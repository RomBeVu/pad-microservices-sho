{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Default to complaining loudly when things don't go according to plan.\n// eslint-disable-next-line no-console\nlet logger = console.error.bind(console);\n// Sets a property on an object, preserving its enumerability.\n// This function assumes that the property is already writable.\nfunction defineProperty(obj, name, value) {\n  const enumerable = !!obj[name] && Object.prototype.propertyIsEnumerable.call(obj, name);\n  Object.defineProperty(obj, name, {\n    configurable: true,\n    enumerable,\n    writable: true,\n    value\n  });\n}\nexport const wrap = (nodule, name, wrapper) => {\n  if (!nodule || !nodule[name]) {\n    logger('no original function ' + String(name) + ' to wrap');\n    return;\n  }\n  if (!wrapper) {\n    logger('no wrapper function');\n    logger(new Error().stack);\n    return;\n  }\n  const original = nodule[name];\n  if (typeof original !== 'function' || typeof wrapper !== 'function') {\n    logger('original object and wrapper must be functions');\n    return;\n  }\n  const wrapped = wrapper(original, name);\n  defineProperty(wrapped, '__original', original);\n  defineProperty(wrapped, '__unwrap', () => {\n    if (nodule[name] === wrapped) {\n      defineProperty(nodule, name, original);\n    }\n  });\n  defineProperty(wrapped, '__wrapped', true);\n  defineProperty(nodule, name, wrapped);\n  return wrapped;\n};\nexport const massWrap = (nodules, names, wrapper) => {\n  if (!nodules) {\n    logger('must provide one or more modules to patch');\n    logger(new Error().stack);\n    return;\n  } else if (!Array.isArray(nodules)) {\n    nodules = [nodules];\n  }\n  if (!(names && Array.isArray(names))) {\n    logger('must provide one or more functions to wrap on modules');\n    return;\n  }\n  nodules.forEach(nodule => {\n    names.forEach(name => {\n      wrap(nodule, name, wrapper);\n    });\n  });\n};\nexport const unwrap = (nodule, name) => {\n  if (!nodule || !nodule[name]) {\n    logger('no function to unwrap.');\n    logger(new Error().stack);\n    return;\n  }\n  const wrapped = nodule[name];\n  if (!wrapped.__unwrap) {\n    logger('no original to unwrap to -- has ' + String(name) + ' already been unwrapped?');\n  } else {\n    wrapped.__unwrap();\n    return;\n  }\n};\nexport const massUnwrap = (nodules, names) => {\n  if (!nodules) {\n    logger('must provide one or more modules to patch');\n    logger(new Error().stack);\n    return;\n  } else if (!Array.isArray(nodules)) {\n    nodules = [nodules];\n  }\n  if (!(names && Array.isArray(names))) {\n    logger('must provide one or more functions to unwrap on modules');\n    return;\n  }\n  nodules.forEach(nodule => {\n    names.forEach(name => {\n      unwrap(nodule, name);\n    });\n  });\n};\nexport default function shimmer(options) {\n  if (options && options.logger) {\n    if (typeof options.logger !== 'function') {\n      logger(\"new logger isn't a function, not replacing\");\n    } else {\n      logger = options.logger;\n    }\n  }\n}\nshimmer.wrap = wrap;\nshimmer.massWrap = massWrap;\nshimmer.unwrap = unwrap;\nshimmer.massUnwrap = massUnwrap;","map":{"version":3,"names":["logger","console","error","bind","defineProperty","obj","name","value","enumerable","Object","prototype","propertyIsEnumerable","call","configurable","writable","wrap","nodule","wrapper","String","Error","stack","original","wrapped","massWrap","nodules","names","Array","isArray","forEach","unwrap","__unwrap","massUnwrap","shimmer","options"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/instrumentation/src/shimmer.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * BSD 2-Clause License\n *\n * Copyright (c) 2013-2019, Forrest L Norvell\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* Modified by OpenTelemetry Authors\n *  - converted to TypeScript\n *  - aligned with style-guide\n */\n\nimport { ShimWrapped } from './types';\n\n// Default to complaining loudly when things don't go according to plan.\n// eslint-disable-next-line no-console\nlet logger: typeof console.error = console.error.bind(console);\n\n// Sets a property on an object, preserving its enumerability.\n// This function assumes that the property is already writable.\nfunction defineProperty(obj: object, name: PropertyKey, value: unknown): void {\n  const enumerable =\n    !!obj[name as keyof typeof obj] &&\n    Object.prototype.propertyIsEnumerable.call(obj, name);\n\n  Object.defineProperty(obj, name, {\n    configurable: true,\n    enumerable,\n    writable: true,\n    value,\n  });\n}\n\nexport const wrap = <Nodule extends object, FieldName extends keyof Nodule>(\n  nodule: Nodule,\n  name: FieldName,\n  wrapper: (original: Nodule[FieldName], name: FieldName) => Nodule[FieldName]\n): ShimWrapped | undefined => {\n  if (!nodule || !nodule[name]) {\n    logger('no original function ' + String(name) + ' to wrap');\n    return;\n  }\n\n  if (!wrapper) {\n    logger('no wrapper function');\n    logger(new Error().stack);\n    return;\n  }\n\n  const original = nodule[name];\n\n  if (typeof original !== 'function' || typeof wrapper !== 'function') {\n    logger('original object and wrapper must be functions');\n    return;\n  }\n\n  const wrapped = wrapper(original, name) as object;\n\n  defineProperty(wrapped, '__original', original);\n  defineProperty(wrapped, '__unwrap', () => {\n    if (nodule[name] === wrapped) {\n      defineProperty(nodule, name, original);\n    }\n  });\n  defineProperty(wrapped, '__wrapped', true);\n  defineProperty(nodule, name, wrapped);\n  return wrapped as ShimWrapped;\n};\n\nexport const massWrap = <Nodule extends object, FieldName extends keyof Nodule>(\n  nodules: Nodule[],\n  names: FieldName[],\n  wrapper: (original: Nodule[FieldName]) => Nodule[FieldName]\n): void => {\n  if (!nodules) {\n    logger('must provide one or more modules to patch');\n    logger(new Error().stack);\n    return;\n  } else if (!Array.isArray(nodules)) {\n    nodules = [nodules];\n  }\n\n  if (!(names && Array.isArray(names))) {\n    logger('must provide one or more functions to wrap on modules');\n    return;\n  }\n\n  nodules.forEach(nodule => {\n    names.forEach(name => {\n      wrap(nodule, name, wrapper);\n    });\n  });\n};\n\nexport const unwrap = <Nodule extends object>(\n  nodule: Nodule,\n  name: keyof Nodule\n): void => {\n  if (!nodule || !nodule[name]) {\n    logger('no function to unwrap.');\n    logger(new Error().stack);\n    return;\n  }\n\n  const wrapped = nodule[name] as unknown as ShimWrapped;\n\n  if (!wrapped.__unwrap) {\n    logger(\n      'no original to unwrap to -- has ' +\n        String(name) +\n        ' already been unwrapped?'\n    );\n  } else {\n    wrapped.__unwrap();\n    return;\n  }\n};\n\nexport const massUnwrap = <Nodule extends object>(\n  nodules: Nodule[],\n  names: Array<keyof Nodule>\n): void => {\n  if (!nodules) {\n    logger('must provide one or more modules to patch');\n    logger(new Error().stack);\n    return;\n  } else if (!Array.isArray(nodules)) {\n    nodules = [nodules];\n  }\n\n  if (!(names && Array.isArray(names))) {\n    logger('must provide one or more functions to unwrap on modules');\n    return;\n  }\n\n  nodules.forEach(nodule => {\n    names.forEach(name => {\n      unwrap(nodule, name);\n    });\n  });\n};\n\nexport interface ShimmerOptions {\n  logger?: typeof console.error;\n}\n\nexport default function shimmer(options: ShimmerOptions): void {\n  if (options && options.logger) {\n    if (typeof options.logger !== 'function') {\n      logger(\"new logger isn't a function, not replacing\");\n    } else {\n      logger = options.logger;\n    }\n  }\n}\n\nshimmer.wrap = wrap;\nshimmer.massWrap = massWrap;\nshimmer.unwrap = unwrap;\nshimmer.massUnwrap = massUnwrap;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
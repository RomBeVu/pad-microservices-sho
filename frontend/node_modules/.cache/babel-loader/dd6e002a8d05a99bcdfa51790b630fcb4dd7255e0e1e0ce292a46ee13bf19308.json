{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as api from '@opentelemetry/api';\nimport { internal, ExportResultCode, globalErrorHandler, unrefTimer } from '@opentelemetry/core';\nimport { MetricReader } from './MetricReader';\nimport { callWithTimeout, TimeoutError } from '../utils';\n/**\n * {@link MetricReader} which collects metrics based on a user-configurable time interval, and passes the metrics to\n * the configured {@link PushMetricExporter}\n */\nexport class PeriodicExportingMetricReader extends MetricReader {\n  _interval;\n  _exporter;\n  _exportInterval;\n  _exportTimeout;\n  constructor(options) {\n    super({\n      aggregationSelector: options.exporter.selectAggregation?.bind(options.exporter),\n      aggregationTemporalitySelector: options.exporter.selectAggregationTemporality?.bind(options.exporter),\n      metricProducers: options.metricProducers\n    });\n    if (options.exportIntervalMillis !== undefined && options.exportIntervalMillis <= 0) {\n      throw Error('exportIntervalMillis must be greater than 0');\n    }\n    if (options.exportTimeoutMillis !== undefined && options.exportTimeoutMillis <= 0) {\n      throw Error('exportTimeoutMillis must be greater than 0');\n    }\n    if (options.exportTimeoutMillis !== undefined && options.exportIntervalMillis !== undefined && options.exportIntervalMillis < options.exportTimeoutMillis) {\n      throw Error('exportIntervalMillis must be greater than or equal to exportTimeoutMillis');\n    }\n    this._exportInterval = options.exportIntervalMillis ?? 60000;\n    this._exportTimeout = options.exportTimeoutMillis ?? 30000;\n    this._exporter = options.exporter;\n  }\n  async _runOnce() {\n    try {\n      await callWithTimeout(this._doRun(), this._exportTimeout);\n    } catch (err) {\n      if (err instanceof TimeoutError) {\n        api.diag.error('Export took longer than %s milliseconds and timed out.', this._exportTimeout);\n        return;\n      }\n      globalErrorHandler(err);\n    }\n  }\n  async _doRun() {\n    const {\n      resourceMetrics,\n      errors\n    } = await this.collect({\n      timeoutMillis: this._exportTimeout\n    });\n    if (errors.length > 0) {\n      api.diag.error('PeriodicExportingMetricReader: metrics collection errors', ...errors);\n    }\n    if (resourceMetrics.resource.asyncAttributesPending) {\n      try {\n        await resourceMetrics.resource.waitForAsyncAttributes?.();\n      } catch (e) {\n        api.diag.debug('Error while resolving async portion of resource: ', e);\n        globalErrorHandler(e);\n      }\n    }\n    if (resourceMetrics.scopeMetrics.length === 0) {\n      return;\n    }\n    const result = await internal._export(this._exporter, resourceMetrics);\n    if (result.code !== ExportResultCode.SUCCESS) {\n      throw new Error(`PeriodicExportingMetricReader: metrics export failed (error ${result.error})`);\n    }\n  }\n  onInitialized() {\n    // start running the interval as soon as this reader is initialized and keep handle for shutdown.\n    this._interval = setInterval(() => {\n      // this._runOnce never rejects. Using void operator to suppress @typescript-eslint/no-floating-promises.\n      void this._runOnce();\n    }, this._exportInterval);\n    unrefTimer(this._interval);\n  }\n  async onForceFlush() {\n    await this._runOnce();\n    await this._exporter.forceFlush();\n  }\n  async onShutdown() {\n    if (this._interval) {\n      clearInterval(this._interval);\n    }\n    await this.onForceFlush();\n    await this._exporter.shutdown();\n  }\n}","map":{"version":3,"names":["api","internal","ExportResultCode","globalErrorHandler","unrefTimer","MetricReader","callWithTimeout","TimeoutError","PeriodicExportingMetricReader","_interval","_exporter","_exportInterval","_exportTimeout","constructor","options","aggregationSelector","exporter","selectAggregation","bind","aggregationTemporalitySelector","selectAggregationTemporality","metricProducers","exportIntervalMillis","undefined","Error","exportTimeoutMillis","_runOnce","_doRun","err","diag","error","resourceMetrics","errors","collect","timeoutMillis","length","resource","asyncAttributesPending","waitForAsyncAttributes","e","debug","scopeMetrics","result","_export","code","SUCCESS","onInitialized","setInterval","onForceFlush","forceFlush","onShutdown","clearInterval","shutdown"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/sdk-metrics/src/export/PeriodicExportingMetricReader.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport {\n  internal,\n  ExportResultCode,\n  globalErrorHandler,\n  unrefTimer,\n} from '@opentelemetry/core';\nimport { MetricReader } from './MetricReader';\nimport { PushMetricExporter } from './MetricExporter';\nimport { callWithTimeout, TimeoutError } from '../utils';\nimport { MetricProducer } from './MetricProducer';\n\nexport type PeriodicExportingMetricReaderOptions = {\n  /**\n   * The backing exporter for the metric reader.\n   */\n  exporter: PushMetricExporter;\n  /**\n   * An internal milliseconds for the metric reader to initiate metric\n   * collection.\n   */\n  exportIntervalMillis?: number;\n  /**\n   * Milliseconds for the async observable callback to timeout.\n   */\n  exportTimeoutMillis?: number;\n  /**\n   * **Note, this option is experimental**. Additional MetricProducers to use as a source of\n   * aggregated metric data in addition to the SDK's metric data. The resource returned by\n   * these MetricProducers is ignored; the SDK's resource will be used instead.\n   * @experimental\n   */\n  metricProducers?: MetricProducer[];\n};\n\n/**\n * {@link MetricReader} which collects metrics based on a user-configurable time interval, and passes the metrics to\n * the configured {@link PushMetricExporter}\n */\nexport class PeriodicExportingMetricReader extends MetricReader {\n  private _interval?: ReturnType<typeof setInterval>;\n  private _exporter: PushMetricExporter;\n  private readonly _exportInterval: number;\n  private readonly _exportTimeout: number;\n\n  constructor(options: PeriodicExportingMetricReaderOptions) {\n    super({\n      aggregationSelector: options.exporter.selectAggregation?.bind(\n        options.exporter\n      ),\n      aggregationTemporalitySelector:\n        options.exporter.selectAggregationTemporality?.bind(options.exporter),\n      metricProducers: options.metricProducers,\n    });\n\n    if (\n      options.exportIntervalMillis !== undefined &&\n      options.exportIntervalMillis <= 0\n    ) {\n      throw Error('exportIntervalMillis must be greater than 0');\n    }\n\n    if (\n      options.exportTimeoutMillis !== undefined &&\n      options.exportTimeoutMillis <= 0\n    ) {\n      throw Error('exportTimeoutMillis must be greater than 0');\n    }\n\n    if (\n      options.exportTimeoutMillis !== undefined &&\n      options.exportIntervalMillis !== undefined &&\n      options.exportIntervalMillis < options.exportTimeoutMillis\n    ) {\n      throw Error(\n        'exportIntervalMillis must be greater than or equal to exportTimeoutMillis'\n      );\n    }\n\n    this._exportInterval = options.exportIntervalMillis ?? 60000;\n    this._exportTimeout = options.exportTimeoutMillis ?? 30000;\n    this._exporter = options.exporter;\n  }\n\n  private async _runOnce(): Promise<void> {\n    try {\n      await callWithTimeout(this._doRun(), this._exportTimeout);\n    } catch (err) {\n      if (err instanceof TimeoutError) {\n        api.diag.error(\n          'Export took longer than %s milliseconds and timed out.',\n          this._exportTimeout\n        );\n        return;\n      }\n\n      globalErrorHandler(err);\n    }\n  }\n\n  private async _doRun(): Promise<void> {\n    const { resourceMetrics, errors } = await this.collect({\n      timeoutMillis: this._exportTimeout,\n    });\n\n    if (errors.length > 0) {\n      api.diag.error(\n        'PeriodicExportingMetricReader: metrics collection errors',\n        ...errors\n      );\n    }\n\n    if (resourceMetrics.resource.asyncAttributesPending) {\n      try {\n        await resourceMetrics.resource.waitForAsyncAttributes?.();\n      } catch (e) {\n        api.diag.debug('Error while resolving async portion of resource: ', e);\n        globalErrorHandler(e);\n      }\n    }\n\n    if (resourceMetrics.scopeMetrics.length === 0) {\n      return;\n    }\n\n    const result = await internal._export(this._exporter, resourceMetrics);\n    if (result.code !== ExportResultCode.SUCCESS) {\n      throw new Error(\n        `PeriodicExportingMetricReader: metrics export failed (error ${result.error})`\n      );\n    }\n  }\n\n  protected override onInitialized(): void {\n    // start running the interval as soon as this reader is initialized and keep handle for shutdown.\n    this._interval = setInterval(() => {\n      // this._runOnce never rejects. Using void operator to suppress @typescript-eslint/no-floating-promises.\n      void this._runOnce();\n    }, this._exportInterval);\n    unrefTimer(this._interval);\n  }\n\n  protected async onForceFlush(): Promise<void> {\n    await this._runOnce();\n    await this._exporter.forceFlush();\n  }\n\n  protected async onShutdown(): Promise<void> {\n    if (this._interval) {\n      clearInterval(this._interval);\n    }\n    await this.onForceFlush();\n    await this._exporter.shutdown();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
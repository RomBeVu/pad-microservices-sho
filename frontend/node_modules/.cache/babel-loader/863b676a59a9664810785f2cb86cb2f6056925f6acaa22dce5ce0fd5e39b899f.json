{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// https://tc39.es/proposal-regex-escaping\n// escape ^ $ \\ .  + ? ( ) [ ] { } |\n// do not need to escape * as we interpret it as wildcard\nconst ESCAPE = /[\\^$\\\\.+?()[\\]{}|]/g;\n/**\n * Wildcard pattern predicate, supports patterns like `*`, `foo*`, `*bar`.\n */\nexport class PatternPredicate {\n  _matchAll;\n  _regexp;\n  constructor(pattern) {\n    if (pattern === '*') {\n      this._matchAll = true;\n      this._regexp = /.*/;\n    } else {\n      this._matchAll = false;\n      this._regexp = new RegExp(PatternPredicate.escapePattern(pattern));\n    }\n  }\n  match(str) {\n    if (this._matchAll) {\n      return true;\n    }\n    return this._regexp.test(str);\n  }\n  static escapePattern(pattern) {\n    return `^${pattern.replace(ESCAPE, '\\\\$&').replace('*', '.*')}$`;\n  }\n  static hasWildcard(pattern) {\n    return pattern.includes('*');\n  }\n}\nexport class ExactPredicate {\n  _matchAll;\n  _pattern;\n  constructor(pattern) {\n    this._matchAll = pattern === undefined;\n    this._pattern = pattern;\n  }\n  match(str) {\n    if (this._matchAll) {\n      return true;\n    }\n    if (str === this._pattern) {\n      return true;\n    }\n    return false;\n  }\n}","map":{"version":3,"names":["ESCAPE","PatternPredicate","_matchAll","_regexp","constructor","pattern","RegExp","escapePattern","match","str","test","replace","hasWildcard","includes","ExactPredicate","_pattern","undefined"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/sdk-metrics/src/view/Predicate.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// https://tc39.es/proposal-regex-escaping\n// escape ^ $ \\ .  + ? ( ) [ ] { } |\n// do not need to escape * as we interpret it as wildcard\nconst ESCAPE = /[\\^$\\\\.+?()[\\]{}|]/g;\n\nexport interface Predicate {\n  match(str: string): boolean;\n}\n\n/**\n * Wildcard pattern predicate, supports patterns like `*`, `foo*`, `*bar`.\n */\nexport class PatternPredicate implements Predicate {\n  private _matchAll: boolean;\n  private _regexp: RegExp;\n\n  constructor(pattern: string) {\n    if (pattern === '*') {\n      this._matchAll = true;\n      this._regexp = /.*/;\n    } else {\n      this._matchAll = false;\n      this._regexp = new RegExp(PatternPredicate.escapePattern(pattern));\n    }\n  }\n\n  match(str: string): boolean {\n    if (this._matchAll) {\n      return true;\n    }\n\n    return this._regexp.test(str);\n  }\n\n  static escapePattern(pattern: string): string {\n    return `^${pattern.replace(ESCAPE, '\\\\$&').replace('*', '.*')}$`;\n  }\n\n  static hasWildcard(pattern: string): boolean {\n    return pattern.includes('*');\n  }\n}\n\nexport class ExactPredicate implements Predicate {\n  private _matchAll: boolean;\n  private _pattern?: string;\n\n  constructor(pattern?: string) {\n    this._matchAll = pattern === undefined;\n    this._pattern = pattern;\n  }\n\n  match(str: string): boolean {\n    if (this._matchAll) {\n      return true;\n    }\n    if (str === this._pattern) {\n      return true;\n    }\n    return false;\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAgBA;AACA;AACA;AACA,MAAMA,MAAM,GAAG,qBAAqB;AAMpC;;;AAGA,OAAM,MAAOC,gBAAgB;EACnBC,SAAS;EACTC,OAAO;EAEfC,YAAYC,OAAe;IACzB,IAAIA,OAAO,KAAK,GAAG,EAAE;MACnB,IAAI,CAACH,SAAS,GAAG,IAAI;MACrB,IAAI,CAACC,OAAO,GAAG,IAAI;KACpB,MAAM;MACL,IAAI,CAACD,SAAS,GAAG,KAAK;MACtB,IAAI,CAACC,OAAO,GAAG,IAAIG,MAAM,CAACL,gBAAgB,CAACM,aAAa,CAACF,OAAO,CAAC,CAAC;;EAEtE;EAEAG,KAAKA,CAACC,GAAW;IACf,IAAI,IAAI,CAACP,SAAS,EAAE;MAClB,OAAO,IAAI;;IAGb,OAAO,IAAI,CAACC,OAAO,CAACO,IAAI,CAACD,GAAG,CAAC;EAC/B;EAEA,OAAOF,aAAaA,CAACF,OAAe;IAClC,OAAO,IAAIA,OAAO,CAACM,OAAO,CAACX,MAAM,EAAE,MAAM,CAAC,CAACW,OAAO,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG;EAClE;EAEA,OAAOC,WAAWA,CAACP,OAAe;IAChC,OAAOA,OAAO,CAACQ,QAAQ,CAAC,GAAG,CAAC;EAC9B;;AAGF,OAAM,MAAOC,cAAc;EACjBZ,SAAS;EACTa,QAAQ;EAEhBX,YAAYC,OAAgB;IAC1B,IAAI,CAACH,SAAS,GAAGG,OAAO,KAAKW,SAAS;IACtC,IAAI,CAACD,QAAQ,GAAGV,OAAO;EACzB;EAEAG,KAAKA,CAACC,GAAW;IACf,IAAI,IAAI,CAACP,SAAS,EAAE;MAClB,OAAO,IAAI;;IAEb,IAAIO,GAAG,KAAK,IAAI,CAACM,QAAQ,EAAE;MACzB,OAAO,IAAI;;IAEb,OAAO,KAAK;EACd","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
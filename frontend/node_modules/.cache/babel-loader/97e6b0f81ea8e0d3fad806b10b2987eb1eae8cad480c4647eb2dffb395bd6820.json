{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/// <reference types=\"zone.js\" />\nimport { ROOT_CONTEXT } from '@opentelemetry/api';\nimport { isListenerObject } from './util';\n/* Key name to be used to save a context reference in Zone */\nconst ZONE_CONTEXT_KEY = 'OT_ZONE_CONTEXT';\n/**\n * ZoneContextManager\n * This module provides an easy functionality for tracing action between asynchronous operations in web.\n * It was not possible with standard [StackContextManager]{@link https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-sdk-trace-web/src/StackContextManager.ts}.\n * It heavily depends on [zone.js]{@link https://www.npmjs.com/package/zone.js}.\n * It stores the information about context in zone. Each Context will have always new Zone;\n * It also supports binding a certain Span to a target that has \"addEventListener\" and \"removeEventListener\".\n * When this happens a new zone is being created and the provided Span is being assigned to this zone.\n */\nexport class ZoneContextManager {\n  /**\n   * whether the context manager is enabled or not\n   */\n  _enabled = false;\n  /**\n   * Helps to create a unique name for the zones - part of zone name\n   */\n  _zoneCounter = 0;\n  /**\n   * Returns the active context from certain zone name\n   * @param activeZone\n   */\n  _activeContextFromZone(activeZone) {\n    return activeZone && activeZone.get(ZONE_CONTEXT_KEY) || ROOT_CONTEXT;\n  }\n  /**\n   * @param context A context (span) to be executed within target function\n   * @param target Function to be executed within the context\n   */\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  _bindFunction(context, target) {\n    const manager = this;\n    const contextWrapper = function (...args) {\n      return manager.with(context, () => target.apply(this, args));\n    };\n    Object.defineProperty(contextWrapper, 'length', {\n      enumerable: false,\n      configurable: true,\n      writable: false,\n      value: target.length\n    });\n    return contextWrapper;\n  }\n  /**\n   * @param context A context (span) to be bind to target\n   * @param obj target object on which the listeners will be patched\n   */\n  _bindListener(context, obj) {\n    const target = obj;\n    if (target.__ot_listeners !== undefined) {\n      return obj;\n    }\n    target.__ot_listeners = {};\n    if (typeof target.addEventListener === 'function') {\n      target.addEventListener = this._patchAddEventListener(target, target.addEventListener, context);\n    }\n    if (typeof target.removeEventListener === 'function') {\n      target.removeEventListener = this._patchRemoveEventListener(target, target.removeEventListener);\n    }\n    return obj;\n  }\n  /**\n   * Creates a new unique zone name\n   */\n  _createZoneName() {\n    this._zoneCounter++;\n    const random = Math.random();\n    return `${this._zoneCounter}-${random}`;\n  }\n  /**\n   * Creates a new zone\n   * @param zoneName zone name\n   * @param context A context (span) to be bind with Zone\n   */\n  _createZone(zoneName, context) {\n    return Zone.current.fork({\n      name: zoneName,\n      properties: {\n        [ZONE_CONTEXT_KEY]: context\n      }\n    });\n  }\n  /**\n   * Returns the active zone\n   */\n  _getActiveZone() {\n    return Zone.current;\n  }\n  /**\n   * Patches addEventListener method\n   * @param target any target that has \"addEventListener\" method\n   * @param original reference to the patched method\n   * @param [context] context to be bind to the listener\n   */\n  _patchAddEventListener(target, original, context) {\n    const contextManager = this;\n    return function (event, listener, opts) {\n      if (target.__ot_listeners === undefined) {\n        target.__ot_listeners = {};\n      }\n      let listeners = target.__ot_listeners[event];\n      if (listeners === undefined) {\n        listeners = new WeakMap();\n        target.__ot_listeners[event] = listeners;\n      }\n      const patchedListener = contextManager.bind(context, listener);\n      // store a weak reference of the user listener to ours\n      listeners.set(listener, patchedListener);\n      return original.call(this, event, patchedListener, opts);\n    };\n  }\n  /**\n   * Patches removeEventListener method\n   * @param target any target that has \"removeEventListener\" method\n   * @param original reference to the patched method\n   */\n  _patchRemoveEventListener(target, original) {\n    return function (event, listener) {\n      if (target.__ot_listeners === undefined || target.__ot_listeners[event] === undefined) {\n        return original.call(this, event, listener);\n      }\n      const events = target.__ot_listeners[event];\n      const patchedListener = events.get(listener);\n      events.delete(listener);\n      return original.call(this, event, patchedListener || listener);\n    };\n  }\n  /**\n   * Returns the active context\n   */\n  active() {\n    if (!this._enabled) {\n      return ROOT_CONTEXT;\n    }\n    const activeZone = this._getActiveZone();\n    const active = this._activeContextFromZone(activeZone);\n    if (active) {\n      return active;\n    }\n    return ROOT_CONTEXT;\n  }\n  /**\n   * Binds a the certain context or the active one to the target function and then returns the target\n   * @param context A context (span) to be bind to target\n   * @param target a function or event emitter. When target or one of its callbacks is called,\n   *  the provided context will be used as the active context for the duration of the call.\n   */\n  bind(context, target) {\n    // if no specific context to propagate is given, we use the current one\n    if (context === undefined) {\n      context = this.active();\n    }\n    if (typeof target === 'function') {\n      return this._bindFunction(context, target);\n    } else if (isListenerObject(target)) {\n      this._bindListener(context, target);\n    }\n    return target;\n  }\n  /**\n   * Disable the context manager (clears all the contexts)\n   */\n  disable() {\n    this._enabled = false;\n    return this;\n  }\n  /**\n   * Enables the context manager and creates a default(root) context\n   */\n  enable() {\n    this._enabled = true;\n    return this;\n  }\n  /**\n   * Calls the callback function [fn] with the provided [context].\n   *     If [context] is undefined then it will use the active context.\n   *     The context will be set as active\n   * @param context A context (span) to be called with provided callback\n   * @param fn Callback function\n   * @param thisArg optional receiver to be used for calling fn\n   * @param args optional arguments forwarded to fn\n   */\n  with(context, fn, thisArg, ...args) {\n    const zoneName = this._createZoneName();\n    const newZone = this._createZone(zoneName, context);\n    return newZone.run(fn, thisArg, args);\n  }\n}","map":{"version":3,"names":["ROOT_CONTEXT","isListenerObject","ZONE_CONTEXT_KEY","ZoneContextManager","_enabled","_zoneCounter","_activeContextFromZone","activeZone","get","_bindFunction","context","target","manager","contextWrapper","args","with","apply","Object","defineProperty","enumerable","configurable","writable","value","length","_bindListener","obj","__ot_listeners","undefined","addEventListener","_patchAddEventListener","removeEventListener","_patchRemoveEventListener","_createZoneName","random","Math","_createZone","zoneName","Zone","current","fork","name","properties","_getActiveZone","original","contextManager","event","listener","opts","listeners","WeakMap","patchedListener","bind","set","call","events","delete","active","disable","enable","fn","thisArg","newZone","run"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/context-zone-peer-dep/src/ZoneContextManager.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/// <reference types=\"zone.js\" />\nimport { Context, ContextManager, ROOT_CONTEXT } from '@opentelemetry/api';\nimport { TargetWithEvents } from './types';\nimport { isListenerObject } from './util';\n\n/* Key name to be used to save a context reference in Zone */\nconst ZONE_CONTEXT_KEY = 'OT_ZONE_CONTEXT';\n\n/**\n * ZoneContextManager\n * This module provides an easy functionality for tracing action between asynchronous operations in web.\n * It was not possible with standard [StackContextManager]{@link https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-sdk-trace-web/src/StackContextManager.ts}.\n * It heavily depends on [zone.js]{@link https://www.npmjs.com/package/zone.js}.\n * It stores the information about context in zone. Each Context will have always new Zone;\n * It also supports binding a certain Span to a target that has \"addEventListener\" and \"removeEventListener\".\n * When this happens a new zone is being created and the provided Span is being assigned to this zone.\n */\nexport class ZoneContextManager implements ContextManager {\n  /**\n   * whether the context manager is enabled or not\n   */\n  private _enabled = false;\n\n  /**\n   * Helps to create a unique name for the zones - part of zone name\n   */\n  private _zoneCounter = 0;\n\n  /**\n   * Returns the active context from certain zone name\n   * @param activeZone\n   */\n  private _activeContextFromZone(activeZone: Zone | undefined): Context {\n    return (activeZone && activeZone.get(ZONE_CONTEXT_KEY)) || ROOT_CONTEXT;\n  }\n\n  /**\n   * @param context A context (span) to be executed within target function\n   * @param target Function to be executed within the context\n   */\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  private _bindFunction<T extends Function>(context: Context, target: T): T {\n    const manager = this;\n    const contextWrapper = function (this: unknown, ...args: unknown[]) {\n      return manager.with(context, () => target.apply(this, args));\n    };\n    Object.defineProperty(contextWrapper, 'length', {\n      enumerable: false,\n      configurable: true,\n      writable: false,\n      value: target.length,\n    });\n    return contextWrapper as unknown as T;\n  }\n\n  /**\n   * @param context A context (span) to be bind to target\n   * @param obj target object on which the listeners will be patched\n   */\n  private _bindListener<T>(context: Context, obj: T): T {\n    const target = obj as unknown as TargetWithEvents;\n    if (target.__ot_listeners !== undefined) {\n      return obj;\n    }\n    target.__ot_listeners = {};\n\n    if (typeof target.addEventListener === 'function') {\n      target.addEventListener = this._patchAddEventListener(\n        target,\n        target.addEventListener,\n        context\n      );\n    }\n\n    if (typeof target.removeEventListener === 'function') {\n      target.removeEventListener = this._patchRemoveEventListener(\n        target,\n        target.removeEventListener\n      );\n    }\n\n    return obj;\n  }\n\n  /**\n   * Creates a new unique zone name\n   */\n  private _createZoneName() {\n    this._zoneCounter++;\n    const random = Math.random();\n    return `${this._zoneCounter}-${random}`;\n  }\n\n  /**\n   * Creates a new zone\n   * @param zoneName zone name\n   * @param context A context (span) to be bind with Zone\n   */\n  private _createZone(zoneName: string, context: unknown): Zone {\n    return Zone.current.fork({\n      name: zoneName,\n      properties: {\n        [ZONE_CONTEXT_KEY]: context,\n      },\n    });\n  }\n\n  /**\n   * Returns the active zone\n   */\n  private _getActiveZone(): Zone | undefined {\n    return Zone.current;\n  }\n\n  /**\n   * Patches addEventListener method\n   * @param target any target that has \"addEventListener\" method\n   * @param original reference to the patched method\n   * @param [context] context to be bind to the listener\n   */\n  private _patchAddEventListener(\n    target: TargetWithEvents,\n    original: NonNullable<TargetWithEvents['addEventListener']>,\n    context: Context\n  ) {\n    const contextManager = this;\n\n    return function (this: TargetWithEvents, event, listener, opts) {\n      if (target.__ot_listeners === undefined) {\n        target.__ot_listeners = {};\n      }\n      let listeners = target.__ot_listeners[event];\n      if (listeners === undefined) {\n        listeners = new WeakMap();\n        target.__ot_listeners[event] = listeners;\n      }\n      const patchedListener = contextManager.bind(context, listener);\n      // store a weak reference of the user listener to ours\n      listeners.set(listener, patchedListener);\n      return original.call(this, event, patchedListener, opts);\n    } as TargetWithEvents['addEventListener'];\n  }\n\n  /**\n   * Patches removeEventListener method\n   * @param target any target that has \"removeEventListener\" method\n   * @param original reference to the patched method\n   */\n  private _patchRemoveEventListener(\n    target: TargetWithEvents,\n    original: NonNullable<TargetWithEvents['removeEventListener']>\n  ) {\n    return function (this: TargetWithEvents, event, listener) {\n      if (\n        target.__ot_listeners === undefined ||\n        target.__ot_listeners[event] === undefined\n      ) {\n        return original.call(this, event, listener);\n      }\n      const events = target.__ot_listeners[event];\n      const patchedListener = events.get(listener);\n      events.delete(listener);\n      return original.call(this, event, patchedListener || listener);\n    } as TargetWithEvents['removeEventListener'];\n  }\n\n  /**\n   * Returns the active context\n   */\n  active(): Context {\n    if (!this._enabled) {\n      return ROOT_CONTEXT;\n    }\n    const activeZone = this._getActiveZone();\n\n    const active = this._activeContextFromZone(activeZone);\n    if (active) {\n      return active;\n    }\n\n    return ROOT_CONTEXT;\n  }\n\n  /**\n   * Binds a the certain context or the active one to the target function and then returns the target\n   * @param context A context (span) to be bind to target\n   * @param target a function or event emitter. When target or one of its callbacks is called,\n   *  the provided context will be used as the active context for the duration of the call.\n   */\n  bind<T>(context: Context, target: T | TargetWithEvents): T {\n    // if no specific context to propagate is given, we use the current one\n    if (context === undefined) {\n      context = this.active();\n    }\n    if (typeof target === 'function') {\n      return this._bindFunction(context, target);\n    } else if (isListenerObject(target)) {\n      this._bindListener(context, target);\n    }\n    return target as unknown as T;\n  }\n\n  /**\n   * Disable the context manager (clears all the contexts)\n   */\n  disable(): this {\n    this._enabled = false;\n    return this;\n  }\n\n  /**\n   * Enables the context manager and creates a default(root) context\n   */\n  enable(): this {\n    this._enabled = true;\n    return this;\n  }\n\n  /**\n   * Calls the callback function [fn] with the provided [context].\n   *     If [context] is undefined then it will use the active context.\n   *     The context will be set as active\n   * @param context A context (span) to be called with provided callback\n   * @param fn Callback function\n   * @param thisArg optional receiver to be used for calling fn\n   * @param args optional arguments forwarded to fn\n   */\n  with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n    context: Context | null,\n    fn: F,\n    thisArg?: ThisParameterType<F>,\n    ...args: A\n  ): ReturnType<F> {\n    const zoneName = this._createZoneName();\n\n    const newZone = this._createZone(zoneName, context);\n\n    return newZone.run(fn, thisArg, args);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as api from '@opentelemetry/api';\nimport { SemconvStability, semconvStabilityFromStr, isWrapped, InstrumentationBase, safeExecuteInTheMiddle } from '@opentelemetry/instrumentation';\nimport { hrTime, isUrlIgnored, otperformance } from '@opentelemetry/core';\nimport { addSpanNetworkEvents, getResource, PerformanceTimingNames as PTN, shouldPropagateTraceHeaders, parseUrl } from '@opentelemetry/sdk-trace-web';\nimport { ATTR_ERROR_TYPE, ATTR_HTTP_REQUEST_METHOD, ATTR_HTTP_REQUEST_METHOD_ORIGINAL, ATTR_HTTP_RESPONSE_STATUS_CODE, ATTR_SERVER_ADDRESS, ATTR_SERVER_PORT, ATTR_URL_FULL } from '@opentelemetry/semantic-conventions';\nimport { ATTR_HTTP_HOST, ATTR_HTTP_METHOD, ATTR_HTTP_SCHEME, ATTR_HTTP_STATUS_CODE, ATTR_HTTP_URL, ATTR_HTTP_USER_AGENT, ATTR_HTTP_REQUEST_BODY_SIZE, ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED } from './semconv';\nimport { EventNames } from './enums/EventNames';\nimport { normalizeHttpRequestMethod, serverPortFromUrl, getXHRBodyLength } from './utils';\nimport { VERSION } from './version';\nimport { AttributeNames } from './enums/AttributeNames';\n// how long to wait for observer to collect information about resources\n// this is needed as event \"load\" is called before observer\n// hard to say how long it should really wait, seems like 300ms is\n// safe enough\nconst OBSERVER_WAIT_TIME_MS = 300;\n/**\n * This class represents a XMLHttpRequest plugin for auto instrumentation\n */\nexport class XMLHttpRequestInstrumentation extends InstrumentationBase {\n  component = 'xml-http-request';\n  version = VERSION;\n  moduleName = this.component;\n  _tasksCount = 0;\n  _xhrMem = new WeakMap();\n  _usedResources = new WeakSet();\n  _semconvStability;\n  constructor(config = {}) {\n    super('@opentelemetry/instrumentation-xml-http-request', VERSION, config);\n    this._semconvStability = semconvStabilityFromStr('http', config?.semconvStabilityOptIn);\n  }\n  init() {}\n  /**\n   * Adds custom headers to XMLHttpRequest\n   * @param xhr\n   * @param spanUrl\n   * @private\n   */\n  _addHeaders(xhr, spanUrl) {\n    const url = parseUrl(spanUrl).href;\n    if (!shouldPropagateTraceHeaders(url, this.getConfig().propagateTraceHeaderCorsUrls)) {\n      const headers = {};\n      api.propagation.inject(api.context.active(), headers);\n      if (Object.keys(headers).length > 0) {\n        this._diag.debug('headers inject skipped due to CORS policy');\n      }\n      return;\n    }\n    const headers = {};\n    api.propagation.inject(api.context.active(), headers);\n    Object.keys(headers).forEach(key => {\n      xhr.setRequestHeader(key, String(headers[key]));\n    });\n  }\n  /**\n   * Add cors pre flight child span\n   * @param span\n   * @param corsPreFlightRequest\n   * @private\n   */\n  _addChildSpan(span, corsPreFlightRequest) {\n    api.context.with(api.trace.setSpan(api.context.active(), span), () => {\n      const childSpan = this.tracer.startSpan('CORS Preflight', {\n        startTime: corsPreFlightRequest[PTN.FETCH_START]\n      });\n      const skipOldSemconvContentLengthAttrs = !(this._semconvStability & SemconvStability.OLD);\n      addSpanNetworkEvents(childSpan, corsPreFlightRequest, this.getConfig().ignoreNetworkEvents, undefined, skipOldSemconvContentLengthAttrs);\n      childSpan.end(corsPreFlightRequest[PTN.RESPONSE_END]);\n    });\n  }\n  /**\n   * Add attributes when span is going to end\n   * @param span\n   * @param xhr\n   * @param spanUrl\n   * @private\n   */\n  _addFinalSpanAttributes(span, xhrMem, spanUrl) {\n    if (this._semconvStability & SemconvStability.OLD) {\n      if (xhrMem.status !== undefined) {\n        span.setAttribute(ATTR_HTTP_STATUS_CODE, xhrMem.status);\n      }\n      if (xhrMem.statusText !== undefined) {\n        span.setAttribute(AttributeNames.HTTP_STATUS_TEXT, xhrMem.statusText);\n      }\n      if (typeof spanUrl === 'string') {\n        const parsedUrl = parseUrl(spanUrl);\n        span.setAttribute(ATTR_HTTP_HOST, parsedUrl.host);\n        span.setAttribute(ATTR_HTTP_SCHEME, parsedUrl.protocol.replace(':', ''));\n      }\n      // @TODO do we want to collect this or it will be collected earlier once only or\n      //    maybe when parent span is not available ?\n      span.setAttribute(ATTR_HTTP_USER_AGENT, navigator.userAgent);\n    }\n    if (this._semconvStability & SemconvStability.STABLE) {\n      if (xhrMem.status) {\n        // Intentionally exclude status=0, because XHR uses 0 for before a\n        // response is received and semconv says to only add the attribute if\n        // received a response.\n        span.setAttribute(ATTR_HTTP_RESPONSE_STATUS_CODE, xhrMem.status);\n      }\n    }\n  }\n  _applyAttributesAfterXHR(span, xhr) {\n    const applyCustomAttributesOnSpan = this.getConfig().applyCustomAttributesOnSpan;\n    if (typeof applyCustomAttributesOnSpan === 'function') {\n      safeExecuteInTheMiddle(() => applyCustomAttributesOnSpan(span, xhr), error => {\n        if (!error) {\n          return;\n        }\n        this._diag.error('applyCustomAttributesOnSpan', error);\n      }, true);\n    }\n  }\n  /**\n   * will collect information about all resources created\n   * between \"send\" and \"end\" with additional waiting for main resource\n   * @param xhr\n   * @param spanUrl\n   * @private\n   */\n  _addResourceObserver(xhr, spanUrl) {\n    const xhrMem = this._xhrMem.get(xhr);\n    if (!xhrMem || typeof PerformanceObserver !== 'function' || typeof PerformanceResourceTiming !== 'function') {\n      return;\n    }\n    xhrMem.createdResources = {\n      observer: new PerformanceObserver(list => {\n        const entries = list.getEntries();\n        const parsedUrl = parseUrl(spanUrl);\n        entries.forEach(entry => {\n          if (entry.initiatorType === 'xmlhttprequest' && entry.name === parsedUrl.href) {\n            if (xhrMem.createdResources) {\n              xhrMem.createdResources.entries.push(entry);\n            }\n          }\n        });\n      }),\n      entries: []\n    };\n    xhrMem.createdResources.observer.observe({\n      entryTypes: ['resource']\n    });\n  }\n  /**\n   * Clears the resource timings and all resources assigned with spans\n   *     when {@link XMLHttpRequestInstrumentationConfig.clearTimingResources} is\n   *     set to true (default false)\n   * @private\n   */\n  _clearResources() {\n    if (this._tasksCount === 0 && this.getConfig().clearTimingResources) {\n      otperformance.clearResourceTimings();\n      this._xhrMem = new WeakMap();\n      this._usedResources = new WeakSet();\n    }\n  }\n  /**\n   * Finds appropriate resource and add network events to the span\n   * @param span\n   */\n  _findResourceAndAddNetworkEvents(xhrMem, span, spanUrl, startTime, endTime) {\n    if (!spanUrl || !startTime || !endTime || !xhrMem.createdResources) {\n      return;\n    }\n    let resources = xhrMem.createdResources.entries;\n    if (!resources || !resources.length) {\n      // fallback - either Observer is not available or it took longer\n      // then OBSERVER_WAIT_TIME_MS and observer didn't collect enough\n      // information\n      // ts thinks this is the perf_hooks module, but it is the browser performance api\n      resources = otperformance.getEntriesByType('resource');\n    }\n    const resource = getResource(parseUrl(spanUrl).href, startTime, endTime, resources, this._usedResources);\n    if (resource.mainRequest) {\n      const mainRequest = resource.mainRequest;\n      this._markResourceAsUsed(mainRequest);\n      const corsPreFlightRequest = resource.corsPreFlightRequest;\n      if (corsPreFlightRequest) {\n        this._addChildSpan(span, corsPreFlightRequest);\n        this._markResourceAsUsed(corsPreFlightRequest);\n      }\n      const skipOldSemconvContentLengthAttrs = !(this._semconvStability & SemconvStability.OLD);\n      addSpanNetworkEvents(span, mainRequest, this.getConfig().ignoreNetworkEvents, undefined, skipOldSemconvContentLengthAttrs);\n    }\n  }\n  /**\n   * Removes the previous information about span.\n   * This might happened when the same xhr is used again.\n   * @param xhr\n   * @private\n   */\n  _cleanPreviousSpanInformation(xhr) {\n    const xhrMem = this._xhrMem.get(xhr);\n    if (xhrMem) {\n      const callbackToRemoveEvents = xhrMem.callbackToRemoveEvents;\n      if (callbackToRemoveEvents) {\n        callbackToRemoveEvents();\n      }\n      this._xhrMem.delete(xhr);\n    }\n  }\n  /**\n   * Creates a new span when method \"open\" is called\n   * @param xhr\n   * @param url\n   * @param method\n   * @private\n   */\n  _createSpan(xhr, url, method) {\n    if (isUrlIgnored(url, this.getConfig().ignoreUrls)) {\n      this._diag.debug('ignoring span as url matches ignored url');\n      return;\n    }\n    let name = '';\n    const parsedUrl = parseUrl(url);\n    const attributes = {};\n    if (this._semconvStability & SemconvStability.OLD) {\n      name = method.toUpperCase();\n      attributes[ATTR_HTTP_METHOD] = method;\n      attributes[ATTR_HTTP_URL] = parsedUrl.toString();\n    }\n    if (this._semconvStability & SemconvStability.STABLE) {\n      const origMethod = method;\n      const normMethod = normalizeHttpRequestMethod(method);\n      if (!name) {\n        // The \"old\" span name wins if emitting both old and stable semconv\n        // ('http/dup').\n        name = normMethod;\n      }\n      attributes[ATTR_HTTP_REQUEST_METHOD] = normMethod;\n      if (normMethod !== origMethod) {\n        attributes[ATTR_HTTP_REQUEST_METHOD_ORIGINAL] = origMethod;\n      }\n      attributes[ATTR_URL_FULL] = parsedUrl.toString();\n      attributes[ATTR_SERVER_ADDRESS] = parsedUrl.hostname;\n      const serverPort = serverPortFromUrl(parsedUrl);\n      if (serverPort) {\n        attributes[ATTR_SERVER_PORT] = serverPort;\n      }\n    }\n    const currentSpan = this.tracer.startSpan(name, {\n      kind: api.SpanKind.CLIENT,\n      attributes\n    });\n    currentSpan.addEvent(EventNames.METHOD_OPEN);\n    this._cleanPreviousSpanInformation(xhr);\n    this._xhrMem.set(xhr, {\n      span: currentSpan,\n      spanUrl: url\n    });\n    return currentSpan;\n  }\n  /**\n   * Marks certain [resource]{@link PerformanceResourceTiming} when information\n   * from this is used to add events to span.\n   * This is done to avoid reusing the same resource again for next span\n   * @param resource\n   * @private\n   */\n  _markResourceAsUsed(resource) {\n    this._usedResources.add(resource);\n  }\n  /**\n   * Patches the method open\n   * @private\n   */\n  _patchOpen() {\n    return original => {\n      const plugin = this;\n      return function patchOpen(...args) {\n        const method = args[0];\n        const url = args[1];\n        plugin._createSpan(this, url, method);\n        return original.apply(this, args);\n      };\n    };\n  }\n  /**\n   * Patches the method send\n   * @private\n   */\n  _patchSend() {\n    const plugin = this;\n    function endSpanTimeout(eventName, xhrMem, performanceEndTime, endTime) {\n      const callbackToRemoveEvents = xhrMem.callbackToRemoveEvents;\n      if (typeof callbackToRemoveEvents === 'function') {\n        callbackToRemoveEvents();\n      }\n      const {\n        span,\n        spanUrl,\n        sendStartTime\n      } = xhrMem;\n      if (span) {\n        plugin._findResourceAndAddNetworkEvents(xhrMem, span, spanUrl, sendStartTime, performanceEndTime);\n        span.addEvent(eventName, endTime);\n        plugin._addFinalSpanAttributes(span, xhrMem, spanUrl);\n        span.end(endTime);\n        plugin._tasksCount--;\n      }\n      plugin._clearResources();\n    }\n    function endSpan(eventName, xhr, isError, errorType) {\n      const xhrMem = plugin._xhrMem.get(xhr);\n      if (!xhrMem) {\n        return;\n      }\n      xhrMem.status = xhr.status;\n      xhrMem.statusText = xhr.statusText;\n      plugin._xhrMem.delete(xhr);\n      if (xhrMem.span) {\n        const span = xhrMem.span;\n        plugin._applyAttributesAfterXHR(span, xhr);\n        if (plugin._semconvStability & SemconvStability.STABLE) {\n          if (isError) {\n            if (errorType) {\n              span.setStatus({\n                code: api.SpanStatusCode.ERROR,\n                message: errorType\n              });\n              span.setAttribute(ATTR_ERROR_TYPE, errorType);\n            }\n          } else if (xhrMem.status && xhrMem.status >= 400) {\n            span.setStatus({\n              code: api.SpanStatusCode.ERROR\n            });\n            span.setAttribute(ATTR_ERROR_TYPE, String(xhrMem.status));\n          }\n        }\n      }\n      const performanceEndTime = hrTime();\n      const endTime = Date.now();\n      // the timeout is needed as observer doesn't have yet information\n      // when event \"load\" is called. Also the time may differ depends on\n      // browser and speed of computer\n      setTimeout(() => {\n        endSpanTimeout(eventName, xhrMem, performanceEndTime, endTime);\n      }, OBSERVER_WAIT_TIME_MS);\n    }\n    function onError() {\n      endSpan(EventNames.EVENT_ERROR, this, true, 'error');\n    }\n    function onAbort() {\n      endSpan(EventNames.EVENT_ABORT, this, false);\n    }\n    function onTimeout() {\n      endSpan(EventNames.EVENT_TIMEOUT, this, true, 'timeout');\n    }\n    function onLoad() {\n      if (this.status < 299) {\n        endSpan(EventNames.EVENT_LOAD, this, false);\n      } else {\n        endSpan(EventNames.EVENT_ERROR, this, false);\n      }\n    }\n    function unregister(xhr) {\n      xhr.removeEventListener('abort', onAbort);\n      xhr.removeEventListener('error', onError);\n      xhr.removeEventListener('load', onLoad);\n      xhr.removeEventListener('timeout', onTimeout);\n      const xhrMem = plugin._xhrMem.get(xhr);\n      if (xhrMem) {\n        xhrMem.callbackToRemoveEvents = undefined;\n      }\n    }\n    return original => {\n      return function patchSend(...args) {\n        const xhrMem = plugin._xhrMem.get(this);\n        if (!xhrMem) {\n          return original.apply(this, args);\n        }\n        const currentSpan = xhrMem.span;\n        const spanUrl = xhrMem.spanUrl;\n        if (currentSpan && spanUrl) {\n          if (plugin.getConfig().measureRequestSize && args?.[0]) {\n            const body = args[0];\n            const bodyLength = getXHRBodyLength(body);\n            if (bodyLength !== undefined) {\n              if (plugin._semconvStability & SemconvStability.OLD) {\n                currentSpan.setAttribute(ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED, bodyLength);\n              }\n              if (plugin._semconvStability & SemconvStability.STABLE) {\n                currentSpan.setAttribute(ATTR_HTTP_REQUEST_BODY_SIZE, bodyLength);\n              }\n            }\n          }\n          api.context.with(api.trace.setSpan(api.context.active(), currentSpan), () => {\n            plugin._tasksCount++;\n            xhrMem.sendStartTime = hrTime();\n            currentSpan.addEvent(EventNames.METHOD_SEND);\n            this.addEventListener('abort', onAbort);\n            this.addEventListener('error', onError);\n            this.addEventListener('load', onLoad);\n            this.addEventListener('timeout', onTimeout);\n            xhrMem.callbackToRemoveEvents = () => {\n              unregister(this);\n              if (xhrMem.createdResources) {\n                xhrMem.createdResources.observer.disconnect();\n              }\n            };\n            plugin._addHeaders(this, spanUrl);\n            plugin._addResourceObserver(this, spanUrl);\n          });\n        }\n        return original.apply(this, args);\n      };\n    };\n  }\n  /**\n   * implements enable function\n   */\n  enable() {\n    this._diag.debug('applying patch to', this.moduleName, this.version);\n    if (isWrapped(XMLHttpRequest.prototype.open)) {\n      this._unwrap(XMLHttpRequest.prototype, 'open');\n      this._diag.debug('removing previous patch from method open');\n    }\n    if (isWrapped(XMLHttpRequest.prototype.send)) {\n      this._unwrap(XMLHttpRequest.prototype, 'send');\n      this._diag.debug('removing previous patch from method send');\n    }\n    this._wrap(XMLHttpRequest.prototype, 'open', this._patchOpen());\n    this._wrap(XMLHttpRequest.prototype, 'send', this._patchSend());\n  }\n  /**\n   * implements disable function\n   */\n  disable() {\n    this._diag.debug('removing patch from', this.moduleName, this.version);\n    this._unwrap(XMLHttpRequest.prototype, 'open');\n    this._unwrap(XMLHttpRequest.prototype, 'send');\n    this._tasksCount = 0;\n    this._xhrMem = new WeakMap();\n    this._usedResources = new WeakSet();\n  }\n}","map":{"version":3,"names":["api","SemconvStability","semconvStabilityFromStr","isWrapped","InstrumentationBase","safeExecuteInTheMiddle","hrTime","isUrlIgnored","otperformance","addSpanNetworkEvents","getResource","PerformanceTimingNames","PTN","shouldPropagateTraceHeaders","parseUrl","ATTR_ERROR_TYPE","ATTR_HTTP_REQUEST_METHOD","ATTR_HTTP_REQUEST_METHOD_ORIGINAL","ATTR_HTTP_RESPONSE_STATUS_CODE","ATTR_SERVER_ADDRESS","ATTR_SERVER_PORT","ATTR_URL_FULL","ATTR_HTTP_HOST","ATTR_HTTP_METHOD","ATTR_HTTP_SCHEME","ATTR_HTTP_STATUS_CODE","ATTR_HTTP_URL","ATTR_HTTP_USER_AGENT","ATTR_HTTP_REQUEST_BODY_SIZE","ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED","EventNames","normalizeHttpRequestMethod","serverPortFromUrl","getXHRBodyLength","VERSION","AttributeNames","OBSERVER_WAIT_TIME_MS","XMLHttpRequestInstrumentation","component","version","moduleName","_tasksCount","_xhrMem","WeakMap","_usedResources","WeakSet","_semconvStability","constructor","config","semconvStabilityOptIn","init","_addHeaders","xhr","spanUrl","url","href","getConfig","propagateTraceHeaderCorsUrls","headers","propagation","inject","context","active","Object","keys","length","_diag","debug","forEach","key","setRequestHeader","String","_addChildSpan","span","corsPreFlightRequest","with","trace","setSpan","childSpan","tracer","startSpan","startTime","FETCH_START","skipOldSemconvContentLengthAttrs","OLD","ignoreNetworkEvents","undefined","end","RESPONSE_END","_addFinalSpanAttributes","xhrMem","status","setAttribute","statusText","HTTP_STATUS_TEXT","parsedUrl","host","protocol","replace","navigator","userAgent","STABLE","_applyAttributesAfterXHR","applyCustomAttributesOnSpan","error","_addResourceObserver","get","PerformanceObserver","PerformanceResourceTiming","createdResources","observer","list","entries","getEntries","entry","initiatorType","name","push","observe","entryTypes","_clearResources","clearTimingResources","clearResourceTimings","_findResourceAndAddNetworkEvents","endTime","resources","getEntriesByType","resource","mainRequest","_markResourceAsUsed","_cleanPreviousSpanInformation","callbackToRemoveEvents","delete","_createSpan","method","ignoreUrls","attributes","toUpperCase","toString","origMethod","normMethod","hostname","serverPort","currentSpan","kind","SpanKind","CLIENT","addEvent","METHOD_OPEN","set","add","_patchOpen","original","plugin","patchOpen","args","apply","_patchSend","endSpanTimeout","eventName","performanceEndTime","sendStartTime","endSpan","isError","errorType","setStatus","code","SpanStatusCode","ERROR","message","Date","now","setTimeout","onError","EVENT_ERROR","onAbort","EVENT_ABORT","onTimeout","EVENT_TIMEOUT","onLoad","EVENT_LOAD","unregister","removeEventListener","patchSend","measureRequestSize","body","bodyLength","METHOD_SEND","addEventListener","disconnect","enable","XMLHttpRequest","prototype","open","_unwrap","send","_wrap","disable"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/instrumentation-xml-http-request/src/xhr.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport {\n  SemconvStability,\n  semconvStabilityFromStr,\n  isWrapped,\n  InstrumentationBase,\n  InstrumentationConfig,\n  safeExecuteInTheMiddle,\n} from '@opentelemetry/instrumentation';\nimport { hrTime, isUrlIgnored, otperformance } from '@opentelemetry/core';\nimport {\n  addSpanNetworkEvents,\n  getResource,\n  PerformanceTimingNames as PTN,\n  shouldPropagateTraceHeaders,\n  parseUrl,\n} from '@opentelemetry/sdk-trace-web';\nimport {\n  ATTR_ERROR_TYPE,\n  ATTR_HTTP_REQUEST_METHOD,\n  ATTR_HTTP_REQUEST_METHOD_ORIGINAL,\n  ATTR_HTTP_RESPONSE_STATUS_CODE,\n  ATTR_SERVER_ADDRESS,\n  ATTR_SERVER_PORT,\n  ATTR_URL_FULL,\n} from '@opentelemetry/semantic-conventions';\nimport {\n  ATTR_HTTP_HOST,\n  ATTR_HTTP_METHOD,\n  ATTR_HTTP_SCHEME,\n  ATTR_HTTP_STATUS_CODE,\n  ATTR_HTTP_URL,\n  ATTR_HTTP_USER_AGENT,\n  ATTR_HTTP_REQUEST_BODY_SIZE,\n  ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,\n} from './semconv';\nimport { EventNames } from './enums/EventNames';\nimport {\n  OpenFunction,\n  PropagateTraceHeaderCorsUrls,\n  SendFunction,\n  XhrMem,\n} from './types';\nimport {\n  normalizeHttpRequestMethod,\n  serverPortFromUrl,\n  getXHRBodyLength,\n} from './utils';\nimport { VERSION } from './version';\nimport { AttributeNames } from './enums/AttributeNames';\n\n// how long to wait for observer to collect information about resources\n// this is needed as event \"load\" is called before observer\n// hard to say how long it should really wait, seems like 300ms is\n// safe enough\nconst OBSERVER_WAIT_TIME_MS = 300;\n\nexport type XHRCustomAttributeFunction = (\n  span: api.Span,\n  xhr: XMLHttpRequest\n) => void;\n\n/**\n * XMLHttpRequest config\n */\nexport interface XMLHttpRequestInstrumentationConfig\n  extends InstrumentationConfig {\n  /**\n   * The number of timing resources is limited, after the limit\n   * (chrome 250, safari 150) the information is not collected anymore.\n   * The only way to prevent that is to regularly clean the resources\n   * whenever it is possible. This is needed only when PerformanceObserver\n   * is not available\n   */\n  clearTimingResources?: boolean;\n  /** URLs which should include trace headers when origin doesn't match */\n  propagateTraceHeaderCorsUrls?: PropagateTraceHeaderCorsUrls;\n  /**\n   * URLs that partially match any regex in ignoreUrls will not be traced.\n   * In addition, URLs that are _exact matches_ of strings in ignoreUrls will\n   * also not be traced.\n   */\n  ignoreUrls?: Array<string | RegExp>;\n  /** Function for adding custom attributes on the span */\n  applyCustomAttributesOnSpan?: XHRCustomAttributeFunction;\n  /** Ignore adding network events as span events */\n  ignoreNetworkEvents?: boolean;\n  /** Measure outgoing request size */\n  measureRequestSize?: boolean;\n  /** Select the HTTP semantic conventions version(s) used. */\n  semconvStabilityOptIn?: string;\n}\n\n/**\n * This class represents a XMLHttpRequest plugin for auto instrumentation\n */\nexport class XMLHttpRequestInstrumentation extends InstrumentationBase<XMLHttpRequestInstrumentationConfig> {\n  readonly component: string = 'xml-http-request';\n  readonly version: string = VERSION;\n  moduleName = this.component;\n\n  private _tasksCount = 0;\n  private _xhrMem = new WeakMap<XMLHttpRequest, XhrMem>();\n  private _usedResources = new WeakSet<PerformanceResourceTiming>();\n  private _semconvStability: SemconvStability;\n\n  constructor(config: XMLHttpRequestInstrumentationConfig = {}) {\n    super('@opentelemetry/instrumentation-xml-http-request', VERSION, config);\n    this._semconvStability = semconvStabilityFromStr(\n      'http',\n      config?.semconvStabilityOptIn\n    );\n  }\n\n  init() {}\n\n  /**\n   * Adds custom headers to XMLHttpRequest\n   * @param xhr\n   * @param spanUrl\n   * @private\n   */\n  private _addHeaders(xhr: XMLHttpRequest, spanUrl: string) {\n    const url = parseUrl(spanUrl).href;\n    if (\n      !shouldPropagateTraceHeaders(\n        url,\n        this.getConfig().propagateTraceHeaderCorsUrls\n      )\n    ) {\n      const headers: Partial<Record<string, unknown>> = {};\n      api.propagation.inject(api.context.active(), headers);\n      if (Object.keys(headers).length > 0) {\n        this._diag.debug('headers inject skipped due to CORS policy');\n      }\n      return;\n    }\n    const headers: { [key: string]: unknown } = {};\n    api.propagation.inject(api.context.active(), headers);\n    Object.keys(headers).forEach(key => {\n      xhr.setRequestHeader(key, String(headers[key]));\n    });\n  }\n\n  /**\n   * Add cors pre flight child span\n   * @param span\n   * @param corsPreFlightRequest\n   * @private\n   */\n  private _addChildSpan(\n    span: api.Span,\n    corsPreFlightRequest: PerformanceResourceTiming\n  ): void {\n    api.context.with(api.trace.setSpan(api.context.active(), span), () => {\n      const childSpan = this.tracer.startSpan('CORS Preflight', {\n        startTime: corsPreFlightRequest[PTN.FETCH_START],\n      });\n      const skipOldSemconvContentLengthAttrs = !(\n        this._semconvStability & SemconvStability.OLD\n      );\n      addSpanNetworkEvents(\n        childSpan,\n        corsPreFlightRequest,\n        this.getConfig().ignoreNetworkEvents,\n        undefined,\n        skipOldSemconvContentLengthAttrs\n      );\n      childSpan.end(corsPreFlightRequest[PTN.RESPONSE_END]);\n    });\n  }\n\n  /**\n   * Add attributes when span is going to end\n   * @param span\n   * @param xhr\n   * @param spanUrl\n   * @private\n   */\n  _addFinalSpanAttributes(span: api.Span, xhrMem: XhrMem, spanUrl?: string) {\n    if (this._semconvStability & SemconvStability.OLD) {\n      if (xhrMem.status !== undefined) {\n        span.setAttribute(ATTR_HTTP_STATUS_CODE, xhrMem.status);\n      }\n      if (xhrMem.statusText !== undefined) {\n        span.setAttribute(AttributeNames.HTTP_STATUS_TEXT, xhrMem.statusText);\n      }\n      if (typeof spanUrl === 'string') {\n        const parsedUrl = parseUrl(spanUrl);\n        span.setAttribute(ATTR_HTTP_HOST, parsedUrl.host);\n        span.setAttribute(\n          ATTR_HTTP_SCHEME,\n          parsedUrl.protocol.replace(':', '')\n        );\n      }\n\n      // @TODO do we want to collect this or it will be collected earlier once only or\n      //    maybe when parent span is not available ?\n      span.setAttribute(ATTR_HTTP_USER_AGENT, navigator.userAgent);\n    }\n    if (this._semconvStability & SemconvStability.STABLE) {\n      if (xhrMem.status) {\n        // Intentionally exclude status=0, because XHR uses 0 for before a\n        // response is received and semconv says to only add the attribute if\n        // received a response.\n        span.setAttribute(ATTR_HTTP_RESPONSE_STATUS_CODE, xhrMem.status);\n      }\n    }\n  }\n\n  private _applyAttributesAfterXHR(span: api.Span, xhr: XMLHttpRequest) {\n    const applyCustomAttributesOnSpan =\n      this.getConfig().applyCustomAttributesOnSpan;\n    if (typeof applyCustomAttributesOnSpan === 'function') {\n      safeExecuteInTheMiddle(\n        () => applyCustomAttributesOnSpan(span, xhr),\n        error => {\n          if (!error) {\n            return;\n          }\n\n          this._diag.error('applyCustomAttributesOnSpan', error);\n        },\n        true\n      );\n    }\n  }\n\n  /**\n   * will collect information about all resources created\n   * between \"send\" and \"end\" with additional waiting for main resource\n   * @param xhr\n   * @param spanUrl\n   * @private\n   */\n  private _addResourceObserver(xhr: XMLHttpRequest, spanUrl: string) {\n    const xhrMem = this._xhrMem.get(xhr);\n    if (\n      !xhrMem ||\n      typeof PerformanceObserver !== 'function' ||\n      typeof PerformanceResourceTiming !== 'function'\n    ) {\n      return;\n    }\n    xhrMem.createdResources = {\n      observer: new PerformanceObserver(list => {\n        const entries = list.getEntries() as PerformanceResourceTiming[];\n        const parsedUrl = parseUrl(spanUrl);\n\n        entries.forEach(entry => {\n          if (\n            entry.initiatorType === 'xmlhttprequest' &&\n            entry.name === parsedUrl.href\n          ) {\n            if (xhrMem.createdResources) {\n              xhrMem.createdResources.entries.push(entry);\n            }\n          }\n        });\n      }),\n      entries: [],\n    };\n    xhrMem.createdResources.observer.observe({\n      entryTypes: ['resource'],\n    });\n  }\n\n  /**\n   * Clears the resource timings and all resources assigned with spans\n   *     when {@link XMLHttpRequestInstrumentationConfig.clearTimingResources} is\n   *     set to true (default false)\n   * @private\n   */\n  private _clearResources() {\n    if (this._tasksCount === 0 && this.getConfig().clearTimingResources) {\n      (otperformance as unknown as Performance).clearResourceTimings();\n      this._xhrMem = new WeakMap<XMLHttpRequest, XhrMem>();\n      this._usedResources = new WeakSet<PerformanceResourceTiming>();\n    }\n  }\n\n  /**\n   * Finds appropriate resource and add network events to the span\n   * @param span\n   */\n  private _findResourceAndAddNetworkEvents(\n    xhrMem: XhrMem,\n    span: api.Span,\n    spanUrl?: string,\n    startTime?: api.HrTime,\n    endTime?: api.HrTime\n  ): void {\n    if (!spanUrl || !startTime || !endTime || !xhrMem.createdResources) {\n      return;\n    }\n\n    let resources: PerformanceResourceTiming[] =\n      xhrMem.createdResources.entries;\n\n    if (!resources || !resources.length) {\n      // fallback - either Observer is not available or it took longer\n      // then OBSERVER_WAIT_TIME_MS and observer didn't collect enough\n      // information\n      // ts thinks this is the perf_hooks module, but it is the browser performance api\n      resources = (otperformance as unknown as Performance).getEntriesByType(\n        'resource'\n      ) as PerformanceResourceTiming[];\n    }\n\n    const resource = getResource(\n      parseUrl(spanUrl).href,\n      startTime,\n      endTime,\n      resources,\n      this._usedResources\n    );\n\n    if (resource.mainRequest) {\n      const mainRequest = resource.mainRequest;\n      this._markResourceAsUsed(mainRequest);\n\n      const corsPreFlightRequest = resource.corsPreFlightRequest;\n      if (corsPreFlightRequest) {\n        this._addChildSpan(span, corsPreFlightRequest);\n        this._markResourceAsUsed(corsPreFlightRequest);\n      }\n      const skipOldSemconvContentLengthAttrs = !(\n        this._semconvStability & SemconvStability.OLD\n      );\n      addSpanNetworkEvents(\n        span,\n        mainRequest,\n        this.getConfig().ignoreNetworkEvents,\n        undefined,\n        skipOldSemconvContentLengthAttrs\n      );\n    }\n  }\n\n  /**\n   * Removes the previous information about span.\n   * This might happened when the same xhr is used again.\n   * @param xhr\n   * @private\n   */\n  private _cleanPreviousSpanInformation(xhr: XMLHttpRequest) {\n    const xhrMem = this._xhrMem.get(xhr);\n    if (xhrMem) {\n      const callbackToRemoveEvents = xhrMem.callbackToRemoveEvents;\n      if (callbackToRemoveEvents) {\n        callbackToRemoveEvents();\n      }\n      this._xhrMem.delete(xhr);\n    }\n  }\n\n  /**\n   * Creates a new span when method \"open\" is called\n   * @param xhr\n   * @param url\n   * @param method\n   * @private\n   */\n  private _createSpan(\n    xhr: XMLHttpRequest,\n    url: string,\n    method: string\n  ): api.Span | undefined {\n    if (isUrlIgnored(url, this.getConfig().ignoreUrls)) {\n      this._diag.debug('ignoring span as url matches ignored url');\n      return;\n    }\n\n    let name = '';\n    const parsedUrl = parseUrl(url);\n    const attributes = {} as api.Attributes;\n    if (this._semconvStability & SemconvStability.OLD) {\n      name = method.toUpperCase();\n      attributes[ATTR_HTTP_METHOD] = method;\n      attributes[ATTR_HTTP_URL] = parsedUrl.toString();\n    }\n    if (this._semconvStability & SemconvStability.STABLE) {\n      const origMethod = method;\n      const normMethod = normalizeHttpRequestMethod(method);\n      if (!name) {\n        // The \"old\" span name wins if emitting both old and stable semconv\n        // ('http/dup').\n        name = normMethod;\n      }\n      attributes[ATTR_HTTP_REQUEST_METHOD] = normMethod;\n      if (normMethod !== origMethod) {\n        attributes[ATTR_HTTP_REQUEST_METHOD_ORIGINAL] = origMethod;\n      }\n      attributes[ATTR_URL_FULL] = parsedUrl.toString();\n      attributes[ATTR_SERVER_ADDRESS] = parsedUrl.hostname;\n      const serverPort = serverPortFromUrl(parsedUrl);\n      if (serverPort) {\n        attributes[ATTR_SERVER_PORT] = serverPort;\n      }\n    }\n\n    const currentSpan = this.tracer.startSpan(name, {\n      kind: api.SpanKind.CLIENT,\n      attributes,\n    });\n\n    currentSpan.addEvent(EventNames.METHOD_OPEN);\n\n    this._cleanPreviousSpanInformation(xhr);\n\n    this._xhrMem.set(xhr, {\n      span: currentSpan,\n      spanUrl: url,\n    });\n\n    return currentSpan;\n  }\n\n  /**\n   * Marks certain [resource]{@link PerformanceResourceTiming} when information\n   * from this is used to add events to span.\n   * This is done to avoid reusing the same resource again for next span\n   * @param resource\n   * @private\n   */\n  private _markResourceAsUsed(resource: PerformanceResourceTiming) {\n    this._usedResources.add(resource);\n  }\n\n  /**\n   * Patches the method open\n   * @private\n   */\n  protected _patchOpen() {\n    return (original: OpenFunction): OpenFunction => {\n      const plugin = this;\n      return function patchOpen(this: XMLHttpRequest, ...args): void {\n        const method: string = args[0];\n        const url: string = args[1];\n        plugin._createSpan(this, url, method);\n\n        return original.apply(this, args);\n      };\n    };\n  }\n\n  /**\n   * Patches the method send\n   * @private\n   */\n  protected _patchSend() {\n    const plugin = this;\n\n    function endSpanTimeout(\n      eventName: string,\n      xhrMem: XhrMem,\n      performanceEndTime: api.HrTime,\n      endTime: number\n    ) {\n      const callbackToRemoveEvents = xhrMem.callbackToRemoveEvents;\n\n      if (typeof callbackToRemoveEvents === 'function') {\n        callbackToRemoveEvents();\n      }\n\n      const { span, spanUrl, sendStartTime } = xhrMem;\n\n      if (span) {\n        plugin._findResourceAndAddNetworkEvents(\n          xhrMem,\n          span,\n          spanUrl,\n          sendStartTime,\n          performanceEndTime\n        );\n        span.addEvent(eventName, endTime);\n        plugin._addFinalSpanAttributes(span, xhrMem, spanUrl);\n        span.end(endTime);\n        plugin._tasksCount--;\n      }\n      plugin._clearResources();\n    }\n\n    function endSpan(\n      eventName: string,\n      xhr: XMLHttpRequest,\n      isError: boolean,\n      errorType?: string\n    ) {\n      const xhrMem = plugin._xhrMem.get(xhr);\n      if (!xhrMem) {\n        return;\n      }\n      xhrMem.status = xhr.status;\n      xhrMem.statusText = xhr.statusText;\n      plugin._xhrMem.delete(xhr);\n\n      if (xhrMem.span) {\n        const span = xhrMem.span;\n        plugin._applyAttributesAfterXHR(span, xhr);\n\n        if (plugin._semconvStability & SemconvStability.STABLE) {\n          if (isError) {\n            if (errorType) {\n              span.setStatus({\n                code: api.SpanStatusCode.ERROR,\n                message: errorType,\n              });\n              span.setAttribute(ATTR_ERROR_TYPE, errorType);\n            }\n          } else if (xhrMem.status && xhrMem.status >= 400) {\n            span.setStatus({ code: api.SpanStatusCode.ERROR });\n            span.setAttribute(ATTR_ERROR_TYPE, String(xhrMem.status));\n          }\n        }\n      }\n\n      const performanceEndTime = hrTime();\n      const endTime = Date.now();\n\n      // the timeout is needed as observer doesn't have yet information\n      // when event \"load\" is called. Also the time may differ depends on\n      // browser and speed of computer\n      setTimeout(() => {\n        endSpanTimeout(eventName, xhrMem, performanceEndTime, endTime);\n      }, OBSERVER_WAIT_TIME_MS);\n    }\n\n    function onError(this: XMLHttpRequest) {\n      endSpan(EventNames.EVENT_ERROR, this, true, 'error');\n    }\n\n    function onAbort(this: XMLHttpRequest) {\n      endSpan(EventNames.EVENT_ABORT, this, false);\n    }\n\n    function onTimeout(this: XMLHttpRequest) {\n      endSpan(EventNames.EVENT_TIMEOUT, this, true, 'timeout');\n    }\n\n    function onLoad(this: XMLHttpRequest) {\n      if (this.status < 299) {\n        endSpan(EventNames.EVENT_LOAD, this, false);\n      } else {\n        endSpan(EventNames.EVENT_ERROR, this, false);\n      }\n    }\n\n    function unregister(xhr: XMLHttpRequest) {\n      xhr.removeEventListener('abort', onAbort);\n      xhr.removeEventListener('error', onError);\n      xhr.removeEventListener('load', onLoad);\n      xhr.removeEventListener('timeout', onTimeout);\n      const xhrMem = plugin._xhrMem.get(xhr);\n      if (xhrMem) {\n        xhrMem.callbackToRemoveEvents = undefined;\n      }\n    }\n\n    return (original: SendFunction): SendFunction => {\n      return function patchSend(this: XMLHttpRequest, ...args): void {\n        const xhrMem = plugin._xhrMem.get(this);\n        if (!xhrMem) {\n          return original.apply(this, args);\n        }\n        const currentSpan = xhrMem.span;\n        const spanUrl = xhrMem.spanUrl;\n\n        if (currentSpan && spanUrl) {\n          if (plugin.getConfig().measureRequestSize && args?.[0]) {\n            const body = args[0];\n            const bodyLength = getXHRBodyLength(body);\n            if (bodyLength !== undefined) {\n              if (plugin._semconvStability & SemconvStability.OLD) {\n                currentSpan.setAttribute(\n                  ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,\n                  bodyLength\n                );\n              }\n              if (plugin._semconvStability & SemconvStability.STABLE) {\n                currentSpan.setAttribute(\n                  ATTR_HTTP_REQUEST_BODY_SIZE,\n                  bodyLength\n                );\n              }\n            }\n          }\n\n          api.context.with(\n            api.trace.setSpan(api.context.active(), currentSpan),\n            () => {\n              plugin._tasksCount++;\n              xhrMem.sendStartTime = hrTime();\n              currentSpan.addEvent(EventNames.METHOD_SEND);\n\n              this.addEventListener('abort', onAbort);\n              this.addEventListener('error', onError);\n              this.addEventListener('load', onLoad);\n              this.addEventListener('timeout', onTimeout);\n\n              xhrMem.callbackToRemoveEvents = () => {\n                unregister(this);\n                if (xhrMem.createdResources) {\n                  xhrMem.createdResources.observer.disconnect();\n                }\n              };\n              plugin._addHeaders(this, spanUrl);\n              plugin._addResourceObserver(this, spanUrl);\n            }\n          );\n        }\n        return original.apply(this, args);\n      };\n    };\n  }\n\n  /**\n   * implements enable function\n   */\n  override enable() {\n    this._diag.debug('applying patch to', this.moduleName, this.version);\n\n    if (isWrapped(XMLHttpRequest.prototype.open)) {\n      this._unwrap(XMLHttpRequest.prototype, 'open');\n      this._diag.debug('removing previous patch from method open');\n    }\n\n    if (isWrapped(XMLHttpRequest.prototype.send)) {\n      this._unwrap(XMLHttpRequest.prototype, 'send');\n      this._diag.debug('removing previous patch from method send');\n    }\n\n    this._wrap(XMLHttpRequest.prototype, 'open', this._patchOpen());\n    this._wrap(XMLHttpRequest.prototype, 'send', this._patchSend());\n  }\n\n  /**\n   * implements disable function\n   */\n  override disable() {\n    this._diag.debug('removing patch from', this.moduleName, this.version);\n\n    this._unwrap(XMLHttpRequest.prototype, 'open');\n    this._unwrap(XMLHttpRequest.prototype, 'send');\n\n    this._tasksCount = 0;\n    this._xhrMem = new WeakMap<XMLHttpRequest, XhrMem>();\n    this._usedResources = new WeakSet<PerformanceResourceTiming>();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
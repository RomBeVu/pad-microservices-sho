{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { context, diag, TraceFlags } from '@opentelemetry/api';\nimport { BindOnceFuture, ExportResultCode, getNumberFromEnv, globalErrorHandler, suppressTracing, unrefTimer } from '@opentelemetry/core';\n/**\n * Implementation of the {@link SpanProcessor} that batches spans exported by\n * the SDK then pushes them to the exporter pipeline.\n */\nexport class BatchSpanProcessorBase {\n  _exporter;\n  _maxExportBatchSize;\n  _maxQueueSize;\n  _scheduledDelayMillis;\n  _exportTimeoutMillis;\n  _isExporting = false;\n  _finishedSpans = [];\n  _timer;\n  _shutdownOnce;\n  _droppedSpansCount = 0;\n  constructor(_exporter, config) {\n    this._exporter = _exporter;\n    this._maxExportBatchSize = typeof config?.maxExportBatchSize === 'number' ? config.maxExportBatchSize : getNumberFromEnv('OTEL_BSP_MAX_EXPORT_BATCH_SIZE') ?? 512;\n    this._maxQueueSize = typeof config?.maxQueueSize === 'number' ? config.maxQueueSize : getNumberFromEnv('OTEL_BSP_MAX_QUEUE_SIZE') ?? 2048;\n    this._scheduledDelayMillis = typeof config?.scheduledDelayMillis === 'number' ? config.scheduledDelayMillis : getNumberFromEnv('OTEL_BSP_SCHEDULE_DELAY') ?? 5000;\n    this._exportTimeoutMillis = typeof config?.exportTimeoutMillis === 'number' ? config.exportTimeoutMillis : getNumberFromEnv('OTEL_BSP_EXPORT_TIMEOUT') ?? 30000;\n    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n    if (this._maxExportBatchSize > this._maxQueueSize) {\n      diag.warn('BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize');\n      this._maxExportBatchSize = this._maxQueueSize;\n    }\n  }\n  forceFlush() {\n    if (this._shutdownOnce.isCalled) {\n      return this._shutdownOnce.promise;\n    }\n    return this._flushAll();\n  }\n  // does nothing.\n  onStart(_span, _parentContext) {}\n  onEnd(span) {\n    if (this._shutdownOnce.isCalled) {\n      return;\n    }\n    if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {\n      return;\n    }\n    this._addToBuffer(span);\n  }\n  shutdown() {\n    return this._shutdownOnce.call();\n  }\n  _shutdown() {\n    return Promise.resolve().then(() => {\n      return this.onShutdown();\n    }).then(() => {\n      return this._flushAll();\n    }).then(() => {\n      return this._exporter.shutdown();\n    });\n  }\n  /** Add a span in the buffer. */\n  _addToBuffer(span) {\n    if (this._finishedSpans.length >= this._maxQueueSize) {\n      // limit reached, drop span\n      if (this._droppedSpansCount === 0) {\n        diag.debug('maxQueueSize reached, dropping spans');\n      }\n      this._droppedSpansCount++;\n      return;\n    }\n    if (this._droppedSpansCount > 0) {\n      // some spans were dropped, log once with count of spans dropped\n      diag.warn(`Dropped ${this._droppedSpansCount} spans because maxQueueSize reached`);\n      this._droppedSpansCount = 0;\n    }\n    this._finishedSpans.push(span);\n    this._maybeStartTimer();\n  }\n  /**\n   * Send all spans to the exporter respecting the batch size limit\n   * This function is used only on forceFlush or shutdown,\n   * for all other cases _flush should be used\n   * */\n  _flushAll() {\n    return new Promise((resolve, reject) => {\n      const promises = [];\n      // calculate number of batches\n      const count = Math.ceil(this._finishedSpans.length / this._maxExportBatchSize);\n      for (let i = 0, j = count; i < j; i++) {\n        promises.push(this._flushOneBatch());\n      }\n      Promise.all(promises).then(() => {\n        resolve();\n      }).catch(reject);\n    });\n  }\n  _flushOneBatch() {\n    this._clearTimer();\n    if (this._finishedSpans.length === 0) {\n      return Promise.resolve();\n    }\n    return new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        // don't wait anymore for export, this way the next batch can start\n        reject(new Error('Timeout'));\n      }, this._exportTimeoutMillis);\n      // prevent downstream exporter calls from generating spans\n      context.with(suppressTracing(context.active()), () => {\n        // Reset the finished spans buffer here because the next invocations of the _flush method\n        // could pass the same finished spans to the exporter if the buffer is cleared\n        // outside the execution of this callback.\n        let spans;\n        if (this._finishedSpans.length <= this._maxExportBatchSize) {\n          spans = this._finishedSpans;\n          this._finishedSpans = [];\n        } else {\n          spans = this._finishedSpans.splice(0, this._maxExportBatchSize);\n        }\n        const doExport = () => this._exporter.export(spans, result => {\n          clearTimeout(timer);\n          if (result.code === ExportResultCode.SUCCESS) {\n            resolve();\n          } else {\n            reject(result.error ?? new Error('BatchSpanProcessor: span export failed'));\n          }\n        });\n        let pendingResources = null;\n        for (let i = 0, len = spans.length; i < len; i++) {\n          const span = spans[i];\n          if (span.resource.asyncAttributesPending && span.resource.waitForAsyncAttributes) {\n            pendingResources ??= [];\n            pendingResources.push(span.resource.waitForAsyncAttributes());\n          }\n        }\n        // Avoid scheduling a promise to make the behavior more predictable and easier to test\n        if (pendingResources === null) {\n          doExport();\n        } else {\n          Promise.all(pendingResources).then(doExport, err => {\n            globalErrorHandler(err);\n            reject(err);\n          });\n        }\n      });\n    });\n  }\n  _maybeStartTimer() {\n    if (this._isExporting) return;\n    const flush = () => {\n      this._isExporting = true;\n      this._flushOneBatch().finally(() => {\n        this._isExporting = false;\n        if (this._finishedSpans.length > 0) {\n          this._clearTimer();\n          this._maybeStartTimer();\n        }\n      }).catch(e => {\n        this._isExporting = false;\n        globalErrorHandler(e);\n      });\n    };\n    // we only wait if the queue doesn't have enough elements yet\n    if (this._finishedSpans.length >= this._maxExportBatchSize) {\n      return flush();\n    }\n    if (this._timer !== undefined) return;\n    this._timer = setTimeout(() => flush(), this._scheduledDelayMillis);\n    unrefTimer(this._timer);\n  }\n  _clearTimer() {\n    if (this._timer !== undefined) {\n      clearTimeout(this._timer);\n      this._timer = undefined;\n    }\n  }\n}","map":{"version":3,"names":["context","diag","TraceFlags","BindOnceFuture","ExportResultCode","getNumberFromEnv","globalErrorHandler","suppressTracing","unrefTimer","BatchSpanProcessorBase","_exporter","_maxExportBatchSize","_maxQueueSize","_scheduledDelayMillis","_exportTimeoutMillis","_isExporting","_finishedSpans","_timer","_shutdownOnce","_droppedSpansCount","constructor","config","maxExportBatchSize","maxQueueSize","scheduledDelayMillis","exportTimeoutMillis","_shutdown","warn","forceFlush","isCalled","promise","_flushAll","onStart","_span","_parentContext","onEnd","span","spanContext","traceFlags","SAMPLED","_addToBuffer","shutdown","call","Promise","resolve","then","onShutdown","length","debug","push","_maybeStartTimer","reject","promises","count","Math","ceil","i","j","_flushOneBatch","all","catch","_clearTimer","timer","setTimeout","Error","with","active","spans","splice","doExport","export","result","clearTimeout","code","SUCCESS","error","pendingResources","len","resource","asyncAttributesPending","waitForAsyncAttributes","err","flush","finally","e","undefined"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/sdk-trace-base/src/export/BatchSpanProcessorBase.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { context, Context, diag, TraceFlags } from '@opentelemetry/api';\nimport {\n  BindOnceFuture,\n  ExportResultCode,\n  getNumberFromEnv,\n  globalErrorHandler,\n  suppressTracing,\n  unrefTimer,\n} from '@opentelemetry/core';\nimport { Span } from '../Span';\nimport { SpanProcessor } from '../SpanProcessor';\nimport { BufferConfig } from '../types';\nimport { ReadableSpan } from './ReadableSpan';\nimport { SpanExporter } from './SpanExporter';\n\n/**\n * Implementation of the {@link SpanProcessor} that batches spans exported by\n * the SDK then pushes them to the exporter pipeline.\n */\nexport abstract class BatchSpanProcessorBase<T extends BufferConfig>\n  implements SpanProcessor\n{\n  private readonly _maxExportBatchSize: number;\n  private readonly _maxQueueSize: number;\n  private readonly _scheduledDelayMillis: number;\n  private readonly _exportTimeoutMillis: number;\n\n  private _isExporting = false;\n  private _finishedSpans: ReadableSpan[] = [];\n  private _timer: NodeJS.Timeout | undefined;\n  private _shutdownOnce: BindOnceFuture<void>;\n  private _droppedSpansCount: number = 0;\n\n  constructor(\n    private readonly _exporter: SpanExporter,\n    config?: T\n  ) {\n    this._maxExportBatchSize =\n      typeof config?.maxExportBatchSize === 'number'\n        ? config.maxExportBatchSize\n        : (getNumberFromEnv('OTEL_BSP_MAX_EXPORT_BATCH_SIZE') ?? 512);\n    this._maxQueueSize =\n      typeof config?.maxQueueSize === 'number'\n        ? config.maxQueueSize\n        : (getNumberFromEnv('OTEL_BSP_MAX_QUEUE_SIZE') ?? 2048);\n    this._scheduledDelayMillis =\n      typeof config?.scheduledDelayMillis === 'number'\n        ? config.scheduledDelayMillis\n        : (getNumberFromEnv('OTEL_BSP_SCHEDULE_DELAY') ?? 5000);\n    this._exportTimeoutMillis =\n      typeof config?.exportTimeoutMillis === 'number'\n        ? config.exportTimeoutMillis\n        : (getNumberFromEnv('OTEL_BSP_EXPORT_TIMEOUT') ?? 30000);\n\n    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n\n    if (this._maxExportBatchSize > this._maxQueueSize) {\n      diag.warn(\n        'BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize'\n      );\n      this._maxExportBatchSize = this._maxQueueSize;\n    }\n  }\n\n  forceFlush(): Promise<void> {\n    if (this._shutdownOnce.isCalled) {\n      return this._shutdownOnce.promise;\n    }\n    return this._flushAll();\n  }\n\n  // does nothing.\n  onStart(_span: Span, _parentContext: Context): void {}\n\n  onEnd(span: ReadableSpan): void {\n    if (this._shutdownOnce.isCalled) {\n      return;\n    }\n\n    if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {\n      return;\n    }\n\n    this._addToBuffer(span);\n  }\n\n  shutdown(): Promise<void> {\n    return this._shutdownOnce.call();\n  }\n\n  private _shutdown() {\n    return Promise.resolve()\n      .then(() => {\n        return this.onShutdown();\n      })\n      .then(() => {\n        return this._flushAll();\n      })\n      .then(() => {\n        return this._exporter.shutdown();\n      });\n  }\n\n  /** Add a span in the buffer. */\n  private _addToBuffer(span: ReadableSpan) {\n    if (this._finishedSpans.length >= this._maxQueueSize) {\n      // limit reached, drop span\n\n      if (this._droppedSpansCount === 0) {\n        diag.debug('maxQueueSize reached, dropping spans');\n      }\n      this._droppedSpansCount++;\n\n      return;\n    }\n\n    if (this._droppedSpansCount > 0) {\n      // some spans were dropped, log once with count of spans dropped\n      diag.warn(\n        `Dropped ${this._droppedSpansCount} spans because maxQueueSize reached`\n      );\n      this._droppedSpansCount = 0;\n    }\n\n    this._finishedSpans.push(span);\n    this._maybeStartTimer();\n  }\n\n  /**\n   * Send all spans to the exporter respecting the batch size limit\n   * This function is used only on forceFlush or shutdown,\n   * for all other cases _flush should be used\n   * */\n  private _flushAll(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const promises = [];\n      // calculate number of batches\n      const count = Math.ceil(\n        this._finishedSpans.length / this._maxExportBatchSize\n      );\n      for (let i = 0, j = count; i < j; i++) {\n        promises.push(this._flushOneBatch());\n      }\n      Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(reject);\n    });\n  }\n\n  private _flushOneBatch(): Promise<void> {\n    this._clearTimer();\n    if (this._finishedSpans.length === 0) {\n      return Promise.resolve();\n    }\n    return new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        // don't wait anymore for export, this way the next batch can start\n        reject(new Error('Timeout'));\n      }, this._exportTimeoutMillis);\n      // prevent downstream exporter calls from generating spans\n      context.with(suppressTracing(context.active()), () => {\n        // Reset the finished spans buffer here because the next invocations of the _flush method\n        // could pass the same finished spans to the exporter if the buffer is cleared\n        // outside the execution of this callback.\n        let spans: ReadableSpan[];\n        if (this._finishedSpans.length <= this._maxExportBatchSize) {\n          spans = this._finishedSpans;\n          this._finishedSpans = [];\n        } else {\n          spans = this._finishedSpans.splice(0, this._maxExportBatchSize);\n        }\n\n        const doExport = () =>\n          this._exporter.export(spans, result => {\n            clearTimeout(timer);\n            if (result.code === ExportResultCode.SUCCESS) {\n              resolve();\n            } else {\n              reject(\n                result.error ??\n                  new Error('BatchSpanProcessor: span export failed')\n              );\n            }\n          });\n\n        let pendingResources: Array<Promise<void>> | null = null;\n        for (let i = 0, len = spans.length; i < len; i++) {\n          const span = spans[i];\n          if (\n            span.resource.asyncAttributesPending &&\n            span.resource.waitForAsyncAttributes\n          ) {\n            pendingResources ??= [];\n            pendingResources.push(span.resource.waitForAsyncAttributes());\n          }\n        }\n\n        // Avoid scheduling a promise to make the behavior more predictable and easier to test\n        if (pendingResources === null) {\n          doExport();\n        } else {\n          Promise.all(pendingResources).then(doExport, err => {\n            globalErrorHandler(err);\n            reject(err);\n          });\n        }\n      });\n    });\n  }\n\n  private _maybeStartTimer() {\n    if (this._isExporting) return;\n    const flush = () => {\n      this._isExporting = true;\n      this._flushOneBatch()\n        .finally(() => {\n          this._isExporting = false;\n          if (this._finishedSpans.length > 0) {\n            this._clearTimer();\n            this._maybeStartTimer();\n          }\n        })\n        .catch(e => {\n          this._isExporting = false;\n          globalErrorHandler(e);\n        });\n    };\n    // we only wait if the queue doesn't have enough elements yet\n    if (this._finishedSpans.length >= this._maxExportBatchSize) {\n      return flush();\n    }\n    if (this._timer !== undefined) return;\n    this._timer = setTimeout(() => flush(), this._scheduledDelayMillis);\n    unrefTimer(this._timer);\n  }\n\n  private _clearTimer() {\n    if (this._timer !== undefined) {\n      clearTimeout(this._timer);\n      this._timer = undefined;\n    }\n  }\n\n  protected abstract onShutdown(): void;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
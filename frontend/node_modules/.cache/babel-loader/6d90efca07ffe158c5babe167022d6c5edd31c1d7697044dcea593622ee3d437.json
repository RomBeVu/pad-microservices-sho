{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { diag } from '@opentelemetry/api';\nimport { SDK_INFO } from '@opentelemetry/core';\nimport { ATTR_SERVICE_NAME, ATTR_TELEMETRY_SDK_LANGUAGE, ATTR_TELEMETRY_SDK_NAME, ATTR_TELEMETRY_SDK_VERSION } from '@opentelemetry/semantic-conventions';\nimport { defaultServiceName } from './platform';\nimport { isPromiseLike } from './utils';\nclass ResourceImpl {\n  _rawAttributes;\n  _asyncAttributesPending = false;\n  _memoizedAttributes;\n  static FromAttributeList(attributes) {\n    const res = new ResourceImpl({});\n    res._rawAttributes = guardedRawAttributes(attributes);\n    res._asyncAttributesPending = attributes.filter(([_, val]) => isPromiseLike(val)).length > 0;\n    return res;\n  }\n  constructor(\n  /**\n   * A dictionary of attributes with string keys and values that provide\n   * information about the entity as numbers, strings or booleans\n   * TODO: Consider to add check/validation on attributes.\n   */\n  resource) {\n    const attributes = resource.attributes ?? {};\n    this._rawAttributes = Object.entries(attributes).map(([k, v]) => {\n      if (isPromiseLike(v)) {\n        // side-effect\n        this._asyncAttributesPending = true;\n      }\n      return [k, v];\n    });\n    this._rawAttributes = guardedRawAttributes(this._rawAttributes);\n  }\n  get asyncAttributesPending() {\n    return this._asyncAttributesPending;\n  }\n  async waitForAsyncAttributes() {\n    if (!this.asyncAttributesPending) {\n      return;\n    }\n    for (let i = 0; i < this._rawAttributes.length; i++) {\n      const [k, v] = this._rawAttributes[i];\n      this._rawAttributes[i] = [k, isPromiseLike(v) ? await v : v];\n    }\n    this._asyncAttributesPending = false;\n  }\n  get attributes() {\n    if (this.asyncAttributesPending) {\n      diag.error('Accessing resource attributes before async attributes settled');\n    }\n    if (this._memoizedAttributes) {\n      return this._memoizedAttributes;\n    }\n    const attrs = {};\n    for (const [k, v] of this._rawAttributes) {\n      if (isPromiseLike(v)) {\n        diag.debug(`Unsettled resource attribute ${k} skipped`);\n        continue;\n      }\n      if (v != null) {\n        attrs[k] ??= v;\n      }\n    }\n    // only memoize output if all attributes are settled\n    if (!this._asyncAttributesPending) {\n      this._memoizedAttributes = attrs;\n    }\n    return attrs;\n  }\n  getRawAttributes() {\n    return this._rawAttributes;\n  }\n  merge(resource) {\n    if (resource == null) return this;\n    // Order is important\n    // Spec states incoming attributes override existing attributes\n    return ResourceImpl.FromAttributeList([...resource.getRawAttributes(), ...this.getRawAttributes()]);\n  }\n}\nexport function resourceFromAttributes(attributes) {\n  return ResourceImpl.FromAttributeList(Object.entries(attributes));\n}\nexport function resourceFromDetectedResource(detectedResource) {\n  return new ResourceImpl(detectedResource);\n}\nexport function emptyResource() {\n  return resourceFromAttributes({});\n}\nexport function defaultResource() {\n  return resourceFromAttributes({\n    [ATTR_SERVICE_NAME]: defaultServiceName(),\n    [ATTR_TELEMETRY_SDK_LANGUAGE]: SDK_INFO[ATTR_TELEMETRY_SDK_LANGUAGE],\n    [ATTR_TELEMETRY_SDK_NAME]: SDK_INFO[ATTR_TELEMETRY_SDK_NAME],\n    [ATTR_TELEMETRY_SDK_VERSION]: SDK_INFO[ATTR_TELEMETRY_SDK_VERSION]\n  });\n}\nfunction guardedRawAttributes(attributes) {\n  return attributes.map(([k, v]) => {\n    if (isPromiseLike(v)) {\n      return [k, v.catch(err => {\n        diag.debug('promise rejection for resource attribute: %s - %s', k, err);\n        return undefined;\n      })];\n    }\n    return [k, v];\n  });\n}","map":{"version":3,"names":["diag","SDK_INFO","ATTR_SERVICE_NAME","ATTR_TELEMETRY_SDK_LANGUAGE","ATTR_TELEMETRY_SDK_NAME","ATTR_TELEMETRY_SDK_VERSION","defaultServiceName","isPromiseLike","ResourceImpl","_rawAttributes","_asyncAttributesPending","_memoizedAttributes","FromAttributeList","attributes","res","guardedRawAttributes","filter","_","val","length","constructor","resource","Object","entries","map","k","v","asyncAttributesPending","waitForAsyncAttributes","i","error","attrs","debug","getRawAttributes","merge","resourceFromAttributes","resourceFromDetectedResource","detectedResource","emptyResource","defaultResource","catch","err","undefined"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/resources/src/ResourceImpl.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Attributes, AttributeValue, diag } from '@opentelemetry/api';\nimport { SDK_INFO } from '@opentelemetry/core';\nimport {\n  ATTR_SERVICE_NAME,\n  ATTR_TELEMETRY_SDK_LANGUAGE,\n  ATTR_TELEMETRY_SDK_NAME,\n  ATTR_TELEMETRY_SDK_VERSION,\n} from '@opentelemetry/semantic-conventions';\nimport { Resource } from './Resource';\nimport { defaultServiceName } from './platform';\nimport {\n  DetectedResource,\n  DetectedResourceAttributes,\n  MaybePromise,\n  RawResourceAttribute,\n} from './types';\nimport { isPromiseLike } from './utils';\n\nclass ResourceImpl implements Resource {\n  private _rawAttributes: RawResourceAttribute[];\n  private _asyncAttributesPending = false;\n\n  private _memoizedAttributes?: Attributes;\n\n  static FromAttributeList(\n    attributes: [string, MaybePromise<AttributeValue | undefined>][]\n  ): Resource {\n    const res = new ResourceImpl({});\n    res._rawAttributes = guardedRawAttributes(attributes);\n    res._asyncAttributesPending =\n      attributes.filter(([_, val]) => isPromiseLike(val)).length > 0;\n    return res;\n  }\n\n  constructor(\n    /**\n     * A dictionary of attributes with string keys and values that provide\n     * information about the entity as numbers, strings or booleans\n     * TODO: Consider to add check/validation on attributes.\n     */\n    resource: DetectedResource\n  ) {\n    const attributes = resource.attributes ?? {};\n    this._rawAttributes = Object.entries(attributes).map(([k, v]) => {\n      if (isPromiseLike(v)) {\n        // side-effect\n        this._asyncAttributesPending = true;\n      }\n\n      return [k, v];\n    });\n\n    this._rawAttributes = guardedRawAttributes(this._rawAttributes);\n  }\n\n  public get asyncAttributesPending(): boolean {\n    return this._asyncAttributesPending;\n  }\n\n  public async waitForAsyncAttributes(): Promise<void> {\n    if (!this.asyncAttributesPending) {\n      return;\n    }\n\n    for (let i = 0; i < this._rawAttributes.length; i++) {\n      const [k, v] = this._rawAttributes[i];\n      this._rawAttributes[i] = [k, isPromiseLike(v) ? await v : v];\n    }\n\n    this._asyncAttributesPending = false;\n  }\n\n  public get attributes(): Attributes {\n    if (this.asyncAttributesPending) {\n      diag.error(\n        'Accessing resource attributes before async attributes settled'\n      );\n    }\n\n    if (this._memoizedAttributes) {\n      return this._memoizedAttributes;\n    }\n\n    const attrs: Attributes = {};\n    for (const [k, v] of this._rawAttributes) {\n      if (isPromiseLike(v)) {\n        diag.debug(`Unsettled resource attribute ${k} skipped`);\n        continue;\n      }\n      if (v != null) {\n        attrs[k] ??= v;\n      }\n    }\n\n    // only memoize output if all attributes are settled\n    if (!this._asyncAttributesPending) {\n      this._memoizedAttributes = attrs;\n    }\n\n    return attrs;\n  }\n\n  public getRawAttributes(): RawResourceAttribute[] {\n    return this._rawAttributes;\n  }\n\n  public merge(resource: Resource | null): Resource {\n    if (resource == null) return this;\n\n    // Order is important\n    // Spec states incoming attributes override existing attributes\n    return ResourceImpl.FromAttributeList([\n      ...resource.getRawAttributes(),\n      ...this.getRawAttributes(),\n    ]);\n  }\n}\n\nexport function resourceFromAttributes(\n  attributes: DetectedResourceAttributes\n): Resource {\n  return ResourceImpl.FromAttributeList(Object.entries(attributes));\n}\n\nexport function resourceFromDetectedResource(\n  detectedResource: DetectedResource\n): Resource {\n  return new ResourceImpl(detectedResource);\n}\n\nexport function emptyResource(): Resource {\n  return resourceFromAttributes({});\n}\n\nexport function defaultResource(): Resource {\n  return resourceFromAttributes({\n    [ATTR_SERVICE_NAME]: defaultServiceName(),\n    [ATTR_TELEMETRY_SDK_LANGUAGE]: SDK_INFO[ATTR_TELEMETRY_SDK_LANGUAGE],\n    [ATTR_TELEMETRY_SDK_NAME]: SDK_INFO[ATTR_TELEMETRY_SDK_NAME],\n    [ATTR_TELEMETRY_SDK_VERSION]: SDK_INFO[ATTR_TELEMETRY_SDK_VERSION],\n  });\n}\n\nfunction guardedRawAttributes(\n  attributes: RawResourceAttribute[]\n): RawResourceAttribute[] {\n  return attributes.map(([k, v]) => {\n    if (isPromiseLike(v)) {\n      return [\n        k,\n        v.catch(err => {\n          diag.debug(\n            'promise rejection for resource attribute: %s - %s',\n            k,\n            err\n          );\n          return undefined;\n        }),\n      ];\n    }\n    return [k, v];\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as ieee754 from './ieee754';\nimport * as util from '../util';\nimport { MappingError } from './types';\n/**\n * LogarithmMapping implements exponential mapping functions for scale > 0.\n * For scales <= 0 the exponent mapping should be used.\n */\nexport class LogarithmMapping {\n  _scale;\n  _scaleFactor;\n  _inverseFactor;\n  constructor(scale) {\n    this._scale = scale;\n    this._scaleFactor = util.ldexp(Math.LOG2E, scale);\n    this._inverseFactor = util.ldexp(Math.LN2, -scale);\n  }\n  /**\n   * Maps positive floating point values to indexes corresponding to scale\n   * @param value\n   * @returns {number} index for provided value at the current scale\n   */\n  mapToIndex(value) {\n    if (value <= ieee754.MIN_VALUE) {\n      return this._minNormalLowerBoundaryIndex() - 1;\n    }\n    // exact power of two special case\n    if (ieee754.getSignificand(value) === 0) {\n      const exp = ieee754.getNormalBase2(value);\n      return (exp << this._scale) - 1;\n    }\n    // non-power of two cases. use Math.floor to round the scaled logarithm\n    const index = Math.floor(Math.log(value) * this._scaleFactor);\n    const maxIndex = this._maxNormalLowerBoundaryIndex();\n    if (index >= maxIndex) {\n      return maxIndex;\n    }\n    return index;\n  }\n  /**\n   * Returns the lower bucket boundary for the given index for scale\n   *\n   * @param index\n   * @returns {number}\n   */\n  lowerBoundary(index) {\n    const maxIndex = this._maxNormalLowerBoundaryIndex();\n    if (index >= maxIndex) {\n      if (index === maxIndex) {\n        return 2 * Math.exp((index - (1 << this._scale)) / this._scaleFactor);\n      }\n      throw new MappingError(`overflow: ${index} is > maximum lower boundary: ${maxIndex}`);\n    }\n    const minIndex = this._minNormalLowerBoundaryIndex();\n    if (index <= minIndex) {\n      if (index === minIndex) {\n        return ieee754.MIN_VALUE;\n      } else if (index === minIndex - 1) {\n        return Math.exp((index + (1 << this._scale)) / this._scaleFactor) / 2;\n      }\n      throw new MappingError(`overflow: ${index} is < minimum lower boundary: ${minIndex}`);\n    }\n    return Math.exp(index * this._inverseFactor);\n  }\n  /**\n   * The scale used by this mapping\n   * @returns {number}\n   */\n  get scale() {\n    return this._scale;\n  }\n  _minNormalLowerBoundaryIndex() {\n    return ieee754.MIN_NORMAL_EXPONENT << this._scale;\n  }\n  _maxNormalLowerBoundaryIndex() {\n    return (ieee754.MAX_NORMAL_EXPONENT + 1 << this._scale) - 1;\n  }\n}","map":{"version":3,"names":["ieee754","util","MappingError","LogarithmMapping","_scale","_scaleFactor","_inverseFactor","constructor","scale","ldexp","Math","LOG2E","LN2","mapToIndex","value","MIN_VALUE","_minNormalLowerBoundaryIndex","getSignificand","exp","getNormalBase2","index","floor","log","maxIndex","_maxNormalLowerBoundaryIndex","lowerBoundary","minIndex","MIN_NORMAL_EXPONENT","MAX_NORMAL_EXPONENT"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/sdk-metrics/src/aggregator/exponential-histogram/mapping/LogarithmMapping.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as ieee754 from './ieee754';\nimport * as util from '../util';\nimport { Mapping, MappingError } from './types';\n\n/**\n * LogarithmMapping implements exponential mapping functions for scale > 0.\n * For scales <= 0 the exponent mapping should be used.\n */\nexport class LogarithmMapping implements Mapping {\n  private readonly _scale: number;\n  private readonly _scaleFactor: number;\n  private readonly _inverseFactor: number;\n\n  constructor(scale: number) {\n    this._scale = scale;\n    this._scaleFactor = util.ldexp(Math.LOG2E, scale);\n    this._inverseFactor = util.ldexp(Math.LN2, -scale);\n  }\n\n  /**\n   * Maps positive floating point values to indexes corresponding to scale\n   * @param value\n   * @returns {number} index for provided value at the current scale\n   */\n  mapToIndex(value: number): number {\n    if (value <= ieee754.MIN_VALUE) {\n      return this._minNormalLowerBoundaryIndex() - 1;\n    }\n\n    // exact power of two special case\n    if (ieee754.getSignificand(value) === 0) {\n      const exp = ieee754.getNormalBase2(value);\n      return (exp << this._scale) - 1;\n    }\n\n    // non-power of two cases. use Math.floor to round the scaled logarithm\n    const index = Math.floor(Math.log(value) * this._scaleFactor);\n    const maxIndex = this._maxNormalLowerBoundaryIndex();\n    if (index >= maxIndex) {\n      return maxIndex;\n    }\n\n    return index;\n  }\n\n  /**\n   * Returns the lower bucket boundary for the given index for scale\n   *\n   * @param index\n   * @returns {number}\n   */\n  lowerBoundary(index: number): number {\n    const maxIndex = this._maxNormalLowerBoundaryIndex();\n    if (index >= maxIndex) {\n      if (index === maxIndex) {\n        return 2 * Math.exp((index - (1 << this._scale)) / this._scaleFactor);\n      }\n      throw new MappingError(\n        `overflow: ${index} is > maximum lower boundary: ${maxIndex}`\n      );\n    }\n\n    const minIndex = this._minNormalLowerBoundaryIndex();\n    if (index <= minIndex) {\n      if (index === minIndex) {\n        return ieee754.MIN_VALUE;\n      } else if (index === minIndex - 1) {\n        return Math.exp((index + (1 << this._scale)) / this._scaleFactor) / 2;\n      }\n      throw new MappingError(\n        `overflow: ${index} is < minimum lower boundary: ${minIndex}`\n      );\n    }\n\n    return Math.exp(index * this._inverseFactor);\n  }\n\n  /**\n   * The scale used by this mapping\n   * @returns {number}\n   */\n  get scale(): number {\n    return this._scale;\n  }\n\n  private _minNormalLowerBoundaryIndex(): number {\n    return ieee754.MIN_NORMAL_EXPONENT << this._scale;\n  }\n\n  private _maxNormalLowerBoundaryIndex(): number {\n    return ((ieee754.MAX_NORMAL_EXPONENT + 1) << this._scale) - 1;\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAeA,OAAO,KAAKA,OAAO,MAAM,WAAW;AACpC,OAAO,KAAKC,IAAI,MAAM,SAAS;AAC/B,SAAkBC,YAAY,QAAQ,SAAS;AAE/C;;;;AAIA,OAAM,MAAOC,gBAAgB;EACVC,MAAM;EACNC,YAAY;EACZC,cAAc;EAE/BC,YAAYC,KAAa;IACvB,IAAI,CAACJ,MAAM,GAAGI,KAAK;IACnB,IAAI,CAACH,YAAY,GAAGJ,IAAI,CAACQ,KAAK,CAACC,IAAI,CAACC,KAAK,EAAEH,KAAK,CAAC;IACjD,IAAI,CAACF,cAAc,GAAGL,IAAI,CAACQ,KAAK,CAACC,IAAI,CAACE,GAAG,EAAE,CAACJ,KAAK,CAAC;EACpD;EAEA;;;;;EAKAK,UAAUA,CAACC,KAAa;IACtB,IAAIA,KAAK,IAAId,OAAO,CAACe,SAAS,EAAE;MAC9B,OAAO,IAAI,CAACC,4BAA4B,EAAE,GAAG,CAAC;;IAGhD;IACA,IAAIhB,OAAO,CAACiB,cAAc,CAACH,KAAK,CAAC,KAAK,CAAC,EAAE;MACvC,MAAMI,GAAG,GAAGlB,OAAO,CAACmB,cAAc,CAACL,KAAK,CAAC;MACzC,OAAO,CAACI,GAAG,IAAI,IAAI,CAACd,MAAM,IAAI,CAAC;;IAGjC;IACA,MAAMgB,KAAK,GAAGV,IAAI,CAACW,KAAK,CAACX,IAAI,CAACY,GAAG,CAACR,KAAK,CAAC,GAAG,IAAI,CAACT,YAAY,CAAC;IAC7D,MAAMkB,QAAQ,GAAG,IAAI,CAACC,4BAA4B,EAAE;IACpD,IAAIJ,KAAK,IAAIG,QAAQ,EAAE;MACrB,OAAOA,QAAQ;;IAGjB,OAAOH,KAAK;EACd;EAEA;;;;;;EAMAK,aAAaA,CAACL,KAAa;IACzB,MAAMG,QAAQ,GAAG,IAAI,CAACC,4BAA4B,EAAE;IACpD,IAAIJ,KAAK,IAAIG,QAAQ,EAAE;MACrB,IAAIH,KAAK,KAAKG,QAAQ,EAAE;QACtB,OAAO,CAAC,GAAGb,IAAI,CAACQ,GAAG,CAAC,CAACE,KAAK,IAAI,CAAC,IAAI,IAAI,CAAChB,MAAM,CAAC,IAAI,IAAI,CAACC,YAAY,CAAC;;MAEvE,MAAM,IAAIH,YAAY,CACpB,aAAakB,KAAK,iCAAiCG,QAAQ,EAAE,CAC9D;;IAGH,MAAMG,QAAQ,GAAG,IAAI,CAACV,4BAA4B,EAAE;IACpD,IAAII,KAAK,IAAIM,QAAQ,EAAE;MACrB,IAAIN,KAAK,KAAKM,QAAQ,EAAE;QACtB,OAAO1B,OAAO,CAACe,SAAS;OACzB,MAAM,IAAIK,KAAK,KAAKM,QAAQ,GAAG,CAAC,EAAE;QACjC,OAAOhB,IAAI,CAACQ,GAAG,CAAC,CAACE,KAAK,IAAI,CAAC,IAAI,IAAI,CAAChB,MAAM,CAAC,IAAI,IAAI,CAACC,YAAY,CAAC,GAAG,CAAC;;MAEvE,MAAM,IAAIH,YAAY,CACpB,aAAakB,KAAK,iCAAiCM,QAAQ,EAAE,CAC9D;;IAGH,OAAOhB,IAAI,CAACQ,GAAG,CAACE,KAAK,GAAG,IAAI,CAACd,cAAc,CAAC;EAC9C;EAEA;;;;EAIA,IAAIE,KAAKA,CAAA;IACP,OAAO,IAAI,CAACJ,MAAM;EACpB;EAEQY,4BAA4BA,CAAA;IAClC,OAAOhB,OAAO,CAAC2B,mBAAmB,IAAI,IAAI,CAACvB,MAAM;EACnD;EAEQoB,4BAA4BA,CAAA;IAClC,OAAO,CAAExB,OAAO,CAAC4B,mBAAmB,GAAG,CAAC,IAAK,IAAI,CAACxB,MAAM,IAAI,CAAC;EAC/D","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
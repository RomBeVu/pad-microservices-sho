{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { PatternPredicate } from './Predicate';\nimport { createMultiAttributesProcessor, createNoopAttributesProcessor } from './AttributesProcessor';\nimport { InstrumentSelector } from './InstrumentSelector';\nimport { MeterSelector } from './MeterSelector';\nimport { AggregationType, toAggregation } from './AggregationOption';\nfunction isSelectorNotProvided(options) {\n  return options.instrumentName == null && options.instrumentType == null && options.instrumentUnit == null && options.meterName == null && options.meterVersion == null && options.meterSchemaUrl == null;\n}\nfunction validateViewOptions(viewOptions) {\n  // If no criteria is provided, the SDK SHOULD treat it as an error.\n  // It is recommended that the SDK implementations fail fast.\n  if (isSelectorNotProvided(viewOptions)) {\n    throw new Error('Cannot create view with no selector arguments supplied');\n  }\n  // the SDK SHOULD NOT allow Views with a specified name to be declared with instrument selectors that\n  // may select more than one instrument (e.g. wild card instrument name) in the same Meter.\n  if (viewOptions.name != null && (viewOptions?.instrumentName == null || PatternPredicate.hasWildcard(viewOptions.instrumentName))) {\n    throw new Error('Views with a specified name must be declared with an instrument selector that selects at most one instrument per meter.');\n  }\n}\n/**\n * Can be passed to a {@link MeterProvider} to select instruments and alter their metric stream.\n */\nexport class View {\n  name;\n  description;\n  aggregation;\n  attributesProcessor;\n  instrumentSelector;\n  meterSelector;\n  aggregationCardinalityLimit;\n  /**\n   * Create a new {@link View} instance.\n   *\n   * Parameters can be categorized as two types:\n   *  Instrument selection criteria: Used to describe the instrument(s) this view will be applied to.\n   *  Will be treated as additive (the Instrument has to meet all the provided criteria to be selected).\n   *\n   *  Metric stream altering: Alter the metric stream of instruments selected by instrument selection criteria.\n   *\n   * @param viewOptions {@link ViewOptions} for altering the metric stream and instrument selection.\n   * @param viewOptions.name\n   * Alters the metric stream:\n   *  This will be used as the name of the metrics stream.\n   *  If not provided, the original Instrument name will be used.\n   * @param viewOptions.description\n   * Alters the metric stream:\n   *  This will be used as the description of the metrics stream.\n   *  If not provided, the original Instrument description will be used by default.\n   * @param viewOptions.attributesProcessors\n   * Alters the metric stream:\n   *  If provided, the attributes will be modified as defined by the added processors.\n   *  If not provided, all attribute keys will be used by default.\n   * @param viewOptions.aggregationCardinalityLimit\n   * Alters the metric stream:\n   *  Sets a limit on the number of unique attribute combinations (cardinality) that can be aggregated.\n   *  If not provided, the default limit of 2000 will be used.\n   * @param viewOptions.aggregation\n   * Alters the metric stream:\n   *  Alters the {@link Aggregation} of the metric stream.\n   * @param viewOptions.instrumentName\n   * Instrument selection criteria:\n   *  Original name of the Instrument(s) with wildcard support.\n   * @param viewOptions.instrumentType\n   * Instrument selection criteria:\n   *  The original type of the Instrument(s).\n   * @param viewOptions.instrumentUnit\n   * Instrument selection criteria:\n   *  The unit of the Instrument(s).\n   * @param viewOptions.meterName\n   * Instrument selection criteria:\n   *  The name of the Meter. No wildcard support, name must match the meter exactly.\n   * @param viewOptions.meterVersion\n   * Instrument selection criteria:\n   *  The version of the Meter. No wildcard support, version must match exactly.\n   * @param viewOptions.meterSchemaUrl\n   * Instrument selection criteria:\n   *  The schema URL of the Meter. No wildcard support, schema URL must match exactly.\n   *\n   * @example\n   * // Create a view that changes the Instrument 'my.instrument' to use to an\n   * // ExplicitBucketHistogramAggregation with the boundaries [20, 30, 40]\n   * new View({\n   *   aggregation: new ExplicitBucketHistogramAggregation([20, 30, 40]),\n   *   instrumentName: 'my.instrument'\n   * })\n   */\n  constructor(viewOptions) {\n    validateViewOptions(viewOptions);\n    // Create multi-processor if attributesProcessors are defined.\n    if (viewOptions.attributesProcessors != null) {\n      this.attributesProcessor = createMultiAttributesProcessor(viewOptions.attributesProcessors);\n    } else {\n      this.attributesProcessor = createNoopAttributesProcessor();\n    }\n    this.name = viewOptions.name;\n    this.description = viewOptions.description;\n    this.aggregation = toAggregation(viewOptions.aggregation ?? {\n      type: AggregationType.DEFAULT\n    });\n    this.instrumentSelector = new InstrumentSelector({\n      name: viewOptions.instrumentName,\n      type: viewOptions.instrumentType,\n      unit: viewOptions.instrumentUnit\n    });\n    this.meterSelector = new MeterSelector({\n      name: viewOptions.meterName,\n      version: viewOptions.meterVersion,\n      schemaUrl: viewOptions.meterSchemaUrl\n    });\n    this.aggregationCardinalityLimit = viewOptions.aggregationCardinalityLimit;\n  }\n}","map":{"version":3,"names":["PatternPredicate","createMultiAttributesProcessor","createNoopAttributesProcessor","InstrumentSelector","MeterSelector","AggregationType","toAggregation","isSelectorNotProvided","options","instrumentName","instrumentType","instrumentUnit","meterName","meterVersion","meterSchemaUrl","validateViewOptions","viewOptions","Error","name","hasWildcard","View","description","aggregation","attributesProcessor","instrumentSelector","meterSelector","aggregationCardinalityLimit","constructor","attributesProcessors","type","DEFAULT","unit","version","schemaUrl"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/sdk-metrics/src/view/View.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { PatternPredicate } from './Predicate';\nimport {\n  createMultiAttributesProcessor,\n  createNoopAttributesProcessor,\n  IAttributesProcessor,\n} from './AttributesProcessor';\nimport { InstrumentSelector } from './InstrumentSelector';\nimport { MeterSelector } from './MeterSelector';\nimport { Aggregation } from './Aggregation';\nimport {\n  AggregationOption,\n  AggregationType,\n  toAggregation,\n} from './AggregationOption';\nimport { InstrumentType } from '../export/MetricData';\n\nexport type ViewOptions = {\n  /**\n   *  Alters the metric stream:\n   *  This will be used as the name of the metrics stream.\n   *  If not provided, the original Instrument name will be used.\n   */\n  name?: string;\n  /**\n   * Alters the metric stream:\n   * This will be used as the description of the metrics stream.\n   * If not provided, the original Instrument description will be used by default.\n   *\n   * @example <caption>changes the description of all selected instruments to 'sample description'</caption>\n   * description: 'sample description'\n   */\n  description?: string;\n  /**\n   * Alters the metric stream:\n   * If provided, the attributes will be modified as defined by the processors in the list. Processors are applied\n   * in the order they're provided.\n   * If not provided, all attribute keys will be used by default.\n   *\n   * @example <caption>drops all attributes with top-level keys except for 'myAttr' and 'myOtherAttr'</caption>\n   * attributesProcessors: [createAllowListProcessor(['myAttr', 'myOtherAttr'])]\n   * @example <caption>drops all attributes</caption>\n   * attributesProcessors: [createAllowListProcessor([])]\n   * @example <caption>allows all attributes except for 'myAttr'</caption>\n   * attributesProcessors: [createDenyListProcessor(['myAttr']]\n   */\n  attributesProcessors?: IAttributesProcessor[];\n  /**\n   * Alters the metric stream:\n   * Alters the Aggregation of the metric stream.\n   *\n   * @example <caption>changes the aggregation of the selected instrument(s) to ExplicitBucketHistogramAggregation</caption>\n   * aggregation: { type: AggregationType.EXPLICIT_BUCKET_HISTOGRAM, options: { boundaries: [1, 10, 100] } }\n   * @example <caption>changes the aggregation of the selected instrument(s) to LastValueAggregation</caption>\n   * aggregation: { type: AggregationType.LAST_VALUE, options: { boundaries: [1, 10, 100] } }\n   */\n  aggregation?: AggregationOption;\n  /**\n   * Alters the metric stream:\n   * Sets a limit on the number of unique attribute combinations (cardinality) that can be aggregated.\n   * If not provided, the default limit will be used.\n   *\n   * @example <caption>sets the cardinality limit to 1000</caption>\n   * aggregationCardinalityLimit: 1000\n   */\n  aggregationCardinalityLimit?: number;\n  /**\n   * Instrument selection criteria:\n   * The original type of the Instrument(s).\n   *\n   * @example <caption>selects all counters</caption>\n   * instrumentType: InstrumentType.COUNTER\n   * @example <caption>selects all histograms</caption>\n   * instrumentType: InstrumentType.HISTOGRAM\n   */\n  instrumentType?: InstrumentType;\n  /**\n   * Instrument selection criteria:\n   * Original name of the Instrument(s) with wildcard support.\n   *\n   * @example <caption>select all instruments</caption>\n   * instrumentName: '*'\n   * @example <caption>select all instruments starting with 'my.instruments.'</caption>\n   * instrumentName: 'my.instruments.*'\n   * @example <caption>select all instruments named 'my.instrument.requests' exactly</caption>\n   * instrumentName: 'my.instruments.requests'\n   */\n  instrumentName?: string;\n  /**\n   * Instrument selection criteria:\n   * The unit of the Instrument(s).\n   *\n   * @example <caption>select all instruments with unit 'ms'</caption>\n   * instrumentUnit: 'ms'\n   */\n  instrumentUnit?: string;\n  /**\n   * Instrument selection criteria:\n   * The name of the Meter. No wildcard support, name must match the meter exactly.\n   *\n   * @example <caption>select all meters named 'example.component.app' exactly</caption>\n   * meterName: 'example.component.app'\n   */\n  meterName?: string;\n  /**\n   * Instrument selection criteria:\n   * The version of the Meter. No wildcard support, version must match exactly.\n   *\n   * @example\n   * meterVersion: '1.0.1'\n   */\n  meterVersion?: string;\n  /**\n   * Instrument selection criteria:\n   * The schema URL of the Meter. No wildcard support, schema URL must match exactly.\n   *\n   * @example <caption>Select all meters with schema URL 'https://example.com/schema' exactly.</caption>\n   * meterSchemaUrl: 'https://example.com/schema'\n   */\n  meterSchemaUrl?: string;\n};\n\nfunction isSelectorNotProvided(options: ViewOptions): boolean {\n  return (\n    options.instrumentName == null &&\n    options.instrumentType == null &&\n    options.instrumentUnit == null &&\n    options.meterName == null &&\n    options.meterVersion == null &&\n    options.meterSchemaUrl == null\n  );\n}\n\nfunction validateViewOptions(viewOptions: ViewOptions) {\n  // If no criteria is provided, the SDK SHOULD treat it as an error.\n  // It is recommended that the SDK implementations fail fast.\n  if (isSelectorNotProvided(viewOptions)) {\n    throw new Error('Cannot create view with no selector arguments supplied');\n  }\n\n  // the SDK SHOULD NOT allow Views with a specified name to be declared with instrument selectors that\n  // may select more than one instrument (e.g. wild card instrument name) in the same Meter.\n  if (\n    viewOptions.name != null &&\n    (viewOptions?.instrumentName == null ||\n      PatternPredicate.hasWildcard(viewOptions.instrumentName))\n  ) {\n    throw new Error(\n      'Views with a specified name must be declared with an instrument selector that selects at most one instrument per meter.'\n    );\n  }\n}\n\n/**\n * Can be passed to a {@link MeterProvider} to select instruments and alter their metric stream.\n */\nexport class View {\n  readonly name?: string;\n  readonly description?: string;\n  readonly aggregation: Aggregation;\n  readonly attributesProcessor: IAttributesProcessor;\n  readonly instrumentSelector: InstrumentSelector;\n  readonly meterSelector: MeterSelector;\n  readonly aggregationCardinalityLimit?: number;\n\n  /**\n   * Create a new {@link View} instance.\n   *\n   * Parameters can be categorized as two types:\n   *  Instrument selection criteria: Used to describe the instrument(s) this view will be applied to.\n   *  Will be treated as additive (the Instrument has to meet all the provided criteria to be selected).\n   *\n   *  Metric stream altering: Alter the metric stream of instruments selected by instrument selection criteria.\n   *\n   * @param viewOptions {@link ViewOptions} for altering the metric stream and instrument selection.\n   * @param viewOptions.name\n   * Alters the metric stream:\n   *  This will be used as the name of the metrics stream.\n   *  If not provided, the original Instrument name will be used.\n   * @param viewOptions.description\n   * Alters the metric stream:\n   *  This will be used as the description of the metrics stream.\n   *  If not provided, the original Instrument description will be used by default.\n   * @param viewOptions.attributesProcessors\n   * Alters the metric stream:\n   *  If provided, the attributes will be modified as defined by the added processors.\n   *  If not provided, all attribute keys will be used by default.\n   * @param viewOptions.aggregationCardinalityLimit\n   * Alters the metric stream:\n   *  Sets a limit on the number of unique attribute combinations (cardinality) that can be aggregated.\n   *  If not provided, the default limit of 2000 will be used.\n   * @param viewOptions.aggregation\n   * Alters the metric stream:\n   *  Alters the {@link Aggregation} of the metric stream.\n   * @param viewOptions.instrumentName\n   * Instrument selection criteria:\n   *  Original name of the Instrument(s) with wildcard support.\n   * @param viewOptions.instrumentType\n   * Instrument selection criteria:\n   *  The original type of the Instrument(s).\n   * @param viewOptions.instrumentUnit\n   * Instrument selection criteria:\n   *  The unit of the Instrument(s).\n   * @param viewOptions.meterName\n   * Instrument selection criteria:\n   *  The name of the Meter. No wildcard support, name must match the meter exactly.\n   * @param viewOptions.meterVersion\n   * Instrument selection criteria:\n   *  The version of the Meter. No wildcard support, version must match exactly.\n   * @param viewOptions.meterSchemaUrl\n   * Instrument selection criteria:\n   *  The schema URL of the Meter. No wildcard support, schema URL must match exactly.\n   *\n   * @example\n   * // Create a view that changes the Instrument 'my.instrument' to use to an\n   * // ExplicitBucketHistogramAggregation with the boundaries [20, 30, 40]\n   * new View({\n   *   aggregation: new ExplicitBucketHistogramAggregation([20, 30, 40]),\n   *   instrumentName: 'my.instrument'\n   * })\n   */\n  constructor(viewOptions: ViewOptions) {\n    validateViewOptions(viewOptions);\n\n    // Create multi-processor if attributesProcessors are defined.\n    if (viewOptions.attributesProcessors != null) {\n      this.attributesProcessor = createMultiAttributesProcessor(\n        viewOptions.attributesProcessors\n      );\n    } else {\n      this.attributesProcessor = createNoopAttributesProcessor();\n    }\n\n    this.name = viewOptions.name;\n    this.description = viewOptions.description;\n    this.aggregation = toAggregation(\n      viewOptions.aggregation ?? { type: AggregationType.DEFAULT }\n    );\n    this.instrumentSelector = new InstrumentSelector({\n      name: viewOptions.instrumentName,\n      type: viewOptions.instrumentType,\n      unit: viewOptions.instrumentUnit,\n    });\n    this.meterSelector = new MeterSelector({\n      name: viewOptions.meterName,\n      version: viewOptions.meterVersion,\n      schemaUrl: viewOptions.meterSchemaUrl,\n    });\n    this.aggregationCardinalityLimit = viewOptions.aggregationCardinalityLimit;\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAgBA,SAASA,gBAAgB,QAAQ,aAAa;AAC9C,SACEC,8BAA8B,EAC9BC,6BAA6B,QAExB,uBAAuB;AAC9B,SAASC,kBAAkB,QAAQ,sBAAsB;AACzD,SAASC,aAAa,QAAQ,iBAAiB;AAE/C,SAEEC,eAAe,EACfC,aAAa,QACR,qBAAqB;AA4G5B,SAASC,qBAAqBA,CAACC,OAAoB;EACjD,OACEA,OAAO,CAACC,cAAc,IAAI,IAAI,IAC9BD,OAAO,CAACE,cAAc,IAAI,IAAI,IAC9BF,OAAO,CAACG,cAAc,IAAI,IAAI,IAC9BH,OAAO,CAACI,SAAS,IAAI,IAAI,IACzBJ,OAAO,CAACK,YAAY,IAAI,IAAI,IAC5BL,OAAO,CAACM,cAAc,IAAI,IAAI;AAElC;AAEA,SAASC,mBAAmBA,CAACC,WAAwB;EACnD;EACA;EACA,IAAIT,qBAAqB,CAACS,WAAW,CAAC,EAAE;IACtC,MAAM,IAAIC,KAAK,CAAC,wDAAwD,CAAC;;EAG3E;EACA;EACA,IACED,WAAW,CAACE,IAAI,IAAI,IAAI,KACvBF,WAAW,EAAEP,cAAc,IAAI,IAAI,IAClCT,gBAAgB,CAACmB,WAAW,CAACH,WAAW,CAACP,cAAc,CAAC,CAAC,EAC3D;IACA,MAAM,IAAIQ,KAAK,CACb,yHAAyH,CAC1H;;AAEL;AAEA;;;AAGA,OAAM,MAAOG,IAAI;EACNF,IAAI;EACJG,WAAW;EACXC,WAAW;EACXC,mBAAmB;EACnBC,kBAAkB;EAClBC,aAAa;EACbC,2BAA2B;EAEpC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAwDAC,YAAYX,WAAwB;IAClCD,mBAAmB,CAACC,WAAW,CAAC;IAEhC;IACA,IAAIA,WAAW,CAACY,oBAAoB,IAAI,IAAI,EAAE;MAC5C,IAAI,CAACL,mBAAmB,GAAGtB,8BAA8B,CACvDe,WAAW,CAACY,oBAAoB,CACjC;KACF,MAAM;MACL,IAAI,CAACL,mBAAmB,GAAGrB,6BAA6B,EAAE;;IAG5D,IAAI,CAACgB,IAAI,GAAGF,WAAW,CAACE,IAAI;IAC5B,IAAI,CAACG,WAAW,GAAGL,WAAW,CAACK,WAAW;IAC1C,IAAI,CAACC,WAAW,GAAGhB,aAAa,CAC9BU,WAAW,CAACM,WAAW,IAAI;MAAEO,IAAI,EAAExB,eAAe,CAACyB;IAAO,CAAE,CAC7D;IACD,IAAI,CAACN,kBAAkB,GAAG,IAAIrB,kBAAkB,CAAC;MAC/Ce,IAAI,EAAEF,WAAW,CAACP,cAAc;MAChCoB,IAAI,EAAEb,WAAW,CAACN,cAAc;MAChCqB,IAAI,EAAEf,WAAW,CAACL;KACnB,CAAC;IACF,IAAI,CAACc,aAAa,GAAG,IAAIrB,aAAa,CAAC;MACrCc,IAAI,EAAEF,WAAW,CAACJ,SAAS;MAC3BoB,OAAO,EAAEhB,WAAW,CAACH,YAAY;MACjCoB,SAAS,EAAEjB,WAAW,CAACF;KACxB,CAAC;IACF,IAAI,CAACY,2BAA2B,GAAGV,WAAW,CAACU,2BAA2B;EAC5E","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
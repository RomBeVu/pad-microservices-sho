{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { hashAttributes } from '../utils';\nimport { AttributeHashMap } from './HashMap';\n/**\n * Internal interface.\n *\n * Allows synchronous collection of metrics. This processor should allow\n * allocation of new aggregation cells for metrics and convert cumulative\n * recording to delta data points.\n */\nexport class DeltaMetricProcessor {\n  _aggregator;\n  _activeCollectionStorage = new AttributeHashMap();\n  // TODO: find a reasonable mean to clean the memo;\n  // https://github.com/open-telemetry/opentelemetry-specification/pull/2208\n  _cumulativeMemoStorage = new AttributeHashMap();\n  _cardinalityLimit;\n  _overflowAttributes = {\n    'otel.metric.overflow': true\n  };\n  _overflowHashCode;\n  constructor(_aggregator, aggregationCardinalityLimit) {\n    this._aggregator = _aggregator;\n    this._cardinalityLimit = (aggregationCardinalityLimit ?? 2000) - 1;\n    this._overflowHashCode = hashAttributes(this._overflowAttributes);\n  }\n  record(value, attributes, _context, collectionTime) {\n    let accumulation = this._activeCollectionStorage.get(attributes);\n    if (!accumulation) {\n      if (this._activeCollectionStorage.size >= this._cardinalityLimit) {\n        const overflowAccumulation = this._activeCollectionStorage.getOrDefault(this._overflowAttributes, () => this._aggregator.createAccumulation(collectionTime));\n        overflowAccumulation?.record(value);\n        return;\n      }\n      accumulation = this._aggregator.createAccumulation(collectionTime);\n      this._activeCollectionStorage.set(attributes, accumulation);\n    }\n    accumulation?.record(value);\n  }\n  batchCumulate(measurements, collectionTime) {\n    Array.from(measurements.entries()).forEach(([attributes, value, hashCode]) => {\n      const accumulation = this._aggregator.createAccumulation(collectionTime);\n      accumulation?.record(value);\n      let delta = accumulation;\n      // Diff with recorded cumulative memo.\n      if (this._cumulativeMemoStorage.has(attributes, hashCode)) {\n        // has() returned true, previous is present.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const previous = this._cumulativeMemoStorage.get(attributes, hashCode);\n        delta = this._aggregator.diff(previous, accumulation);\n      } else {\n        // If the cardinality limit is reached, we need to change the attributes\n        if (this._cumulativeMemoStorage.size >= this._cardinalityLimit) {\n          attributes = this._overflowAttributes;\n          hashCode = this._overflowHashCode;\n          if (this._cumulativeMemoStorage.has(attributes, hashCode)) {\n            // has() returned true, previous is present.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const previous = this._cumulativeMemoStorage.get(attributes, hashCode);\n            delta = this._aggregator.diff(previous, accumulation);\n          }\n        }\n      }\n      // Merge with uncollected active delta.\n      if (this._activeCollectionStorage.has(attributes, hashCode)) {\n        // has() returned true, active is present.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const active = this._activeCollectionStorage.get(attributes, hashCode);\n        delta = this._aggregator.merge(active, delta);\n      }\n      // Save the current record and the delta record.\n      this._cumulativeMemoStorage.set(attributes, accumulation, hashCode);\n      this._activeCollectionStorage.set(attributes, delta, hashCode);\n    });\n  }\n  /**\n   * Returns a collection of delta metrics. Start time is the when first\n   * time event collected.\n   */\n  collect() {\n    const unreportedDelta = this._activeCollectionStorage;\n    this._activeCollectionStorage = new AttributeHashMap();\n    return unreportedDelta;\n  }\n}","map":{"version":3,"names":["hashAttributes","AttributeHashMap","DeltaMetricProcessor","_aggregator","_activeCollectionStorage","_cumulativeMemoStorage","_cardinalityLimit","_overflowAttributes","_overflowHashCode","constructor","aggregationCardinalityLimit","record","value","attributes","_context","collectionTime","accumulation","get","size","overflowAccumulation","getOrDefault","createAccumulation","set","batchCumulate","measurements","Array","from","entries","forEach","hashCode","delta","has","previous","diff","active","merge","collect","unreportedDelta"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/sdk-metrics/src/state/DeltaMetricProcessor.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context, HrTime, Attributes } from '@opentelemetry/api';\nimport { Maybe, hashAttributes } from '../utils';\nimport { Accumulation, Aggregator } from '../aggregator/types';\nimport { AttributeHashMap } from './HashMap';\n\n/**\n * Internal interface.\n *\n * Allows synchronous collection of metrics. This processor should allow\n * allocation of new aggregation cells for metrics and convert cumulative\n * recording to delta data points.\n */\nexport class DeltaMetricProcessor<T extends Maybe<Accumulation>> {\n  private _activeCollectionStorage = new AttributeHashMap<T>();\n  // TODO: find a reasonable mean to clean the memo;\n  // https://github.com/open-telemetry/opentelemetry-specification/pull/2208\n  private _cumulativeMemoStorage = new AttributeHashMap<T>();\n  private _cardinalityLimit: number;\n  private _overflowAttributes = { 'otel.metric.overflow': true };\n  private _overflowHashCode: string;\n\n  constructor(\n    private _aggregator: Aggregator<T>,\n    aggregationCardinalityLimit?: number\n  ) {\n    this._cardinalityLimit = (aggregationCardinalityLimit ?? 2000) - 1;\n    this._overflowHashCode = hashAttributes(this._overflowAttributes);\n  }\n\n  record(\n    value: number,\n    attributes: Attributes,\n    _context: Context,\n    collectionTime: HrTime\n  ) {\n    let accumulation = this._activeCollectionStorage.get(attributes);\n\n    if (!accumulation) {\n      if (this._activeCollectionStorage.size >= this._cardinalityLimit) {\n        const overflowAccumulation = this._activeCollectionStorage.getOrDefault(\n          this._overflowAttributes,\n          () => this._aggregator.createAccumulation(collectionTime)\n        );\n        overflowAccumulation?.record(value);\n        return;\n      }\n\n      accumulation = this._aggregator.createAccumulation(collectionTime);\n      this._activeCollectionStorage.set(attributes, accumulation);\n    }\n\n    accumulation?.record(value);\n  }\n\n  batchCumulate(\n    measurements: AttributeHashMap<number>,\n    collectionTime: HrTime\n  ) {\n    Array.from(measurements.entries()).forEach(\n      ([attributes, value, hashCode]) => {\n        const accumulation =\n          this._aggregator.createAccumulation(collectionTime);\n        accumulation?.record(value);\n        let delta = accumulation;\n        // Diff with recorded cumulative memo.\n        if (this._cumulativeMemoStorage.has(attributes, hashCode)) {\n          // has() returned true, previous is present.\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          const previous = this._cumulativeMemoStorage.get(\n            attributes,\n            hashCode\n          )!;\n          delta = this._aggregator.diff(previous, accumulation);\n        } else {\n          // If the cardinality limit is reached, we need to change the attributes\n          if (this._cumulativeMemoStorage.size >= this._cardinalityLimit) {\n            attributes = this._overflowAttributes;\n            hashCode = this._overflowHashCode;\n            if (this._cumulativeMemoStorage.has(attributes, hashCode)) {\n              // has() returned true, previous is present.\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              const previous = this._cumulativeMemoStorage.get(\n                attributes,\n                hashCode\n              )!;\n              delta = this._aggregator.diff(previous, accumulation);\n            }\n          }\n        }\n        // Merge with uncollected active delta.\n        if (this._activeCollectionStorage.has(attributes, hashCode)) {\n          // has() returned true, active is present.\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          const active = this._activeCollectionStorage.get(\n            attributes,\n            hashCode\n          )!;\n          delta = this._aggregator.merge(active, delta);\n        }\n\n        // Save the current record and the delta record.\n        this._cumulativeMemoStorage.set(attributes, accumulation, hashCode);\n        this._activeCollectionStorage.set(attributes, delta, hashCode);\n      }\n    );\n  }\n\n  /**\n   * Returns a collection of delta metrics. Start time is the when first\n   * time event collected.\n   */\n  collect() {\n    const unreportedDelta = this._activeCollectionStorage;\n    this._activeCollectionStorage = new AttributeHashMap();\n\n    return unreportedDelta;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
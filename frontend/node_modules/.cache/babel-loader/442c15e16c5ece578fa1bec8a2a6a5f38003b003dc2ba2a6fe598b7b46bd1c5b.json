{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ValueType, diag } from '@opentelemetry/api';\nimport { equalsCaseInsensitive } from './utils';\nexport function createInstrumentDescriptor(name, type, options) {\n  if (!isValidName(name)) {\n    diag.warn(`Invalid metric name: \"${name}\". The metric name should be a ASCII string with a length no greater than 255 characters.`);\n  }\n  return {\n    name,\n    type,\n    description: options?.description ?? '',\n    unit: options?.unit ?? '',\n    valueType: options?.valueType ?? ValueType.DOUBLE,\n    advice: options?.advice ?? {}\n  };\n}\nexport function createInstrumentDescriptorWithView(view, instrument) {\n  return {\n    name: view.name ?? instrument.name,\n    description: view.description ?? instrument.description,\n    type: instrument.type,\n    unit: instrument.unit,\n    valueType: instrument.valueType,\n    advice: instrument.advice\n  };\n}\nexport function isDescriptorCompatibleWith(descriptor, otherDescriptor) {\n  // Names are case-insensitive strings.\n  return equalsCaseInsensitive(descriptor.name, otherDescriptor.name) && descriptor.unit === otherDescriptor.unit && descriptor.type === otherDescriptor.type && descriptor.valueType === otherDescriptor.valueType;\n}\n// ASCII string with a length no greater than 255 characters.\n// NB: the first character counted separately from the rest.\nconst NAME_REGEXP = /^[a-z][a-z0-9_.\\-/]{0,254}$/i;\nexport function isValidName(name) {\n  return name.match(NAME_REGEXP) != null;\n}","map":{"version":3,"names":["ValueType","diag","equalsCaseInsensitive","createInstrumentDescriptor","name","type","options","isValidName","warn","description","unit","valueType","DOUBLE","advice","createInstrumentDescriptorWithView","view","instrument","isDescriptorCompatibleWith","descriptor","otherDescriptor","NAME_REGEXP","match"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/sdk-metrics/src/InstrumentDescriptor.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  MetricAdvice,\n  MetricOptions,\n  ValueType,\n  diag,\n} from '@opentelemetry/api';\nimport { View } from './view/View';\nimport { equalsCaseInsensitive } from './utils';\nimport { InstrumentType, MetricDescriptor } from './export/MetricData';\n\n/**\n * An internal interface describing the instrument.\n *\n * This is intentionally distinguished from the public MetricDescriptor (a.k.a. InstrumentDescriptor)\n * which may not contains internal fields like metric advice.\n */\nexport interface InstrumentDescriptor extends MetricDescriptor {\n  /**\n   * For internal use; exporter should avoid depending on the type of the\n   * instrument as their resulting aggregator can be re-mapped with views.\n   */\n  readonly type: InstrumentType;\n\n  /**\n   * See {@link MetricAdvice}\n   *\n   * @experimental\n   */\n  readonly advice: MetricAdvice;\n}\n\nexport function createInstrumentDescriptor(\n  name: string,\n  type: InstrumentType,\n  options?: MetricOptions\n): InstrumentDescriptor {\n  if (!isValidName(name)) {\n    diag.warn(\n      `Invalid metric name: \"${name}\". The metric name should be a ASCII string with a length no greater than 255 characters.`\n    );\n  }\n  return {\n    name,\n    type,\n    description: options?.description ?? '',\n    unit: options?.unit ?? '',\n    valueType: options?.valueType ?? ValueType.DOUBLE,\n    advice: options?.advice ?? {},\n  };\n}\n\nexport function createInstrumentDescriptorWithView(\n  view: View,\n  instrument: InstrumentDescriptor\n): InstrumentDescriptor {\n  return {\n    name: view.name ?? instrument.name,\n    description: view.description ?? instrument.description,\n    type: instrument.type,\n    unit: instrument.unit,\n    valueType: instrument.valueType,\n    advice: instrument.advice,\n  };\n}\n\nexport function isDescriptorCompatibleWith(\n  descriptor: InstrumentDescriptor,\n  otherDescriptor: InstrumentDescriptor\n) {\n  // Names are case-insensitive strings.\n  return (\n    equalsCaseInsensitive(descriptor.name, otherDescriptor.name) &&\n    descriptor.unit === otherDescriptor.unit &&\n    descriptor.type === otherDescriptor.type &&\n    descriptor.valueType === otherDescriptor.valueType\n  );\n}\n\n// ASCII string with a length no greater than 255 characters.\n// NB: the first character counted separately from the rest.\nconst NAME_REGEXP = /^[a-z][a-z0-9_.\\-/]{0,254}$/i;\nexport function isValidName(name: string): boolean {\n  return name.match(NAME_REGEXP) != null;\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAgBA,SAGEA,SAAS,EACTC,IAAI,QACC,oBAAoB;AAE3B,SAASC,qBAAqB,QAAQ,SAAS;AAwB/C,OAAM,SAAUC,0BAA0BA,CACxCC,IAAY,EACZC,IAAoB,EACpBC,OAAuB;EAEvB,IAAI,CAACC,WAAW,CAACH,IAAI,CAAC,EAAE;IACtBH,IAAI,CAACO,IAAI,CACP,yBAAyBJ,IAAI,2FAA2F,CACzH;;EAEH,OAAO;IACLA,IAAI;IACJC,IAAI;IACJI,WAAW,EAAEH,OAAO,EAAEG,WAAW,IAAI,EAAE;IACvCC,IAAI,EAAEJ,OAAO,EAAEI,IAAI,IAAI,EAAE;IACzBC,SAAS,EAAEL,OAAO,EAAEK,SAAS,IAAIX,SAAS,CAACY,MAAM;IACjDC,MAAM,EAAEP,OAAO,EAAEO,MAAM,IAAI;GAC5B;AACH;AAEA,OAAM,SAAUC,kCAAkCA,CAChDC,IAAU,EACVC,UAAgC;EAEhC,OAAO;IACLZ,IAAI,EAAEW,IAAI,CAACX,IAAI,IAAIY,UAAU,CAACZ,IAAI;IAClCK,WAAW,EAAEM,IAAI,CAACN,WAAW,IAAIO,UAAU,CAACP,WAAW;IACvDJ,IAAI,EAAEW,UAAU,CAACX,IAAI;IACrBK,IAAI,EAAEM,UAAU,CAACN,IAAI;IACrBC,SAAS,EAAEK,UAAU,CAACL,SAAS;IAC/BE,MAAM,EAAEG,UAAU,CAACH;GACpB;AACH;AAEA,OAAM,SAAUI,0BAA0BA,CACxCC,UAAgC,EAChCC,eAAqC;EAErC;EACA,OACEjB,qBAAqB,CAACgB,UAAU,CAACd,IAAI,EAAEe,eAAe,CAACf,IAAI,CAAC,IAC5Dc,UAAU,CAACR,IAAI,KAAKS,eAAe,CAACT,IAAI,IACxCQ,UAAU,CAACb,IAAI,KAAKc,eAAe,CAACd,IAAI,IACxCa,UAAU,CAACP,SAAS,KAAKQ,eAAe,CAACR,SAAS;AAEtD;AAEA;AACA;AACA,MAAMS,WAAW,GAAG,8BAA8B;AAClD,OAAM,SAAUb,WAAWA,CAACH,IAAY;EACtC,OAAOA,IAAI,CAACiB,KAAK,CAACD,WAAW,CAAC,IAAI,IAAI;AACxC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { isValidTraceId } from '@opentelemetry/api';\nimport { SamplingDecision } from '../Sampler';\n/** Sampler that samples a given fraction of traces based of trace id deterministically. */\nexport class TraceIdRatioBasedSampler {\n  _ratio;\n  _upperBound;\n  constructor(_ratio = 0) {\n    this._ratio = _ratio;\n    this._ratio = this._normalize(_ratio);\n    this._upperBound = Math.floor(this._ratio * 0xffffffff);\n  }\n  shouldSample(context, traceId) {\n    return {\n      decision: isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound ? SamplingDecision.RECORD_AND_SAMPLED : SamplingDecision.NOT_RECORD\n    };\n  }\n  toString() {\n    return `TraceIdRatioBased{${this._ratio}}`;\n  }\n  _normalize(ratio) {\n    if (typeof ratio !== 'number' || isNaN(ratio)) return 0;\n    return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;\n  }\n  _accumulate(traceId) {\n    let accumulation = 0;\n    for (let i = 0; i < traceId.length / 8; i++) {\n      const pos = i * 8;\n      const part = parseInt(traceId.slice(pos, pos + 8), 16);\n      accumulation = (accumulation ^ part) >>> 0;\n    }\n    return accumulation;\n  }\n}","map":{"version":3,"names":["isValidTraceId","SamplingDecision","TraceIdRatioBasedSampler","_ratio","_upperBound","constructor","_normalize","Math","floor","shouldSample","context","traceId","decision","_accumulate","RECORD_AND_SAMPLED","NOT_RECORD","toString","ratio","isNaN","accumulation","i","length","pos","part","parseInt","slice"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/sdk-trace-base/src/sampler/TraceIdRatioBasedSampler.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { isValidTraceId } from '@opentelemetry/api';\nimport { Sampler, SamplingDecision, SamplingResult } from '../Sampler';\n\n/** Sampler that samples a given fraction of traces based of trace id deterministically. */\nexport class TraceIdRatioBasedSampler implements Sampler {\n  private _upperBound: number;\n\n  constructor(private readonly _ratio: number = 0) {\n    this._ratio = this._normalize(_ratio);\n    this._upperBound = Math.floor(this._ratio * 0xffffffff);\n  }\n\n  shouldSample(context: unknown, traceId: string): SamplingResult {\n    return {\n      decision:\n        isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound\n          ? SamplingDecision.RECORD_AND_SAMPLED\n          : SamplingDecision.NOT_RECORD,\n    };\n  }\n\n  toString(): string {\n    return `TraceIdRatioBased{${this._ratio}}`;\n  }\n\n  private _normalize(ratio: number): number {\n    if (typeof ratio !== 'number' || isNaN(ratio)) return 0;\n    return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;\n  }\n\n  private _accumulate(traceId: string): number {\n    let accumulation = 0;\n    for (let i = 0; i < traceId.length / 8; i++) {\n      const pos = i * 8;\n      const part = parseInt(traceId.slice(pos, pos + 8), 16);\n      accumulation = (accumulation ^ part) >>> 0;\n    }\n    return accumulation;\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAgBA,SAASA,cAAc,QAAQ,oBAAoB;AACnD,SAAkBC,gBAAgB,QAAwB,YAAY;AAEtE;AACA,OAAM,MAAOC,wBAAwB;EAGNC,MAAA;EAFrBC,WAAW;EAEnBC,YAA6BF,MAAA,GAAiB,CAAC;IAAlB,KAAAA,MAAM,GAANA,MAAM;IACjC,IAAI,CAACA,MAAM,GAAG,IAAI,CAACG,UAAU,CAACH,MAAM,CAAC;IACrC,IAAI,CAACC,WAAW,GAAGG,IAAI,CAACC,KAAK,CAAC,IAAI,CAACL,MAAM,GAAG,UAAU,CAAC;EACzD;EAEAM,YAAYA,CAACC,OAAgB,EAAEC,OAAe;IAC5C,OAAO;MACLC,QAAQ,EACNZ,cAAc,CAACW,OAAO,CAAC,IAAI,IAAI,CAACE,WAAW,CAACF,OAAO,CAAC,GAAG,IAAI,CAACP,WAAW,GACnEH,gBAAgB,CAACa,kBAAkB,GACnCb,gBAAgB,CAACc;KACxB;EACH;EAEAC,QAAQA,CAAA;IACN,OAAO,qBAAqB,IAAI,CAACb,MAAM,GAAG;EAC5C;EAEQG,UAAUA,CAACW,KAAa;IAC9B,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAIC,KAAK,CAACD,KAAK,CAAC,EAAE,OAAO,CAAC;IACvD,OAAOA,KAAK,IAAI,CAAC,GAAG,CAAC,GAAGA,KAAK,IAAI,CAAC,GAAG,CAAC,GAAGA,KAAK;EAChD;EAEQJ,WAAWA,CAACF,OAAe;IACjC,IAAIQ,YAAY,GAAG,CAAC;IACpB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,OAAO,CAACU,MAAM,GAAG,CAAC,EAAED,CAAC,EAAE,EAAE;MAC3C,MAAME,GAAG,GAAGF,CAAC,GAAG,CAAC;MACjB,MAAMG,IAAI,GAAGC,QAAQ,CAACb,OAAO,CAACc,KAAK,CAACH,GAAG,EAAEA,GAAG,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC;MACtDH,YAAY,GAAG,CAACA,YAAY,GAAGI,IAAI,MAAM,CAAC;;IAE5C,OAAOJ,YAAY;EACrB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
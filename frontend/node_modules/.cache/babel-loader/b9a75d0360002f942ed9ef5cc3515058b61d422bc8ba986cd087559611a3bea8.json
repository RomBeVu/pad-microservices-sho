{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { globalErrorHandler } from '@opentelemetry/core';\n/**\n * Implementation of the {@link SpanProcessor} that simply forwards all\n * received events to a list of {@link SpanProcessor}s.\n */\nexport class MultiSpanProcessor {\n  _spanProcessors;\n  constructor(_spanProcessors) {\n    this._spanProcessors = _spanProcessors;\n  }\n  forceFlush() {\n    const promises = [];\n    for (const spanProcessor of this._spanProcessors) {\n      promises.push(spanProcessor.forceFlush());\n    }\n    return new Promise(resolve => {\n      Promise.all(promises).then(() => {\n        resolve();\n      }).catch(error => {\n        globalErrorHandler(error || new Error('MultiSpanProcessor: forceFlush failed'));\n        resolve();\n      });\n    });\n  }\n  onStart(span, context) {\n    for (const spanProcessor of this._spanProcessors) {\n      spanProcessor.onStart(span, context);\n    }\n  }\n  onEnd(span) {\n    for (const spanProcessor of this._spanProcessors) {\n      spanProcessor.onEnd(span);\n    }\n  }\n  shutdown() {\n    const promises = [];\n    for (const spanProcessor of this._spanProcessors) {\n      promises.push(spanProcessor.shutdown());\n    }\n    return new Promise((resolve, reject) => {\n      Promise.all(promises).then(() => {\n        resolve();\n      }, reject);\n    });\n  }\n}","map":{"version":3,"names":["globalErrorHandler","MultiSpanProcessor","_spanProcessors","constructor","forceFlush","promises","spanProcessor","push","Promise","resolve","all","then","catch","error","Error","onStart","span","context","onEnd","shutdown","reject"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/sdk-trace-base/src/MultiSpanProcessor.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '@opentelemetry/api';\nimport { globalErrorHandler } from '@opentelemetry/core';\nimport { ReadableSpan } from './export/ReadableSpan';\nimport { Span } from './Span';\nimport { SpanProcessor } from './SpanProcessor';\n\n/**\n * Implementation of the {@link SpanProcessor} that simply forwards all\n * received events to a list of {@link SpanProcessor}s.\n */\nexport class MultiSpanProcessor implements SpanProcessor {\n  constructor(private readonly _spanProcessors: SpanProcessor[]) {}\n\n  forceFlush(): Promise<void> {\n    const promises: Promise<void>[] = [];\n\n    for (const spanProcessor of this._spanProcessors) {\n      promises.push(spanProcessor.forceFlush());\n    }\n    return new Promise(resolve => {\n      Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(error => {\n          globalErrorHandler(\n            error || new Error('MultiSpanProcessor: forceFlush failed')\n          );\n          resolve();\n        });\n    });\n  }\n\n  onStart(span: Span, context: Context): void {\n    for (const spanProcessor of this._spanProcessors) {\n      spanProcessor.onStart(span, context);\n    }\n  }\n\n  onEnd(span: ReadableSpan): void {\n    for (const spanProcessor of this._spanProcessors) {\n      spanProcessor.onEnd(span);\n    }\n  }\n\n  shutdown(): Promise<void> {\n    const promises: Promise<void>[] = [];\n\n    for (const spanProcessor of this._spanProcessors) {\n      promises.push(spanProcessor.shutdown());\n    }\n    return new Promise((resolve, reject) => {\n      Promise.all(promises).then(() => {\n        resolve();\n      }, reject);\n    });\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAiBA,SAASA,kBAAkB,QAAQ,qBAAqB;AAKxD;;;;AAIA,OAAM,MAAOC,kBAAkB;EACAC,eAAA;EAA7BC,YAA6BD,eAAgC;IAAhC,KAAAA,eAAe,GAAfA,eAAe;EAAoB;EAEhEE,UAAUA,CAAA;IACR,MAAMC,QAAQ,GAAoB,EAAE;IAEpC,KAAK,MAAMC,aAAa,IAAI,IAAI,CAACJ,eAAe,EAAE;MAChDG,QAAQ,CAACE,IAAI,CAACD,aAAa,CAACF,UAAU,EAAE,CAAC;;IAE3C,OAAO,IAAII,OAAO,CAACC,OAAO,IAAG;MAC3BD,OAAO,CAACE,GAAG,CAACL,QAAQ,CAAC,CAClBM,IAAI,CAAC,MAAK;QACTF,OAAO,EAAE;MACX,CAAC,CAAC,CACDG,KAAK,CAACC,KAAK,IAAG;QACbb,kBAAkB,CAChBa,KAAK,IAAI,IAAIC,KAAK,CAAC,uCAAuC,CAAC,CAC5D;QACDL,OAAO,EAAE;MACX,CAAC,CAAC;IACN,CAAC,CAAC;EACJ;EAEAM,OAAOA,CAACC,IAAU,EAAEC,OAAgB;IAClC,KAAK,MAAMX,aAAa,IAAI,IAAI,CAACJ,eAAe,EAAE;MAChDI,aAAa,CAACS,OAAO,CAACC,IAAI,EAAEC,OAAO,CAAC;;EAExC;EAEAC,KAAKA,CAACF,IAAkB;IACtB,KAAK,MAAMV,aAAa,IAAI,IAAI,CAACJ,eAAe,EAAE;MAChDI,aAAa,CAACY,KAAK,CAACF,IAAI,CAAC;;EAE7B;EAEAG,QAAQA,CAAA;IACN,MAAMd,QAAQ,GAAoB,EAAE;IAEpC,KAAK,MAAMC,aAAa,IAAI,IAAI,CAACJ,eAAe,EAAE;MAChDG,QAAQ,CAACE,IAAI,CAACD,aAAa,CAACa,QAAQ,EAAE,CAAC;;IAEzC,OAAO,IAAIX,OAAO,CAAC,CAACC,OAAO,EAAEW,MAAM,KAAI;MACrCZ,OAAO,CAACE,GAAG,CAACL,QAAQ,CAAC,CAACM,IAAI,CAAC,MAAK;QAC9BF,OAAO,EAAE;MACX,CAAC,EAAEW,MAAM,CAAC;IACZ,CAAC,CAAC;EACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
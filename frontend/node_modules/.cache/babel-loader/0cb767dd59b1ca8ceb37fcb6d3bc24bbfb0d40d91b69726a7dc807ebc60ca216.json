{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { merge } from '@opentelemetry/core';\nimport { defaultResource } from '@opentelemetry/resources';\nimport { Tracer } from './Tracer';\nimport { loadDefaultConfig } from './config';\nimport { MultiSpanProcessor } from './MultiSpanProcessor';\nimport { reconfigureLimits } from './utility';\nexport var ForceFlushState;\n(function (ForceFlushState) {\n  ForceFlushState[ForceFlushState[\"resolved\"] = 0] = \"resolved\";\n  ForceFlushState[ForceFlushState[\"timeout\"] = 1] = \"timeout\";\n  ForceFlushState[ForceFlushState[\"error\"] = 2] = \"error\";\n  ForceFlushState[ForceFlushState[\"unresolved\"] = 3] = \"unresolved\";\n})(ForceFlushState || (ForceFlushState = {}));\n/**\n * This class represents a basic tracer provider which platform libraries can extend\n */\nexport class BasicTracerProvider {\n  _config;\n  _tracers = new Map();\n  _resource;\n  _activeSpanProcessor;\n  constructor(config = {}) {\n    const mergedConfig = merge({}, loadDefaultConfig(), reconfigureLimits(config));\n    this._resource = mergedConfig.resource ?? defaultResource();\n    this._config = Object.assign({}, mergedConfig, {\n      resource: this._resource\n    });\n    const spanProcessors = [];\n    if (config.spanProcessors?.length) {\n      spanProcessors.push(...config.spanProcessors);\n    }\n    this._activeSpanProcessor = new MultiSpanProcessor(spanProcessors);\n  }\n  getTracer(name, version, options) {\n    const key = `${name}@${version || ''}:${options?.schemaUrl || ''}`;\n    if (!this._tracers.has(key)) {\n      this._tracers.set(key, new Tracer({\n        name,\n        version,\n        schemaUrl: options?.schemaUrl\n      }, this._config, this._resource, this._activeSpanProcessor));\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this._tracers.get(key);\n  }\n  forceFlush() {\n    const timeout = this._config.forceFlushTimeoutMillis;\n    const promises = this._activeSpanProcessor['_spanProcessors'].map(spanProcessor => {\n      return new Promise(resolve => {\n        let state;\n        const timeoutInterval = setTimeout(() => {\n          resolve(new Error(`Span processor did not completed within timeout period of ${timeout} ms`));\n          state = ForceFlushState.timeout;\n        }, timeout);\n        spanProcessor.forceFlush().then(() => {\n          clearTimeout(timeoutInterval);\n          if (state !== ForceFlushState.timeout) {\n            state = ForceFlushState.resolved;\n            resolve(state);\n          }\n        }).catch(error => {\n          clearTimeout(timeoutInterval);\n          state = ForceFlushState.error;\n          resolve(error);\n        });\n      });\n    });\n    return new Promise((resolve, reject) => {\n      Promise.all(promises).then(results => {\n        const errors = results.filter(result => result !== ForceFlushState.resolved);\n        if (errors.length > 0) {\n          reject(errors);\n        } else {\n          resolve();\n        }\n      }).catch(error => reject([error]));\n    });\n  }\n  shutdown() {\n    return this._activeSpanProcessor.shutdown();\n  }\n}","map":{"version":3,"names":["merge","defaultResource","Tracer","loadDefaultConfig","MultiSpanProcessor","reconfigureLimits","ForceFlushState","BasicTracerProvider","_config","_tracers","Map","_resource","_activeSpanProcessor","constructor","config","mergedConfig","resource","Object","assign","spanProcessors","length","push","getTracer","name","version","options","key","schemaUrl","has","set","get","forceFlush","timeout","forceFlushTimeoutMillis","promises","map","spanProcessor","Promise","resolve","state","timeoutInterval","setTimeout","Error","then","clearTimeout","resolved","catch","error","reject","all","results","errors","filter","result","shutdown"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/sdk-trace-base/src/BasicTracerProvider.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { TracerProvider, Tracer as ApiTracer } from '@opentelemetry/api';\nimport { merge } from '@opentelemetry/core';\nimport { defaultResource, Resource } from '@opentelemetry/resources';\nimport { SpanProcessor } from './SpanProcessor';\nimport { Tracer } from './Tracer';\nimport { loadDefaultConfig } from './config';\nimport { MultiSpanProcessor } from './MultiSpanProcessor';\nimport { TracerConfig } from './types';\nimport { reconfigureLimits } from './utility';\n\nexport enum ForceFlushState {\n  'resolved',\n  'timeout',\n  'error',\n  'unresolved',\n}\n\n/**\n * This class represents a basic tracer provider which platform libraries can extend\n */\nexport class BasicTracerProvider implements TracerProvider {\n  private readonly _config: TracerConfig;\n  private readonly _tracers: Map<string, Tracer> = new Map();\n  private readonly _resource: Resource;\n  private readonly _activeSpanProcessor: MultiSpanProcessor;\n\n  constructor(config: TracerConfig = {}) {\n    const mergedConfig = merge(\n      {},\n      loadDefaultConfig(),\n      reconfigureLimits(config)\n    );\n    this._resource = mergedConfig.resource ?? defaultResource();\n\n    this._config = Object.assign({}, mergedConfig, {\n      resource: this._resource,\n    });\n\n    const spanProcessors: SpanProcessor[] = [];\n\n    if (config.spanProcessors?.length) {\n      spanProcessors.push(...config.spanProcessors);\n    }\n\n    this._activeSpanProcessor = new MultiSpanProcessor(spanProcessors);\n  }\n\n  getTracer(\n    name: string,\n    version?: string,\n    options?: { schemaUrl?: string }\n  ): ApiTracer {\n    const key = `${name}@${version || ''}:${options?.schemaUrl || ''}`;\n    if (!this._tracers.has(key)) {\n      this._tracers.set(\n        key,\n        new Tracer(\n          { name, version, schemaUrl: options?.schemaUrl },\n          this._config,\n          this._resource,\n          this._activeSpanProcessor\n        )\n      );\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this._tracers.get(key)!;\n  }\n\n  forceFlush(): Promise<void> {\n    const timeout = this._config.forceFlushTimeoutMillis;\n    const promises = this._activeSpanProcessor['_spanProcessors'].map(\n      (spanProcessor: SpanProcessor) => {\n        return new Promise(resolve => {\n          let state: ForceFlushState;\n          const timeoutInterval = setTimeout(() => {\n            resolve(\n              new Error(\n                `Span processor did not completed within timeout period of ${timeout} ms`\n              )\n            );\n            state = ForceFlushState.timeout;\n          }, timeout);\n\n          spanProcessor\n            .forceFlush()\n            .then(() => {\n              clearTimeout(timeoutInterval);\n              if (state !== ForceFlushState.timeout) {\n                state = ForceFlushState.resolved;\n                resolve(state);\n              }\n            })\n            .catch(error => {\n              clearTimeout(timeoutInterval);\n              state = ForceFlushState.error;\n              resolve(error);\n            });\n        });\n      }\n    );\n\n    return new Promise<void>((resolve, reject) => {\n      Promise.all(promises)\n        .then(results => {\n          const errors = results.filter(\n            result => result !== ForceFlushState.resolved\n          );\n          if (errors.length > 0) {\n            reject(errors);\n          } else {\n            resolve();\n          }\n        })\n        .catch(error => reject([error]));\n    });\n  }\n\n  shutdown(): Promise<void> {\n    return this._activeSpanProcessor.shutdown();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
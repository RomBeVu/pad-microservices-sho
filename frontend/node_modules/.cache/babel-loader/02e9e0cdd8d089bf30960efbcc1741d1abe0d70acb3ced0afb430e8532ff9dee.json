{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { AggregatorKind } from './types';\nimport { millisToHrTime, hrTimeToMicroseconds } from '@opentelemetry/core';\nimport { DataPointType } from '../export/MetricData';\nexport class LastValueAccumulation {\n  startTime;\n  _current;\n  sampleTime;\n  constructor(startTime, _current = 0, sampleTime = [0, 0]) {\n    this.startTime = startTime;\n    this._current = _current;\n    this.sampleTime = sampleTime;\n  }\n  record(value) {\n    this._current = value;\n    this.sampleTime = millisToHrTime(Date.now());\n  }\n  setStartTime(startTime) {\n    this.startTime = startTime;\n  }\n  toPointValue() {\n    return this._current;\n  }\n}\n/** Basic aggregator which calculates a LastValue from individual measurements. */\nexport class LastValueAggregator {\n  kind = AggregatorKind.LAST_VALUE;\n  createAccumulation(startTime) {\n    return new LastValueAccumulation(startTime);\n  }\n  /**\n   * Returns the result of the merge of the given accumulations.\n   *\n   * Return the newly captured (delta) accumulation for LastValueAggregator.\n   */\n  merge(previous, delta) {\n    // nanoseconds may lose precisions.\n    const latestAccumulation = hrTimeToMicroseconds(delta.sampleTime) >= hrTimeToMicroseconds(previous.sampleTime) ? delta : previous;\n    return new LastValueAccumulation(previous.startTime, latestAccumulation.toPointValue(), latestAccumulation.sampleTime);\n  }\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   *\n   * A delta aggregation is not meaningful to LastValueAggregator, just return\n   * the newly captured (delta) accumulation for LastValueAggregator.\n   */\n  diff(previous, current) {\n    // nanoseconds may lose precisions.\n    const latestAccumulation = hrTimeToMicroseconds(current.sampleTime) >= hrTimeToMicroseconds(previous.sampleTime) ? current : previous;\n    return new LastValueAccumulation(current.startTime, latestAccumulation.toPointValue(), latestAccumulation.sampleTime);\n  }\n  toMetricData(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {\n    return {\n      descriptor,\n      aggregationTemporality,\n      dataPointType: DataPointType.GAUGE,\n      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {\n        return {\n          attributes,\n          startTime: accumulation.startTime,\n          endTime,\n          value: accumulation.toPointValue()\n        };\n      })\n    };\n  }\n}","map":{"version":3,"names":["AggregatorKind","millisToHrTime","hrTimeToMicroseconds","DataPointType","LastValueAccumulation","startTime","_current","sampleTime","constructor","record","value","Date","now","setStartTime","toPointValue","LastValueAggregator","kind","LAST_VALUE","createAccumulation","merge","previous","delta","latestAccumulation","diff","current","toMetricData","descriptor","aggregationTemporality","accumulationByAttributes","endTime","dataPointType","GAUGE","dataPoints","map","attributes","accumulation"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/sdk-metrics/src/aggregator/LastValue.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Accumulation,\n  AccumulationRecord,\n  Aggregator,\n  AggregatorKind,\n  LastValue,\n} from './types';\nimport { HrTime } from '@opentelemetry/api';\nimport { millisToHrTime, hrTimeToMicroseconds } from '@opentelemetry/core';\nimport { DataPointType, GaugeMetricData } from '../export/MetricData';\nimport { Maybe } from '../utils';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\n\nexport class LastValueAccumulation implements Accumulation {\n  constructor(\n    public startTime: HrTime,\n    private _current: number = 0,\n    public sampleTime: HrTime = [0, 0]\n  ) {}\n\n  record(value: number): void {\n    this._current = value;\n    this.sampleTime = millisToHrTime(Date.now());\n  }\n\n  setStartTime(startTime: HrTime): void {\n    this.startTime = startTime;\n  }\n\n  toPointValue(): LastValue {\n    return this._current;\n  }\n}\n\n/** Basic aggregator which calculates a LastValue from individual measurements. */\nexport class LastValueAggregator implements Aggregator<LastValueAccumulation> {\n  public kind: AggregatorKind.LAST_VALUE = AggregatorKind.LAST_VALUE;\n\n  createAccumulation(startTime: HrTime) {\n    return new LastValueAccumulation(startTime);\n  }\n\n  /**\n   * Returns the result of the merge of the given accumulations.\n   *\n   * Return the newly captured (delta) accumulation for LastValueAggregator.\n   */\n  merge(\n    previous: LastValueAccumulation,\n    delta: LastValueAccumulation\n  ): LastValueAccumulation {\n    // nanoseconds may lose precisions.\n    const latestAccumulation =\n      hrTimeToMicroseconds(delta.sampleTime) >=\n      hrTimeToMicroseconds(previous.sampleTime)\n        ? delta\n        : previous;\n    return new LastValueAccumulation(\n      previous.startTime,\n      latestAccumulation.toPointValue(),\n      latestAccumulation.sampleTime\n    );\n  }\n\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   *\n   * A delta aggregation is not meaningful to LastValueAggregator, just return\n   * the newly captured (delta) accumulation for LastValueAggregator.\n   */\n  diff(\n    previous: LastValueAccumulation,\n    current: LastValueAccumulation\n  ): LastValueAccumulation {\n    // nanoseconds may lose precisions.\n    const latestAccumulation =\n      hrTimeToMicroseconds(current.sampleTime) >=\n      hrTimeToMicroseconds(previous.sampleTime)\n        ? current\n        : previous;\n    return new LastValueAccumulation(\n      current.startTime,\n      latestAccumulation.toPointValue(),\n      latestAccumulation.sampleTime\n    );\n  }\n\n  toMetricData(\n    descriptor: InstrumentDescriptor,\n    aggregationTemporality: AggregationTemporality,\n    accumulationByAttributes: AccumulationRecord<LastValueAccumulation>[],\n    endTime: HrTime\n  ): Maybe<GaugeMetricData> {\n    return {\n      descriptor,\n      aggregationTemporality,\n      dataPointType: DataPointType.GAUGE,\n      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {\n        return {\n          attributes,\n          startTime: accumulation.startTime,\n          endTime,\n          value: accumulation.toPointValue(),\n        };\n      }),\n    };\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAgBA,SAIEA,cAAc,QAET,SAAS;AAEhB,SAASC,cAAc,EAAEC,oBAAoB,QAAQ,qBAAqB;AAC1E,SAASC,aAAa,QAAyB,sBAAsB;AAKrE,OAAM,MAAOC,qBAAqB;EAEvBC,SAAA;EACCC,QAAA;EACDC,UAAA;EAHTC,YACSH,SAAiB,EAChBC,QAAA,GAAmB,CAAC,EACrBC,UAAA,GAAqB,CAAC,CAAC,EAAE,CAAC,CAAC;IAF3B,KAAAF,SAAS,GAATA,SAAS;IACR,KAAAC,QAAQ,GAARA,QAAQ;IACT,KAAAC,UAAU,GAAVA,UAAU;EAChB;EAEHE,MAAMA,CAACC,KAAa;IAClB,IAAI,CAACJ,QAAQ,GAAGI,KAAK;IACrB,IAAI,CAACH,UAAU,GAAGN,cAAc,CAACU,IAAI,CAACC,GAAG,EAAE,CAAC;EAC9C;EAEAC,YAAYA,CAACR,SAAiB;IAC5B,IAAI,CAACA,SAAS,GAAGA,SAAS;EAC5B;EAEAS,YAAYA,CAAA;IACV,OAAO,IAAI,CAACR,QAAQ;EACtB;;AAGF;AACA,OAAM,MAAOS,mBAAmB;EACvBC,IAAI,GAA8BhB,cAAc,CAACiB,UAAU;EAElEC,kBAAkBA,CAACb,SAAiB;IAClC,OAAO,IAAID,qBAAqB,CAACC,SAAS,CAAC;EAC7C;EAEA;;;;;EAKAc,KAAKA,CACHC,QAA+B,EAC/BC,KAA4B;IAE5B;IACA,MAAMC,kBAAkB,GACtBpB,oBAAoB,CAACmB,KAAK,CAACd,UAAU,CAAC,IACtCL,oBAAoB,CAACkB,QAAQ,CAACb,UAAU,CAAC,GACrCc,KAAK,GACLD,QAAQ;IACd,OAAO,IAAIhB,qBAAqB,CAC9BgB,QAAQ,CAACf,SAAS,EAClBiB,kBAAkB,CAACR,YAAY,EAAE,EACjCQ,kBAAkB,CAACf,UAAU,CAC9B;EACH;EAEA;;;;;;EAMAgB,IAAIA,CACFH,QAA+B,EAC/BI,OAA8B;IAE9B;IACA,MAAMF,kBAAkB,GACtBpB,oBAAoB,CAACsB,OAAO,CAACjB,UAAU,CAAC,IACxCL,oBAAoB,CAACkB,QAAQ,CAACb,UAAU,CAAC,GACrCiB,OAAO,GACPJ,QAAQ;IACd,OAAO,IAAIhB,qBAAqB,CAC9BoB,OAAO,CAACnB,SAAS,EACjBiB,kBAAkB,CAACR,YAAY,EAAE,EACjCQ,kBAAkB,CAACf,UAAU,CAC9B;EACH;EAEAkB,YAAYA,CACVC,UAAgC,EAChCC,sBAA8C,EAC9CC,wBAAqE,EACrEC,OAAe;IAEf,OAAO;MACLH,UAAU;MACVC,sBAAsB;MACtBG,aAAa,EAAE3B,aAAa,CAAC4B,KAAK;MAClCC,UAAU,EAAEJ,wBAAwB,CAACK,GAAG,CAAC,CAAC,CAACC,UAAU,EAAEC,YAAY,CAAC,KAAI;QACtE,OAAO;UACLD,UAAU;UACV7B,SAAS,EAAE8B,YAAY,CAAC9B,SAAS;UACjCwB,OAAO;UACPnB,KAAK,EAAEyB,YAAY,CAACrB,YAAY;SACjC;MACH,CAAC;KACF;EACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { isSpanContextValid, trace, TraceFlags } from '@opentelemetry/api';\nimport { isTracingSuppressed } from './suppress-tracing';\nimport { TraceState } from './TraceState';\nexport const TRACE_PARENT_HEADER = 'traceparent';\nexport const TRACE_STATE_HEADER = 'tracestate';\nconst VERSION = '00';\nconst VERSION_PART = '(?!ff)[\\\\da-f]{2}';\nconst TRACE_ID_PART = '(?![0]{32})[\\\\da-f]{32}';\nconst PARENT_ID_PART = '(?![0]{16})[\\\\da-f]{16}';\nconst FLAGS_PART = '[\\\\da-f]{2}';\nconst TRACE_PARENT_REGEX = new RegExp(`^\\\\s?(${VERSION_PART})-(${TRACE_ID_PART})-(${PARENT_ID_PART})-(${FLAGS_PART})(-.*)?\\\\s?$`);\n/**\n * Parses information from the [traceparent] span tag and converts it into {@link SpanContext}\n * @param traceParent - A meta property that comes from server.\n *     It should be dynamically generated server side to have the server's request trace Id,\n *     a parent span Id that was set on the server's request span,\n *     and the trace flags to indicate the server's sampling decision\n *     (01 = sampled, 00 = not sampled).\n *     for example: '{version}-{traceId}-{spanId}-{sampleDecision}'\n *     For more information see {@link https://www.w3.org/TR/trace-context/}\n */\nexport function parseTraceParent(traceParent) {\n  const match = TRACE_PARENT_REGEX.exec(traceParent);\n  if (!match) return null;\n  // According to the specification the implementation should be compatible\n  // with future versions. If there are more parts, we only reject it if it's using version 00\n  // See https://www.w3.org/TR/trace-context/#versioning-of-traceparent\n  if (match[1] === '00' && match[5]) return null;\n  return {\n    traceId: match[2],\n    spanId: match[3],\n    traceFlags: parseInt(match[4], 16)\n  };\n}\n/**\n * Propagates {@link SpanContext} through Trace Context format propagation.\n *\n * Based on the Trace Context specification:\n * https://www.w3.org/TR/trace-context/\n */\nexport class W3CTraceContextPropagator {\n  inject(context, carrier, setter) {\n    const spanContext = trace.getSpanContext(context);\n    if (!spanContext || isTracingSuppressed(context) || !isSpanContextValid(spanContext)) return;\n    const traceParent = `${VERSION}-${spanContext.traceId}-${spanContext.spanId}-0${Number(spanContext.traceFlags || TraceFlags.NONE).toString(16)}`;\n    setter.set(carrier, TRACE_PARENT_HEADER, traceParent);\n    if (spanContext.traceState) {\n      setter.set(carrier, TRACE_STATE_HEADER, spanContext.traceState.serialize());\n    }\n  }\n  extract(context, carrier, getter) {\n    const traceParentHeader = getter.get(carrier, TRACE_PARENT_HEADER);\n    if (!traceParentHeader) return context;\n    const traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;\n    if (typeof traceParent !== 'string') return context;\n    const spanContext = parseTraceParent(traceParent);\n    if (!spanContext) return context;\n    spanContext.isRemote = true;\n    const traceStateHeader = getter.get(carrier, TRACE_STATE_HEADER);\n    if (traceStateHeader) {\n      // If more than one `tracestate` header is found, we merge them into a\n      // single header.\n      const state = Array.isArray(traceStateHeader) ? traceStateHeader.join(',') : traceStateHeader;\n      spanContext.traceState = new TraceState(typeof state === 'string' ? state : undefined);\n    }\n    return trace.setSpanContext(context, spanContext);\n  }\n  fields() {\n    return [TRACE_PARENT_HEADER, TRACE_STATE_HEADER];\n  }\n}","map":{"version":3,"names":["isSpanContextValid","trace","TraceFlags","isTracingSuppressed","TraceState","TRACE_PARENT_HEADER","TRACE_STATE_HEADER","VERSION","VERSION_PART","TRACE_ID_PART","PARENT_ID_PART","FLAGS_PART","TRACE_PARENT_REGEX","RegExp","parseTraceParent","traceParent","match","exec","traceId","spanId","traceFlags","parseInt","W3CTraceContextPropagator","inject","context","carrier","setter","spanContext","getSpanContext","Number","NONE","toString","set","traceState","serialize","extract","getter","traceParentHeader","get","Array","isArray","isRemote","traceStateHeader","state","join","undefined","setSpanContext","fields"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/core/src/trace/W3CTraceContextPropagator.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Context,\n  isSpanContextValid,\n  SpanContext,\n  TextMapGetter,\n  TextMapPropagator,\n  TextMapSetter,\n  trace,\n  TraceFlags,\n} from '@opentelemetry/api';\nimport { isTracingSuppressed } from './suppress-tracing';\nimport { TraceState } from './TraceState';\n\nexport const TRACE_PARENT_HEADER = 'traceparent';\nexport const TRACE_STATE_HEADER = 'tracestate';\n\nconst VERSION = '00';\nconst VERSION_PART = '(?!ff)[\\\\da-f]{2}';\nconst TRACE_ID_PART = '(?![0]{32})[\\\\da-f]{32}';\nconst PARENT_ID_PART = '(?![0]{16})[\\\\da-f]{16}';\nconst FLAGS_PART = '[\\\\da-f]{2}';\nconst TRACE_PARENT_REGEX = new RegExp(\n  `^\\\\s?(${VERSION_PART})-(${TRACE_ID_PART})-(${PARENT_ID_PART})-(${FLAGS_PART})(-.*)?\\\\s?$`\n);\n\n/**\n * Parses information from the [traceparent] span tag and converts it into {@link SpanContext}\n * @param traceParent - A meta property that comes from server.\n *     It should be dynamically generated server side to have the server's request trace Id,\n *     a parent span Id that was set on the server's request span,\n *     and the trace flags to indicate the server's sampling decision\n *     (01 = sampled, 00 = not sampled).\n *     for example: '{version}-{traceId}-{spanId}-{sampleDecision}'\n *     For more information see {@link https://www.w3.org/TR/trace-context/}\n */\nexport function parseTraceParent(traceParent: string): SpanContext | null {\n  const match = TRACE_PARENT_REGEX.exec(traceParent);\n  if (!match) return null;\n\n  // According to the specification the implementation should be compatible\n  // with future versions. If there are more parts, we only reject it if it's using version 00\n  // See https://www.w3.org/TR/trace-context/#versioning-of-traceparent\n  if (match[1] === '00' && match[5]) return null;\n\n  return {\n    traceId: match[2],\n    spanId: match[3],\n    traceFlags: parseInt(match[4], 16),\n  };\n}\n\n/**\n * Propagates {@link SpanContext} through Trace Context format propagation.\n *\n * Based on the Trace Context specification:\n * https://www.w3.org/TR/trace-context/\n */\nexport class W3CTraceContextPropagator implements TextMapPropagator {\n  inject(context: Context, carrier: unknown, setter: TextMapSetter): void {\n    const spanContext = trace.getSpanContext(context);\n    if (\n      !spanContext ||\n      isTracingSuppressed(context) ||\n      !isSpanContextValid(spanContext)\n    )\n      return;\n\n    const traceParent = `${VERSION}-${spanContext.traceId}-${\n      spanContext.spanId\n    }-0${Number(spanContext.traceFlags || TraceFlags.NONE).toString(16)}`;\n\n    setter.set(carrier, TRACE_PARENT_HEADER, traceParent);\n    if (spanContext.traceState) {\n      setter.set(\n        carrier,\n        TRACE_STATE_HEADER,\n        spanContext.traceState.serialize()\n      );\n    }\n  }\n\n  extract(context: Context, carrier: unknown, getter: TextMapGetter): Context {\n    const traceParentHeader = getter.get(carrier, TRACE_PARENT_HEADER);\n    if (!traceParentHeader) return context;\n    const traceParent = Array.isArray(traceParentHeader)\n      ? traceParentHeader[0]\n      : traceParentHeader;\n    if (typeof traceParent !== 'string') return context;\n    const spanContext = parseTraceParent(traceParent);\n    if (!spanContext) return context;\n\n    spanContext.isRemote = true;\n\n    const traceStateHeader = getter.get(carrier, TRACE_STATE_HEADER);\n    if (traceStateHeader) {\n      // If more than one `tracestate` header is found, we merge them into a\n      // single header.\n      const state = Array.isArray(traceStateHeader)\n        ? traceStateHeader.join(',')\n        : traceStateHeader;\n      spanContext.traceState = new TraceState(\n        typeof state === 'string' ? state : undefined\n      );\n    }\n    return trace.setSpanContext(context, spanContext);\n  }\n\n  fields(): string[] {\n    return [TRACE_PARENT_HEADER, TRACE_STATE_HEADER];\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAgBA,SAEEA,kBAAkB,EAKlBC,KAAK,EACLC,UAAU,QACL,oBAAoB;AAC3B,SAASC,mBAAmB,QAAQ,oBAAoB;AACxD,SAASC,UAAU,QAAQ,cAAc;AAEzC,OAAO,MAAMC,mBAAmB,GAAG,aAAa;AAChD,OAAO,MAAMC,kBAAkB,GAAG,YAAY;AAE9C,MAAMC,OAAO,GAAG,IAAI;AACpB,MAAMC,YAAY,GAAG,mBAAmB;AACxC,MAAMC,aAAa,GAAG,yBAAyB;AAC/C,MAAMC,cAAc,GAAG,yBAAyB;AAChD,MAAMC,UAAU,GAAG,aAAa;AAChC,MAAMC,kBAAkB,GAAG,IAAIC,MAAM,CACnC,SAASL,YAAY,MAAMC,aAAa,MAAMC,cAAc,MAAMC,UAAU,cAAc,CAC3F;AAED;;;;;;;;;;AAUA,OAAM,SAAUG,gBAAgBA,CAACC,WAAmB;EAClD,MAAMC,KAAK,GAAGJ,kBAAkB,CAACK,IAAI,CAACF,WAAW,CAAC;EAClD,IAAI,CAACC,KAAK,EAAE,OAAO,IAAI;EAEvB;EACA;EACA;EACA,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,KAAK,CAAC,CAAC,CAAC,EAAE,OAAO,IAAI;EAE9C,OAAO;IACLE,OAAO,EAAEF,KAAK,CAAC,CAAC,CAAC;IACjBG,MAAM,EAAEH,KAAK,CAAC,CAAC,CAAC;IAChBI,UAAU,EAAEC,QAAQ,CAACL,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE;GAClC;AACH;AAEA;;;;;;AAMA,OAAM,MAAOM,yBAAyB;EACpCC,MAAMA,CAACC,OAAgB,EAAEC,OAAgB,EAAEC,MAAqB;IAC9D,MAAMC,WAAW,GAAG1B,KAAK,CAAC2B,cAAc,CAACJ,OAAO,CAAC;IACjD,IACE,CAACG,WAAW,IACZxB,mBAAmB,CAACqB,OAAO,CAAC,IAC5B,CAACxB,kBAAkB,CAAC2B,WAAW,CAAC,EAEhC;IAEF,MAAMZ,WAAW,GAAG,GAAGR,OAAO,IAAIoB,WAAW,CAACT,OAAO,IACnDS,WAAW,CAACR,MACd,KAAKU,MAAM,CAACF,WAAW,CAACP,UAAU,IAAIlB,UAAU,CAAC4B,IAAI,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,EAAE;IAErEL,MAAM,CAACM,GAAG,CAACP,OAAO,EAAEpB,mBAAmB,EAAEU,WAAW,CAAC;IACrD,IAAIY,WAAW,CAACM,UAAU,EAAE;MAC1BP,MAAM,CAACM,GAAG,CACRP,OAAO,EACPnB,kBAAkB,EAClBqB,WAAW,CAACM,UAAU,CAACC,SAAS,EAAE,CACnC;;EAEL;EAEAC,OAAOA,CAACX,OAAgB,EAAEC,OAAgB,EAAEW,MAAqB;IAC/D,MAAMC,iBAAiB,GAAGD,MAAM,CAACE,GAAG,CAACb,OAAO,EAAEpB,mBAAmB,CAAC;IAClE,IAAI,CAACgC,iBAAiB,EAAE,OAAOb,OAAO;IACtC,MAAMT,WAAW,GAAGwB,KAAK,CAACC,OAAO,CAACH,iBAAiB,CAAC,GAChDA,iBAAiB,CAAC,CAAC,CAAC,GACpBA,iBAAiB;IACrB,IAAI,OAAOtB,WAAW,KAAK,QAAQ,EAAE,OAAOS,OAAO;IACnD,MAAMG,WAAW,GAAGb,gBAAgB,CAACC,WAAW,CAAC;IACjD,IAAI,CAACY,WAAW,EAAE,OAAOH,OAAO;IAEhCG,WAAW,CAACc,QAAQ,GAAG,IAAI;IAE3B,MAAMC,gBAAgB,GAAGN,MAAM,CAACE,GAAG,CAACb,OAAO,EAAEnB,kBAAkB,CAAC;IAChE,IAAIoC,gBAAgB,EAAE;MACpB;MACA;MACA,MAAMC,KAAK,GAAGJ,KAAK,CAACC,OAAO,CAACE,gBAAgB,CAAC,GACzCA,gBAAgB,CAACE,IAAI,CAAC,GAAG,CAAC,GAC1BF,gBAAgB;MACpBf,WAAW,CAACM,UAAU,GAAG,IAAI7B,UAAU,CACrC,OAAOuC,KAAK,KAAK,QAAQ,GAAGA,KAAK,GAAGE,SAAS,CAC9C;;IAEH,OAAO5C,KAAK,CAAC6C,cAAc,CAACtB,OAAO,EAAEG,WAAW,CAAC;EACnD;EAEAoB,MAAMA,CAAA;IACJ,OAAO,CAAC1C,mBAAmB,EAAEC,kBAAkB,CAAC;EAClD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
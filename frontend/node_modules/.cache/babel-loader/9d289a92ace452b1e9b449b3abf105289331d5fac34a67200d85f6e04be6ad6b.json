{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { validateKey, validateValue } from '../internal/validators';\nconst MAX_TRACE_STATE_ITEMS = 32;\nconst MAX_TRACE_STATE_LEN = 512;\nconst LIST_MEMBERS_SEPARATOR = ',';\nconst LIST_MEMBER_KEY_VALUE_SPLITTER = '=';\n/**\n * TraceState must be a class and not a simple object type because of the spec\n * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).\n *\n * Here is the list of allowed mutations:\n * - New key-value pair should be added into the beginning of the list\n * - The value of any key can be updated. Modified keys MUST be moved to the\n * beginning of the list.\n */\nexport class TraceState {\n  _internalState = new Map();\n  constructor(rawTraceState) {\n    if (rawTraceState) this._parse(rawTraceState);\n  }\n  set(key, value) {\n    // TODO: Benchmark the different approaches(map vs list) and\n    // use the faster one.\n    const traceState = this._clone();\n    if (traceState._internalState.has(key)) {\n      traceState._internalState.delete(key);\n    }\n    traceState._internalState.set(key, value);\n    return traceState;\n  }\n  unset(key) {\n    const traceState = this._clone();\n    traceState._internalState.delete(key);\n    return traceState;\n  }\n  get(key) {\n    return this._internalState.get(key);\n  }\n  serialize() {\n    return this._keys().reduce((agg, key) => {\n      agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));\n      return agg;\n    }, []).join(LIST_MEMBERS_SEPARATOR);\n  }\n  _parse(rawTraceState) {\n    if (rawTraceState.length > MAX_TRACE_STATE_LEN) return;\n    this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning\n    .reduce((agg, part) => {\n      const listMember = part.trim(); // Optional Whitespace (OWS) handling\n      const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);\n      if (i !== -1) {\n        const key = listMember.slice(0, i);\n        const value = listMember.slice(i + 1, part.length);\n        if (validateKey(key) && validateValue(value)) {\n          agg.set(key, value);\n        } else {\n          // TODO: Consider to add warning log\n        }\n      }\n      return agg;\n    }, new Map());\n    // Because of the reverse() requirement, trunc must be done after map is created\n    if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {\n      this._internalState = new Map(Array.from(this._internalState.entries()).reverse() // Use reverse same as original tracestate parse chain\n      .slice(0, MAX_TRACE_STATE_ITEMS));\n    }\n  }\n  _keys() {\n    return Array.from(this._internalState.keys()).reverse();\n  }\n  _clone() {\n    const traceState = new TraceState();\n    traceState._internalState = new Map(this._internalState);\n    return traceState;\n  }\n}","map":{"version":3,"names":["validateKey","validateValue","MAX_TRACE_STATE_ITEMS","MAX_TRACE_STATE_LEN","LIST_MEMBERS_SEPARATOR","LIST_MEMBER_KEY_VALUE_SPLITTER","TraceState","_internalState","Map","constructor","rawTraceState","_parse","set","key","value","traceState","_clone","has","delete","unset","get","serialize","_keys","reduce","agg","push","join","length","split","reverse","part","listMember","trim","i","indexOf","slice","size","Array","from","entries","keys"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/core/src/trace/TraceState.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport { validateKey, validateValue } from '../internal/validators';\n\nconst MAX_TRACE_STATE_ITEMS = 32;\nconst MAX_TRACE_STATE_LEN = 512;\nconst LIST_MEMBERS_SEPARATOR = ',';\nconst LIST_MEMBER_KEY_VALUE_SPLITTER = '=';\n\n/**\n * TraceState must be a class and not a simple object type because of the spec\n * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).\n *\n * Here is the list of allowed mutations:\n * - New key-value pair should be added into the beginning of the list\n * - The value of any key can be updated. Modified keys MUST be moved to the\n * beginning of the list.\n */\nexport class TraceState implements api.TraceState {\n  private _internalState: Map<string, string> = new Map();\n\n  constructor(rawTraceState?: string) {\n    if (rawTraceState) this._parse(rawTraceState);\n  }\n\n  set(key: string, value: string): TraceState {\n    // TODO: Benchmark the different approaches(map vs list) and\n    // use the faster one.\n    const traceState = this._clone();\n    if (traceState._internalState.has(key)) {\n      traceState._internalState.delete(key);\n    }\n    traceState._internalState.set(key, value);\n    return traceState;\n  }\n\n  unset(key: string): TraceState {\n    const traceState = this._clone();\n    traceState._internalState.delete(key);\n    return traceState;\n  }\n\n  get(key: string): string | undefined {\n    return this._internalState.get(key);\n  }\n\n  serialize(): string {\n    return this._keys()\n      .reduce((agg: string[], key) => {\n        agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));\n        return agg;\n      }, [])\n      .join(LIST_MEMBERS_SEPARATOR);\n  }\n\n  private _parse(rawTraceState: string) {\n    if (rawTraceState.length > MAX_TRACE_STATE_LEN) return;\n    this._internalState = rawTraceState\n      .split(LIST_MEMBERS_SEPARATOR)\n      .reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning\n      .reduce((agg: Map<string, string>, part: string) => {\n        const listMember = part.trim(); // Optional Whitespace (OWS) handling\n        const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);\n        if (i !== -1) {\n          const key = listMember.slice(0, i);\n          const value = listMember.slice(i + 1, part.length);\n          if (validateKey(key) && validateValue(value)) {\n            agg.set(key, value);\n          } else {\n            // TODO: Consider to add warning log\n          }\n        }\n        return agg;\n      }, new Map());\n\n    // Because of the reverse() requirement, trunc must be done after map is created\n    if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {\n      this._internalState = new Map(\n        Array.from(this._internalState.entries())\n          .reverse() // Use reverse same as original tracestate parse chain\n          .slice(0, MAX_TRACE_STATE_ITEMS)\n      );\n    }\n  }\n\n  private _keys(): string[] {\n    return Array.from(this._internalState.keys()).reverse();\n  }\n\n  private _clone(): TraceState {\n    const traceState = new TraceState();\n    traceState._internalState = new Map(this._internalState);\n    return traceState;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as ieee754 from './ieee754';\nimport * as util from '../util';\nimport { MappingError } from './types';\n/**\n * ExponentMapping implements exponential mapping functions for\n * scales <=0. For scales > 0 LogarithmMapping should be used.\n */\nexport class ExponentMapping {\n  _shift;\n  constructor(scale) {\n    this._shift = -scale;\n  }\n  /**\n   * Maps positive floating point values to indexes corresponding to scale\n   * @param value\n   * @returns {number} index for provided value at the current scale\n   */\n  mapToIndex(value) {\n    if (value < ieee754.MIN_VALUE) {\n      return this._minNormalLowerBoundaryIndex();\n    }\n    const exp = ieee754.getNormalBase2(value);\n    // In case the value is an exact power of two, compute a\n    // correction of -1. Note, we are using a custom _rightShift\n    // to accommodate a 52-bit argument, which the native bitwise\n    // operators do not support\n    const correction = this._rightShift(ieee754.getSignificand(value) - 1, ieee754.SIGNIFICAND_WIDTH);\n    return exp + correction >> this._shift;\n  }\n  /**\n   * Returns the lower bucket boundary for the given index for scale\n   *\n   * @param index\n   * @returns {number}\n   */\n  lowerBoundary(index) {\n    const minIndex = this._minNormalLowerBoundaryIndex();\n    if (index < minIndex) {\n      throw new MappingError(`underflow: ${index} is < minimum lower boundary: ${minIndex}`);\n    }\n    const maxIndex = this._maxNormalLowerBoundaryIndex();\n    if (index > maxIndex) {\n      throw new MappingError(`overflow: ${index} is > maximum lower boundary: ${maxIndex}`);\n    }\n    return util.ldexp(1, index << this._shift);\n  }\n  /**\n   * The scale used by this mapping\n   * @returns {number}\n   */\n  get scale() {\n    if (this._shift === 0) {\n      return 0;\n    }\n    return -this._shift;\n  }\n  _minNormalLowerBoundaryIndex() {\n    let index = ieee754.MIN_NORMAL_EXPONENT >> this._shift;\n    if (this._shift < 2) {\n      index--;\n    }\n    return index;\n  }\n  _maxNormalLowerBoundaryIndex() {\n    return ieee754.MAX_NORMAL_EXPONENT >> this._shift;\n  }\n  _rightShift(value, shift) {\n    return Math.floor(value * Math.pow(2, -shift));\n  }\n}","map":{"version":3,"names":["ieee754","util","MappingError","ExponentMapping","_shift","constructor","scale","mapToIndex","value","MIN_VALUE","_minNormalLowerBoundaryIndex","exp","getNormalBase2","correction","_rightShift","getSignificand","SIGNIFICAND_WIDTH","lowerBoundary","index","minIndex","maxIndex","_maxNormalLowerBoundaryIndex","ldexp","MIN_NORMAL_EXPONENT","MAX_NORMAL_EXPONENT","shift","Math","floor","pow"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/sdk-metrics/src/aggregator/exponential-histogram/mapping/ExponentMapping.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as ieee754 from './ieee754';\nimport * as util from '../util';\nimport { Mapping, MappingError } from './types';\n\n/**\n * ExponentMapping implements exponential mapping functions for\n * scales <=0. For scales > 0 LogarithmMapping should be used.\n */\nexport class ExponentMapping implements Mapping {\n  private readonly _shift: number;\n\n  constructor(scale: number) {\n    this._shift = -scale;\n  }\n\n  /**\n   * Maps positive floating point values to indexes corresponding to scale\n   * @param value\n   * @returns {number} index for provided value at the current scale\n   */\n  mapToIndex(value: number): number {\n    if (value < ieee754.MIN_VALUE) {\n      return this._minNormalLowerBoundaryIndex();\n    }\n\n    const exp = ieee754.getNormalBase2(value);\n\n    // In case the value is an exact power of two, compute a\n    // correction of -1. Note, we are using a custom _rightShift\n    // to accommodate a 52-bit argument, which the native bitwise\n    // operators do not support\n    const correction = this._rightShift(\n      ieee754.getSignificand(value) - 1,\n      ieee754.SIGNIFICAND_WIDTH\n    );\n\n    return (exp + correction) >> this._shift;\n  }\n\n  /**\n   * Returns the lower bucket boundary for the given index for scale\n   *\n   * @param index\n   * @returns {number}\n   */\n  lowerBoundary(index: number): number {\n    const minIndex = this._minNormalLowerBoundaryIndex();\n    if (index < minIndex) {\n      throw new MappingError(\n        `underflow: ${index} is < minimum lower boundary: ${minIndex}`\n      );\n    }\n    const maxIndex = this._maxNormalLowerBoundaryIndex();\n    if (index > maxIndex) {\n      throw new MappingError(\n        `overflow: ${index} is > maximum lower boundary: ${maxIndex}`\n      );\n    }\n\n    return util.ldexp(1, index << this._shift);\n  }\n\n  /**\n   * The scale used by this mapping\n   * @returns {number}\n   */\n  get scale(): number {\n    if (this._shift === 0) {\n      return 0;\n    }\n    return -this._shift;\n  }\n\n  private _minNormalLowerBoundaryIndex(): number {\n    let index = ieee754.MIN_NORMAL_EXPONENT >> this._shift;\n    if (this._shift < 2) {\n      index--;\n    }\n\n    return index;\n  }\n\n  private _maxNormalLowerBoundaryIndex(): number {\n    return ieee754.MAX_NORMAL_EXPONENT >> this._shift;\n  }\n\n  private _rightShift(value: number, shift: number): number {\n    return Math.floor(value * Math.pow(2, -shift));\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAeA,OAAO,KAAKA,OAAO,MAAM,WAAW;AACpC,OAAO,KAAKC,IAAI,MAAM,SAAS;AAC/B,SAAkBC,YAAY,QAAQ,SAAS;AAE/C;;;;AAIA,OAAM,MAAOC,eAAe;EACTC,MAAM;EAEvBC,YAAYC,KAAa;IACvB,IAAI,CAACF,MAAM,GAAG,CAACE,KAAK;EACtB;EAEA;;;;;EAKAC,UAAUA,CAACC,KAAa;IACtB,IAAIA,KAAK,GAAGR,OAAO,CAACS,SAAS,EAAE;MAC7B,OAAO,IAAI,CAACC,4BAA4B,EAAE;;IAG5C,MAAMC,GAAG,GAAGX,OAAO,CAACY,cAAc,CAACJ,KAAK,CAAC;IAEzC;IACA;IACA;IACA;IACA,MAAMK,UAAU,GAAG,IAAI,CAACC,WAAW,CACjCd,OAAO,CAACe,cAAc,CAACP,KAAK,CAAC,GAAG,CAAC,EACjCR,OAAO,CAACgB,iBAAiB,CAC1B;IAED,OAAQL,GAAG,GAAGE,UAAU,IAAK,IAAI,CAACT,MAAM;EAC1C;EAEA;;;;;;EAMAa,aAAaA,CAACC,KAAa;IACzB,MAAMC,QAAQ,GAAG,IAAI,CAACT,4BAA4B,EAAE;IACpD,IAAIQ,KAAK,GAAGC,QAAQ,EAAE;MACpB,MAAM,IAAIjB,YAAY,CACpB,cAAcgB,KAAK,iCAAiCC,QAAQ,EAAE,CAC/D;;IAEH,MAAMC,QAAQ,GAAG,IAAI,CAACC,4BAA4B,EAAE;IACpD,IAAIH,KAAK,GAAGE,QAAQ,EAAE;MACpB,MAAM,IAAIlB,YAAY,CACpB,aAAagB,KAAK,iCAAiCE,QAAQ,EAAE,CAC9D;;IAGH,OAAOnB,IAAI,CAACqB,KAAK,CAAC,CAAC,EAAEJ,KAAK,IAAI,IAAI,CAACd,MAAM,CAAC;EAC5C;EAEA;;;;EAIA,IAAIE,KAAKA,CAAA;IACP,IAAI,IAAI,CAACF,MAAM,KAAK,CAAC,EAAE;MACrB,OAAO,CAAC;;IAEV,OAAO,CAAC,IAAI,CAACA,MAAM;EACrB;EAEQM,4BAA4BA,CAAA;IAClC,IAAIQ,KAAK,GAAGlB,OAAO,CAACuB,mBAAmB,IAAI,IAAI,CAACnB,MAAM;IACtD,IAAI,IAAI,CAACA,MAAM,GAAG,CAAC,EAAE;MACnBc,KAAK,EAAE;;IAGT,OAAOA,KAAK;EACd;EAEQG,4BAA4BA,CAAA;IAClC,OAAOrB,OAAO,CAACwB,mBAAmB,IAAI,IAAI,CAACpB,MAAM;EACnD;EAEQU,WAAWA,CAACN,KAAa,EAAEiB,KAAa;IAC9C,OAAOC,IAAI,CAACC,KAAK,CAACnB,KAAK,GAAGkB,IAAI,CAACE,GAAG,CAAC,CAAC,EAAE,CAACH,KAAK,CAAC,CAAC;EAChD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
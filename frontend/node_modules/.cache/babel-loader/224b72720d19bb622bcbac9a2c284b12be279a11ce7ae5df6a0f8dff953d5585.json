{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { diag, SpanStatusCode } from '@opentelemetry/api';\nimport { addHrTimes, millisToHrTime, getTimeOrigin, hrTime, hrTimeDuration, isAttributeValue, isTimeInput, isTimeInputHrTime, otperformance, sanitizeAttributes } from '@opentelemetry/core';\nimport { ATTR_EXCEPTION_MESSAGE, ATTR_EXCEPTION_STACKTRACE, ATTR_EXCEPTION_TYPE } from '@opentelemetry/semantic-conventions';\nimport { ExceptionEventName } from './enums';\n/**\n * This class represents a span.\n */\nexport class SpanImpl {\n  // Below properties are included to implement ReadableSpan for export\n  // purposes but are not intended to be written-to directly.\n  _spanContext;\n  kind;\n  parentSpanContext;\n  attributes = {};\n  links = [];\n  events = [];\n  startTime;\n  resource;\n  instrumentationScope;\n  _droppedAttributesCount = 0;\n  _droppedEventsCount = 0;\n  _droppedLinksCount = 0;\n  name;\n  status = {\n    code: SpanStatusCode.UNSET\n  };\n  endTime = [0, 0];\n  _ended = false;\n  _duration = [-1, -1];\n  _spanProcessor;\n  _spanLimits;\n  _attributeValueLengthLimit;\n  _performanceStartTime;\n  _performanceOffset;\n  _startTimeProvided;\n  /**\n   * Constructs a new SpanImpl instance.\n   */\n  constructor(opts) {\n    const now = Date.now();\n    this._spanContext = opts.spanContext;\n    this._performanceStartTime = otperformance.now();\n    this._performanceOffset = now - (this._performanceStartTime + getTimeOrigin());\n    this._startTimeProvided = opts.startTime != null;\n    this._spanLimits = opts.spanLimits;\n    this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0;\n    this._spanProcessor = opts.spanProcessor;\n    this.name = opts.name;\n    this.parentSpanContext = opts.parentSpanContext;\n    this.kind = opts.kind;\n    this.links = opts.links || [];\n    this.startTime = this._getTime(opts.startTime ?? now);\n    this.resource = opts.resource;\n    this.instrumentationScope = opts.scope;\n    if (opts.attributes != null) {\n      this.setAttributes(opts.attributes);\n    }\n    this._spanProcessor.onStart(this, opts.context);\n  }\n  spanContext() {\n    return this._spanContext;\n  }\n  setAttribute(key, value) {\n    if (value == null || this._isSpanEnded()) return this;\n    if (key.length === 0) {\n      diag.warn(`Invalid attribute key: ${key}`);\n      return this;\n    }\n    if (!isAttributeValue(value)) {\n      diag.warn(`Invalid attribute value set for key: ${key}`);\n      return this;\n    }\n    const {\n      attributeCountLimit\n    } = this._spanLimits;\n    if (attributeCountLimit !== undefined && Object.keys(this.attributes).length >= attributeCountLimit && !Object.prototype.hasOwnProperty.call(this.attributes, key)) {\n      this._droppedAttributesCount++;\n      return this;\n    }\n    this.attributes[key] = this._truncateToSize(value);\n    return this;\n  }\n  setAttributes(attributes) {\n    for (const [k, v] of Object.entries(attributes)) {\n      this.setAttribute(k, v);\n    }\n    return this;\n  }\n  /**\n   *\n   * @param name Span Name\n   * @param [attributesOrStartTime] Span attributes or start time\n   *     if type is {@type TimeInput} and 3rd param is undefined\n   * @param [timeStamp] Specified time stamp for the event\n   */\n  addEvent(name, attributesOrStartTime, timeStamp) {\n    if (this._isSpanEnded()) return this;\n    const {\n      eventCountLimit\n    } = this._spanLimits;\n    if (eventCountLimit === 0) {\n      diag.warn('No events allowed.');\n      this._droppedEventsCount++;\n      return this;\n    }\n    if (eventCountLimit !== undefined && this.events.length >= eventCountLimit) {\n      if (this._droppedEventsCount === 0) {\n        diag.debug('Dropping extra events.');\n      }\n      this.events.shift();\n      this._droppedEventsCount++;\n    }\n    if (isTimeInput(attributesOrStartTime)) {\n      if (!isTimeInput(timeStamp)) {\n        timeStamp = attributesOrStartTime;\n      }\n      attributesOrStartTime = undefined;\n    }\n    const attributes = sanitizeAttributes(attributesOrStartTime);\n    this.events.push({\n      name,\n      attributes,\n      time: this._getTime(timeStamp),\n      droppedAttributesCount: 0\n    });\n    return this;\n  }\n  addLink(link) {\n    this.links.push(link);\n    return this;\n  }\n  addLinks(links) {\n    this.links.push(...links);\n    return this;\n  }\n  setStatus(status) {\n    if (this._isSpanEnded()) return this;\n    this.status = {\n      ...status\n    };\n    // When using try-catch, the caught \"error\" is of type `any`. When then assigning `any` to `status.message`,\n    // TypeScript will not error. While this can happen during use of any API, it is more common on Span#setStatus()\n    // as it's likely used in a catch-block. Therefore, we validate if `status.message` is actually a string, null, or\n    // undefined to avoid an incorrect type causing issues downstream.\n    if (this.status.message != null && typeof status.message !== 'string') {\n      diag.warn(`Dropping invalid status.message of type '${typeof status.message}', expected 'string'`);\n      delete this.status.message;\n    }\n    return this;\n  }\n  updateName(name) {\n    if (this._isSpanEnded()) return this;\n    this.name = name;\n    return this;\n  }\n  end(endTime) {\n    if (this._isSpanEnded()) {\n      diag.error(`${this.name} ${this._spanContext.traceId}-${this._spanContext.spanId} - You can only call end() on a span once.`);\n      return;\n    }\n    this._ended = true;\n    this.endTime = this._getTime(endTime);\n    this._duration = hrTimeDuration(this.startTime, this.endTime);\n    if (this._duration[0] < 0) {\n      diag.warn('Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.', this.startTime, this.endTime);\n      this.endTime = this.startTime.slice();\n      this._duration = [0, 0];\n    }\n    if (this._droppedEventsCount > 0) {\n      diag.warn(`Dropped ${this._droppedEventsCount} events because eventCountLimit reached`);\n    }\n    this._spanProcessor.onEnd(this);\n  }\n  _getTime(inp) {\n    if (typeof inp === 'number' && inp <= otperformance.now()) {\n      // must be a performance timestamp\n      // apply correction and convert to hrtime\n      return hrTime(inp + this._performanceOffset);\n    }\n    if (typeof inp === 'number') {\n      return millisToHrTime(inp);\n    }\n    if (inp instanceof Date) {\n      return millisToHrTime(inp.getTime());\n    }\n    if (isTimeInputHrTime(inp)) {\n      return inp;\n    }\n    if (this._startTimeProvided) {\n      // if user provided a time for the start manually\n      // we can't use duration to calculate event/end times\n      return millisToHrTime(Date.now());\n    }\n    const msDuration = otperformance.now() - this._performanceStartTime;\n    return addHrTimes(this.startTime, millisToHrTime(msDuration));\n  }\n  isRecording() {\n    return this._ended === false;\n  }\n  recordException(exception, time) {\n    const attributes = {};\n    if (typeof exception === 'string') {\n      attributes[ATTR_EXCEPTION_MESSAGE] = exception;\n    } else if (exception) {\n      if (exception.code) {\n        attributes[ATTR_EXCEPTION_TYPE] = exception.code.toString();\n      } else if (exception.name) {\n        attributes[ATTR_EXCEPTION_TYPE] = exception.name;\n      }\n      if (exception.message) {\n        attributes[ATTR_EXCEPTION_MESSAGE] = exception.message;\n      }\n      if (exception.stack) {\n        attributes[ATTR_EXCEPTION_STACKTRACE] = exception.stack;\n      }\n    }\n    // these are minimum requirements from spec\n    if (attributes[ATTR_EXCEPTION_TYPE] || attributes[ATTR_EXCEPTION_MESSAGE]) {\n      this.addEvent(ExceptionEventName, attributes, time);\n    } else {\n      diag.warn(`Failed to record an exception ${exception}`);\n    }\n  }\n  get duration() {\n    return this._duration;\n  }\n  get ended() {\n    return this._ended;\n  }\n  get droppedAttributesCount() {\n    return this._droppedAttributesCount;\n  }\n  get droppedEventsCount() {\n    return this._droppedEventsCount;\n  }\n  get droppedLinksCount() {\n    return this._droppedLinksCount;\n  }\n  _isSpanEnded() {\n    if (this._ended) {\n      const error = new Error(`Operation attempted on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`);\n      diag.warn(`Cannot execute the operation on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`, error);\n    }\n    return this._ended;\n  }\n  // Utility function to truncate given value within size\n  // for value type of string, will truncate to given limit\n  // for type of non-string, will return same value\n  _truncateToLimitUtil(value, limit) {\n    if (value.length <= limit) {\n      return value;\n    }\n    return value.substring(0, limit);\n  }\n  /**\n   * If the given attribute value is of type string and has more characters than given {@code attributeValueLengthLimit} then\n   * return string with truncated to {@code attributeValueLengthLimit} characters\n   *\n   * If the given attribute value is array of strings then\n   * return new array of strings with each element truncated to {@code attributeValueLengthLimit} characters\n   *\n   * Otherwise return same Attribute {@code value}\n   *\n   * @param value Attribute value\n   * @returns truncated attribute value if required, otherwise same value\n   */\n  _truncateToSize(value) {\n    const limit = this._attributeValueLengthLimit;\n    // Check limit\n    if (limit <= 0) {\n      // Negative values are invalid, so do not truncate\n      diag.warn(`Attribute value limit must be positive, got ${limit}`);\n      return value;\n    }\n    // String\n    if (typeof value === 'string') {\n      return this._truncateToLimitUtil(value, limit);\n    }\n    // Array of strings\n    if (Array.isArray(value)) {\n      return value.map(val => typeof val === 'string' ? this._truncateToLimitUtil(val, limit) : val);\n    }\n    // Other types, no need to apply value length limit\n    return value;\n  }\n}","map":{"version":3,"names":["diag","SpanStatusCode","addHrTimes","millisToHrTime","getTimeOrigin","hrTime","hrTimeDuration","isAttributeValue","isTimeInput","isTimeInputHrTime","otperformance","sanitizeAttributes","ATTR_EXCEPTION_MESSAGE","ATTR_EXCEPTION_STACKTRACE","ATTR_EXCEPTION_TYPE","ExceptionEventName","SpanImpl","_spanContext","kind","parentSpanContext","attributes","links","events","startTime","resource","instrumentationScope","_droppedAttributesCount","_droppedEventsCount","_droppedLinksCount","name","status","code","UNSET","endTime","_ended","_duration","_spanProcessor","_spanLimits","_attributeValueLengthLimit","_performanceStartTime","_performanceOffset","_startTimeProvided","constructor","opts","now","Date","spanContext","spanLimits","attributeValueLengthLimit","spanProcessor","_getTime","scope","setAttributes","onStart","context","setAttribute","key","value","_isSpanEnded","length","warn","attributeCountLimit","undefined","Object","keys","prototype","hasOwnProperty","call","_truncateToSize","k","v","entries","addEvent","attributesOrStartTime","timeStamp","eventCountLimit","debug","shift","push","time","droppedAttributesCount","addLink","link","addLinks","setStatus","message","updateName","end","error","traceId","spanId","slice","onEnd","inp","getTime","msDuration","isRecording","recordException","exception","toString","stack","duration","ended","droppedEventsCount","droppedLinksCount","Error","_truncateToLimitUtil","limit","substring","Array","isArray","map","val"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/sdk-trace-base/src/Span.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Context,\n  diag,\n  Exception,\n  HrTime,\n  Link,\n  Span as APISpan,\n  Attributes,\n  AttributeValue,\n  SpanContext,\n  SpanKind,\n  SpanStatus,\n  SpanStatusCode,\n  TimeInput,\n} from '@opentelemetry/api';\nimport {\n  addHrTimes,\n  millisToHrTime,\n  getTimeOrigin,\n  hrTime,\n  hrTimeDuration,\n  InstrumentationScope,\n  isAttributeValue,\n  isTimeInput,\n  isTimeInputHrTime,\n  otperformance,\n  sanitizeAttributes,\n} from '@opentelemetry/core';\nimport { Resource } from '@opentelemetry/resources';\nimport {\n  ATTR_EXCEPTION_MESSAGE,\n  ATTR_EXCEPTION_STACKTRACE,\n  ATTR_EXCEPTION_TYPE,\n} from '@opentelemetry/semantic-conventions';\nimport { ReadableSpan } from './export/ReadableSpan';\nimport { ExceptionEventName } from './enums';\nimport { SpanProcessor } from './SpanProcessor';\nimport { TimedEvent } from './TimedEvent';\nimport { SpanLimits } from './types';\n\n/**\n * This type provides the properties of @link{ReadableSpan} at the same time\n * of the Span API\n */\nexport type Span = APISpan & ReadableSpan;\n\ninterface SpanOptions {\n  resource: Resource;\n  scope: InstrumentationScope;\n  context: Context;\n  spanContext: SpanContext;\n  name: string;\n  kind: SpanKind;\n  parentSpanContext?: SpanContext;\n  links?: Link[];\n  startTime?: TimeInput;\n  attributes?: Attributes;\n  spanLimits: SpanLimits;\n  spanProcessor: SpanProcessor;\n}\n\n/**\n * This class represents a span.\n */\nexport class SpanImpl implements Span {\n  // Below properties are included to implement ReadableSpan for export\n  // purposes but are not intended to be written-to directly.\n  private readonly _spanContext: SpanContext;\n  readonly kind: SpanKind;\n  readonly parentSpanContext?: SpanContext;\n  readonly attributes: Attributes = {};\n  readonly links: Link[] = [];\n  readonly events: TimedEvent[] = [];\n  readonly startTime: HrTime;\n  readonly resource: Resource;\n  readonly instrumentationScope: InstrumentationScope;\n\n  private _droppedAttributesCount = 0;\n  private _droppedEventsCount: number = 0;\n  private _droppedLinksCount: number = 0;\n\n  name: string;\n  status: SpanStatus = {\n    code: SpanStatusCode.UNSET,\n  };\n  endTime: HrTime = [0, 0];\n  private _ended = false;\n  private _duration: HrTime = [-1, -1];\n  private readonly _spanProcessor: SpanProcessor;\n  private readonly _spanLimits: SpanLimits;\n  private readonly _attributeValueLengthLimit: number;\n\n  private readonly _performanceStartTime: number;\n  private readonly _performanceOffset: number;\n  private readonly _startTimeProvided: boolean;\n\n  /**\n   * Constructs a new SpanImpl instance.\n   */\n  constructor(opts: SpanOptions) {\n    const now = Date.now();\n\n    this._spanContext = opts.spanContext;\n    this._performanceStartTime = otperformance.now();\n    this._performanceOffset =\n      now - (this._performanceStartTime + getTimeOrigin());\n    this._startTimeProvided = opts.startTime != null;\n    this._spanLimits = opts.spanLimits;\n    this._attributeValueLengthLimit =\n      this._spanLimits.attributeValueLengthLimit || 0;\n    this._spanProcessor = opts.spanProcessor;\n\n    this.name = opts.name;\n    this.parentSpanContext = opts.parentSpanContext;\n    this.kind = opts.kind;\n    this.links = opts.links || [];\n    this.startTime = this._getTime(opts.startTime ?? now);\n    this.resource = opts.resource;\n    this.instrumentationScope = opts.scope;\n\n    if (opts.attributes != null) {\n      this.setAttributes(opts.attributes);\n    }\n\n    this._spanProcessor.onStart(this, opts.context);\n  }\n\n  spanContext(): SpanContext {\n    return this._spanContext;\n  }\n\n  setAttribute(key: string, value?: AttributeValue): this;\n  setAttribute(key: string, value: unknown): this {\n    if (value == null || this._isSpanEnded()) return this;\n    if (key.length === 0) {\n      diag.warn(`Invalid attribute key: ${key}`);\n      return this;\n    }\n    if (!isAttributeValue(value)) {\n      diag.warn(`Invalid attribute value set for key: ${key}`);\n      return this;\n    }\n\n    const { attributeCountLimit } = this._spanLimits;\n\n    if (\n      attributeCountLimit !== undefined &&\n      Object.keys(this.attributes).length >= attributeCountLimit &&\n      !Object.prototype.hasOwnProperty.call(this.attributes, key)\n    ) {\n      this._droppedAttributesCount++;\n      return this;\n    }\n    this.attributes[key] = this._truncateToSize(value);\n    return this;\n  }\n\n  setAttributes(attributes: Attributes): this {\n    for (const [k, v] of Object.entries(attributes)) {\n      this.setAttribute(k, v);\n    }\n    return this;\n  }\n\n  /**\n   *\n   * @param name Span Name\n   * @param [attributesOrStartTime] Span attributes or start time\n   *     if type is {@type TimeInput} and 3rd param is undefined\n   * @param [timeStamp] Specified time stamp for the event\n   */\n  addEvent(\n    name: string,\n    attributesOrStartTime?: Attributes | TimeInput,\n    timeStamp?: TimeInput\n  ): this {\n    if (this._isSpanEnded()) return this;\n\n    const { eventCountLimit } = this._spanLimits;\n\n    if (eventCountLimit === 0) {\n      diag.warn('No events allowed.');\n      this._droppedEventsCount++;\n      return this;\n    }\n\n    if (\n      eventCountLimit !== undefined &&\n      this.events.length >= eventCountLimit\n    ) {\n      if (this._droppedEventsCount === 0) {\n        diag.debug('Dropping extra events.');\n      }\n      this.events.shift();\n      this._droppedEventsCount++;\n    }\n\n    if (isTimeInput(attributesOrStartTime)) {\n      if (!isTimeInput(timeStamp)) {\n        timeStamp = attributesOrStartTime;\n      }\n      attributesOrStartTime = undefined;\n    }\n\n    const attributes = sanitizeAttributes(attributesOrStartTime);\n\n    this.events.push({\n      name,\n      attributes,\n      time: this._getTime(timeStamp),\n      droppedAttributesCount: 0,\n    });\n    return this;\n  }\n\n  addLink(link: Link): this {\n    this.links.push(link);\n    return this;\n  }\n\n  addLinks(links: Link[]): this {\n    this.links.push(...links);\n    return this;\n  }\n\n  setStatus(status: SpanStatus): this {\n    if (this._isSpanEnded()) return this;\n    this.status = { ...status };\n\n    // When using try-catch, the caught \"error\" is of type `any`. When then assigning `any` to `status.message`,\n    // TypeScript will not error. While this can happen during use of any API, it is more common on Span#setStatus()\n    // as it's likely used in a catch-block. Therefore, we validate if `status.message` is actually a string, null, or\n    // undefined to avoid an incorrect type causing issues downstream.\n    if (this.status.message != null && typeof status.message !== 'string') {\n      diag.warn(\n        `Dropping invalid status.message of type '${typeof status.message}', expected 'string'`\n      );\n      delete this.status.message;\n    }\n\n    return this;\n  }\n\n  updateName(name: string): this {\n    if (this._isSpanEnded()) return this;\n    this.name = name;\n    return this;\n  }\n\n  end(endTime?: TimeInput): void {\n    if (this._isSpanEnded()) {\n      diag.error(\n        `${this.name} ${this._spanContext.traceId}-${this._spanContext.spanId} - You can only call end() on a span once.`\n      );\n      return;\n    }\n    this._ended = true;\n\n    this.endTime = this._getTime(endTime);\n    this._duration = hrTimeDuration(this.startTime, this.endTime);\n\n    if (this._duration[0] < 0) {\n      diag.warn(\n        'Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.',\n        this.startTime,\n        this.endTime\n      );\n      this.endTime = this.startTime.slice() as HrTime;\n      this._duration = [0, 0];\n    }\n\n    if (this._droppedEventsCount > 0) {\n      diag.warn(\n        `Dropped ${this._droppedEventsCount} events because eventCountLimit reached`\n      );\n    }\n\n    this._spanProcessor.onEnd(this);\n  }\n\n  private _getTime(inp?: TimeInput): HrTime {\n    if (typeof inp === 'number' && inp <= otperformance.now()) {\n      // must be a performance timestamp\n      // apply correction and convert to hrtime\n      return hrTime(inp + this._performanceOffset);\n    }\n\n    if (typeof inp === 'number') {\n      return millisToHrTime(inp);\n    }\n\n    if (inp instanceof Date) {\n      return millisToHrTime(inp.getTime());\n    }\n\n    if (isTimeInputHrTime(inp)) {\n      return inp;\n    }\n\n    if (this._startTimeProvided) {\n      // if user provided a time for the start manually\n      // we can't use duration to calculate event/end times\n      return millisToHrTime(Date.now());\n    }\n\n    const msDuration = otperformance.now() - this._performanceStartTime;\n    return addHrTimes(this.startTime, millisToHrTime(msDuration));\n  }\n\n  isRecording(): boolean {\n    return this._ended === false;\n  }\n\n  recordException(exception: Exception, time?: TimeInput): void {\n    const attributes: Attributes = {};\n    if (typeof exception === 'string') {\n      attributes[ATTR_EXCEPTION_MESSAGE] = exception;\n    } else if (exception) {\n      if (exception.code) {\n        attributes[ATTR_EXCEPTION_TYPE] = exception.code.toString();\n      } else if (exception.name) {\n        attributes[ATTR_EXCEPTION_TYPE] = exception.name;\n      }\n      if (exception.message) {\n        attributes[ATTR_EXCEPTION_MESSAGE] = exception.message;\n      }\n      if (exception.stack) {\n        attributes[ATTR_EXCEPTION_STACKTRACE] = exception.stack;\n      }\n    }\n\n    // these are minimum requirements from spec\n    if (attributes[ATTR_EXCEPTION_TYPE] || attributes[ATTR_EXCEPTION_MESSAGE]) {\n      this.addEvent(ExceptionEventName, attributes, time);\n    } else {\n      diag.warn(`Failed to record an exception ${exception}`);\n    }\n  }\n\n  get duration(): HrTime {\n    return this._duration;\n  }\n\n  get ended(): boolean {\n    return this._ended;\n  }\n\n  get droppedAttributesCount(): number {\n    return this._droppedAttributesCount;\n  }\n\n  get droppedEventsCount(): number {\n    return this._droppedEventsCount;\n  }\n\n  get droppedLinksCount(): number {\n    return this._droppedLinksCount;\n  }\n\n  private _isSpanEnded(): boolean {\n    if (this._ended) {\n      const error = new Error(\n        `Operation attempted on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`\n      );\n\n      diag.warn(\n        `Cannot execute the operation on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`,\n        error\n      );\n    }\n    return this._ended;\n  }\n\n  // Utility function to truncate given value within size\n  // for value type of string, will truncate to given limit\n  // for type of non-string, will return same value\n  private _truncateToLimitUtil(value: string, limit: number): string {\n    if (value.length <= limit) {\n      return value;\n    }\n    return value.substring(0, limit);\n  }\n\n  /**\n   * If the given attribute value is of type string and has more characters than given {@code attributeValueLengthLimit} then\n   * return string with truncated to {@code attributeValueLengthLimit} characters\n   *\n   * If the given attribute value is array of strings then\n   * return new array of strings with each element truncated to {@code attributeValueLengthLimit} characters\n   *\n   * Otherwise return same Attribute {@code value}\n   *\n   * @param value Attribute value\n   * @returns truncated attribute value if required, otherwise same value\n   */\n  private _truncateToSize(value: AttributeValue): AttributeValue {\n    const limit = this._attributeValueLengthLimit;\n    // Check limit\n    if (limit <= 0) {\n      // Negative values are invalid, so do not truncate\n      diag.warn(`Attribute value limit must be positive, got ${limit}`);\n      return value;\n    }\n\n    // String\n    if (typeof value === 'string') {\n      return this._truncateToLimitUtil(value, limit);\n    }\n\n    // Array of strings\n    if (Array.isArray(value)) {\n      return (value as []).map(val =>\n        typeof val === 'string' ? this._truncateToLimitUtil(val, limit) : val\n      );\n    }\n\n    // Other types, no need to apply value length limit\n    return value;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
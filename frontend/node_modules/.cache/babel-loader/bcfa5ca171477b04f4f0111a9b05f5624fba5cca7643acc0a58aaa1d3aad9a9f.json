{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { createInstrumentDescriptorWithView } from '../InstrumentDescriptor';\nimport { Meter } from '../Meter';\nimport { isNotNullish } from '../utils';\nimport { AsyncMetricStorage } from './AsyncMetricStorage';\nimport { MetricStorageRegistry } from './MetricStorageRegistry';\nimport { MultiMetricStorage } from './MultiWritableMetricStorage';\nimport { ObservableRegistry } from './ObservableRegistry';\nimport { SyncMetricStorage } from './SyncMetricStorage';\nimport { createNoopAttributesProcessor } from '../view/AttributesProcessor';\n/**\n * An internal record for shared meter provider states.\n */\nexport class MeterSharedState {\n  _meterProviderSharedState;\n  _instrumentationScope;\n  metricStorageRegistry = new MetricStorageRegistry();\n  observableRegistry = new ObservableRegistry();\n  meter;\n  constructor(_meterProviderSharedState, _instrumentationScope) {\n    this._meterProviderSharedState = _meterProviderSharedState;\n    this._instrumentationScope = _instrumentationScope;\n    this.meter = new Meter(this);\n  }\n  registerMetricStorage(descriptor) {\n    const storages = this._registerMetricStorage(descriptor, SyncMetricStorage);\n    if (storages.length === 1) {\n      return storages[0];\n    }\n    return new MultiMetricStorage(storages);\n  }\n  registerAsyncMetricStorage(descriptor) {\n    const storages = this._registerMetricStorage(descriptor, AsyncMetricStorage);\n    return storages;\n  }\n  /**\n   * @param collector opaque handle of {@link MetricCollector} which initiated the collection.\n   * @param collectionTime the HrTime at which the collection was initiated.\n   * @param options options for collection.\n   * @returns the list of metric data collected.\n   */\n  async collect(collector, collectionTime, options) {\n    /**\n     * 1. Call all observable callbacks first.\n     * 2. Collect metric result for the collector.\n     */\n    const errors = await this.observableRegistry.observe(collectionTime, options?.timeoutMillis);\n    const storages = this.metricStorageRegistry.getStorages(collector);\n    // prevent more allocations if there are no storages.\n    if (storages.length === 0) {\n      return null;\n    }\n    const metricDataList = storages.map(metricStorage => {\n      return metricStorage.collect(collector, collectionTime);\n    }).filter(isNotNullish);\n    // skip this scope if no data was collected (storage created, but no data observed)\n    if (metricDataList.length === 0) {\n      return {\n        errors\n      };\n    }\n    return {\n      scopeMetrics: {\n        scope: this._instrumentationScope,\n        metrics: metricDataList\n      },\n      errors\n    };\n  }\n  _registerMetricStorage(descriptor, MetricStorageType) {\n    const views = this._meterProviderSharedState.viewRegistry.findViews(descriptor, this._instrumentationScope);\n    let storages = views.map(view => {\n      const viewDescriptor = createInstrumentDescriptorWithView(view, descriptor);\n      const compatibleStorage = this.metricStorageRegistry.findOrUpdateCompatibleStorage(viewDescriptor);\n      if (compatibleStorage != null) {\n        return compatibleStorage;\n      }\n      const aggregator = view.aggregation.createAggregator(viewDescriptor);\n      const viewStorage = new MetricStorageType(viewDescriptor, aggregator, view.attributesProcessor, this._meterProviderSharedState.metricCollectors, view.aggregationCardinalityLimit);\n      this.metricStorageRegistry.register(viewStorage);\n      return viewStorage;\n    });\n    // Fallback to the per-collector aggregations if no view is configured for the instrument.\n    if (storages.length === 0) {\n      const perCollectorAggregations = this._meterProviderSharedState.selectAggregations(descriptor.type);\n      const collectorStorages = perCollectorAggregations.map(([collector, aggregation]) => {\n        const compatibleStorage = this.metricStorageRegistry.findOrUpdateCompatibleCollectorStorage(collector, descriptor);\n        if (compatibleStorage != null) {\n          return compatibleStorage;\n        }\n        const aggregator = aggregation.createAggregator(descriptor);\n        const cardinalityLimit = collector.selectCardinalityLimit(descriptor.type);\n        const storage = new MetricStorageType(descriptor, aggregator, createNoopAttributesProcessor(), [collector], cardinalityLimit);\n        this.metricStorageRegistry.registerForCollector(collector, storage);\n        return storage;\n      });\n      storages = storages.concat(collectorStorages);\n    }\n    return storages;\n  }\n}","map":{"version":3,"names":["createInstrumentDescriptorWithView","Meter","isNotNullish","AsyncMetricStorage","MetricStorageRegistry","MultiMetricStorage","ObservableRegistry","SyncMetricStorage","createNoopAttributesProcessor","MeterSharedState","_meterProviderSharedState","_instrumentationScope","metricStorageRegistry","observableRegistry","meter","constructor","registerMetricStorage","descriptor","storages","_registerMetricStorage","length","registerAsyncMetricStorage","collect","collector","collectionTime","options","errors","observe","timeoutMillis","getStorages","metricDataList","map","metricStorage","filter","scopeMetrics","scope","metrics","MetricStorageType","views","viewRegistry","findViews","view","viewDescriptor","compatibleStorage","findOrUpdateCompatibleStorage","aggregator","aggregation","createAggregator","viewStorage","attributesProcessor","metricCollectors","aggregationCardinalityLimit","register","perCollectorAggregations","selectAggregations","type","collectorStorages","findOrUpdateCompatibleCollectorStorage","cardinalityLimit","selectCardinalityLimit","storage","registerForCollector","concat"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/sdk-metrics/src/state/MeterSharedState.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HrTime } from '@opentelemetry/api';\nimport { InstrumentationScope } from '@opentelemetry/core';\nimport { MetricCollectOptions } from '../export/MetricProducer';\nimport { ScopeMetrics } from '../export/MetricData';\nimport {\n  createInstrumentDescriptorWithView,\n  InstrumentDescriptor,\n} from '../InstrumentDescriptor';\nimport { Meter } from '../Meter';\nimport { isNotNullish, Maybe } from '../utils';\nimport { AsyncMetricStorage } from './AsyncMetricStorage';\nimport { MeterProviderSharedState } from './MeterProviderSharedState';\nimport { MetricCollectorHandle } from './MetricCollector';\nimport { MetricStorageRegistry } from './MetricStorageRegistry';\nimport { MultiMetricStorage } from './MultiWritableMetricStorage';\nimport { ObservableRegistry } from './ObservableRegistry';\nimport { SyncMetricStorage } from './SyncMetricStorage';\nimport { Accumulation, Aggregator } from '../aggregator/types';\nimport {\n  createNoopAttributesProcessor,\n  IAttributesProcessor,\n} from '../view/AttributesProcessor';\nimport { MetricStorage } from './MetricStorage';\n\n/**\n * An internal record for shared meter provider states.\n */\nexport class MeterSharedState {\n  metricStorageRegistry = new MetricStorageRegistry();\n  observableRegistry = new ObservableRegistry();\n  meter: Meter;\n\n  constructor(\n    private _meterProviderSharedState: MeterProviderSharedState,\n    private _instrumentationScope: InstrumentationScope\n  ) {\n    this.meter = new Meter(this);\n  }\n\n  registerMetricStorage(descriptor: InstrumentDescriptor) {\n    const storages = this._registerMetricStorage(descriptor, SyncMetricStorage);\n\n    if (storages.length === 1) {\n      return storages[0];\n    }\n    return new MultiMetricStorage(storages);\n  }\n\n  registerAsyncMetricStorage(descriptor: InstrumentDescriptor) {\n    const storages = this._registerMetricStorage(\n      descriptor,\n      AsyncMetricStorage\n    );\n\n    return storages;\n  }\n\n  /**\n   * @param collector opaque handle of {@link MetricCollector} which initiated the collection.\n   * @param collectionTime the HrTime at which the collection was initiated.\n   * @param options options for collection.\n   * @returns the list of metric data collected.\n   */\n  async collect(\n    collector: MetricCollectorHandle,\n    collectionTime: HrTime,\n    options?: MetricCollectOptions\n  ): Promise<ScopeMetricsResult | null> {\n    /**\n     * 1. Call all observable callbacks first.\n     * 2. Collect metric result for the collector.\n     */\n    const errors = await this.observableRegistry.observe(\n      collectionTime,\n      options?.timeoutMillis\n    );\n    const storages = this.metricStorageRegistry.getStorages(collector);\n\n    // prevent more allocations if there are no storages.\n    if (storages.length === 0) {\n      return null;\n    }\n\n    const metricDataList = storages\n      .map(metricStorage => {\n        return metricStorage.collect(collector, collectionTime);\n      })\n      .filter(isNotNullish);\n\n    // skip this scope if no data was collected (storage created, but no data observed)\n    if (metricDataList.length === 0) {\n      return { errors };\n    }\n\n    return {\n      scopeMetrics: {\n        scope: this._instrumentationScope,\n        metrics: metricDataList,\n      },\n      errors,\n    };\n  }\n\n  private _registerMetricStorage<\n    MetricStorageType extends MetricStorageConstructor,\n    R extends InstanceType<MetricStorageType>,\n  >(\n    descriptor: InstrumentDescriptor,\n    MetricStorageType: MetricStorageType\n  ): R[] {\n    const views = this._meterProviderSharedState.viewRegistry.findViews(\n      descriptor,\n      this._instrumentationScope\n    );\n    let storages = views.map(view => {\n      const viewDescriptor = createInstrumentDescriptorWithView(\n        view,\n        descriptor\n      );\n      const compatibleStorage =\n        this.metricStorageRegistry.findOrUpdateCompatibleStorage<R>(\n          viewDescriptor\n        );\n      if (compatibleStorage != null) {\n        return compatibleStorage;\n      }\n      const aggregator = view.aggregation.createAggregator(viewDescriptor);\n      const viewStorage = new MetricStorageType(\n        viewDescriptor,\n        aggregator,\n        view.attributesProcessor,\n        this._meterProviderSharedState.metricCollectors,\n        view.aggregationCardinalityLimit\n      ) as R;\n      this.metricStorageRegistry.register(viewStorage);\n      return viewStorage;\n    });\n\n    // Fallback to the per-collector aggregations if no view is configured for the instrument.\n    if (storages.length === 0) {\n      const perCollectorAggregations =\n        this._meterProviderSharedState.selectAggregations(descriptor.type);\n      const collectorStorages = perCollectorAggregations.map(\n        ([collector, aggregation]) => {\n          const compatibleStorage =\n            this.metricStorageRegistry.findOrUpdateCompatibleCollectorStorage<R>(\n              collector,\n              descriptor\n            );\n          if (compatibleStorage != null) {\n            return compatibleStorage;\n          }\n\n          const aggregator = aggregation.createAggregator(descriptor);\n          const cardinalityLimit = collector.selectCardinalityLimit(\n            descriptor.type\n          );\n          const storage = new MetricStorageType(\n            descriptor,\n            aggregator,\n            createNoopAttributesProcessor(),\n            [collector],\n            cardinalityLimit\n          ) as R;\n          this.metricStorageRegistry.registerForCollector(collector, storage);\n          return storage;\n        }\n      );\n      storages = storages.concat(collectorStorages);\n    }\n\n    return storages;\n  }\n}\n\ninterface ScopeMetricsResult {\n  scopeMetrics?: ScopeMetrics;\n  errors: unknown[];\n}\n\ninterface MetricStorageConstructor {\n  new (\n    instrumentDescriptor: InstrumentDescriptor,\n    aggregator: Aggregator<Maybe<Accumulation>>,\n    attributesProcessor: IAttributesProcessor,\n    collectors: MetricCollectorHandle[],\n    aggregationCardinalityLimit?: number\n  ): MetricStorage;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { isSpanContextValid, TraceFlags, trace } from '@opentelemetry/api';\nimport { globalErrorHandler } from '@opentelemetry/core';\nimport { AlwaysOffSampler } from './AlwaysOffSampler';\nimport { AlwaysOnSampler } from './AlwaysOnSampler';\n/**\n * A composite sampler that either respects the parent span's sampling decision\n * or delegates to `delegateSampler` for root spans.\n */\nexport class ParentBasedSampler {\n  _root;\n  _remoteParentSampled;\n  _remoteParentNotSampled;\n  _localParentSampled;\n  _localParentNotSampled;\n  constructor(config) {\n    this._root = config.root;\n    if (!this._root) {\n      globalErrorHandler(new Error('ParentBasedSampler must have a root sampler configured'));\n      this._root = new AlwaysOnSampler();\n    }\n    this._remoteParentSampled = config.remoteParentSampled ?? new AlwaysOnSampler();\n    this._remoteParentNotSampled = config.remoteParentNotSampled ?? new AlwaysOffSampler();\n    this._localParentSampled = config.localParentSampled ?? new AlwaysOnSampler();\n    this._localParentNotSampled = config.localParentNotSampled ?? new AlwaysOffSampler();\n  }\n  shouldSample(context, traceId, spanName, spanKind, attributes, links) {\n    const parentContext = trace.getSpanContext(context);\n    if (!parentContext || !isSpanContextValid(parentContext)) {\n      return this._root.shouldSample(context, traceId, spanName, spanKind, attributes, links);\n    }\n    if (parentContext.isRemote) {\n      if (parentContext.traceFlags & TraceFlags.SAMPLED) {\n        return this._remoteParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);\n      }\n      return this._remoteParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);\n    }\n    if (parentContext.traceFlags & TraceFlags.SAMPLED) {\n      return this._localParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);\n    }\n    return this._localParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);\n  }\n  toString() {\n    return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;\n  }\n}","map":{"version":3,"names":["isSpanContextValid","TraceFlags","trace","globalErrorHandler","AlwaysOffSampler","AlwaysOnSampler","ParentBasedSampler","_root","_remoteParentSampled","_remoteParentNotSampled","_localParentSampled","_localParentNotSampled","constructor","config","root","Error","remoteParentSampled","remoteParentNotSampled","localParentSampled","localParentNotSampled","shouldSample","context","traceId","spanName","spanKind","attributes","links","parentContext","getSpanContext","isRemote","traceFlags","SAMPLED","toString"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/sdk-trace-base/src/sampler/ParentBasedSampler.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Context,\n  isSpanContextValid,\n  Link,\n  Attributes,\n  SpanKind,\n  TraceFlags,\n  trace,\n} from '@opentelemetry/api';\nimport { globalErrorHandler } from '@opentelemetry/core';\nimport { AlwaysOffSampler } from './AlwaysOffSampler';\nimport { AlwaysOnSampler } from './AlwaysOnSampler';\nimport { Sampler, SamplingResult } from '../Sampler';\n\n/**\n * A composite sampler that either respects the parent span's sampling decision\n * or delegates to `delegateSampler` for root spans.\n */\nexport class ParentBasedSampler implements Sampler {\n  private _root: Sampler;\n  private _remoteParentSampled: Sampler;\n  private _remoteParentNotSampled: Sampler;\n  private _localParentSampled: Sampler;\n  private _localParentNotSampled: Sampler;\n\n  constructor(config: ParentBasedSamplerConfig) {\n    this._root = config.root;\n\n    if (!this._root) {\n      globalErrorHandler(\n        new Error('ParentBasedSampler must have a root sampler configured')\n      );\n      this._root = new AlwaysOnSampler();\n    }\n\n    this._remoteParentSampled =\n      config.remoteParentSampled ?? new AlwaysOnSampler();\n    this._remoteParentNotSampled =\n      config.remoteParentNotSampled ?? new AlwaysOffSampler();\n    this._localParentSampled =\n      config.localParentSampled ?? new AlwaysOnSampler();\n    this._localParentNotSampled =\n      config.localParentNotSampled ?? new AlwaysOffSampler();\n  }\n\n  shouldSample(\n    context: Context,\n    traceId: string,\n    spanName: string,\n    spanKind: SpanKind,\n    attributes: Attributes,\n    links: Link[]\n  ): SamplingResult {\n    const parentContext = trace.getSpanContext(context);\n\n    if (!parentContext || !isSpanContextValid(parentContext)) {\n      return this._root.shouldSample(\n        context,\n        traceId,\n        spanName,\n        spanKind,\n        attributes,\n        links\n      );\n    }\n\n    if (parentContext.isRemote) {\n      if (parentContext.traceFlags & TraceFlags.SAMPLED) {\n        return this._remoteParentSampled.shouldSample(\n          context,\n          traceId,\n          spanName,\n          spanKind,\n          attributes,\n          links\n        );\n      }\n      return this._remoteParentNotSampled.shouldSample(\n        context,\n        traceId,\n        spanName,\n        spanKind,\n        attributes,\n        links\n      );\n    }\n\n    if (parentContext.traceFlags & TraceFlags.SAMPLED) {\n      return this._localParentSampled.shouldSample(\n        context,\n        traceId,\n        spanName,\n        spanKind,\n        attributes,\n        links\n      );\n    }\n\n    return this._localParentNotSampled.shouldSample(\n      context,\n      traceId,\n      spanName,\n      spanKind,\n      attributes,\n      links\n    );\n  }\n\n  toString(): string {\n    return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;\n  }\n}\n\ninterface ParentBasedSamplerConfig {\n  /** Sampler called for spans with no parent */\n  root: Sampler;\n  /** Sampler called for spans with a remote parent which was sampled. Default AlwaysOn */\n  remoteParentSampled?: Sampler;\n  /** Sampler called for spans with a remote parent which was not sampled. Default AlwaysOff */\n  remoteParentNotSampled?: Sampler;\n  /** Sampler called for spans with a local parent which was sampled. Default AlwaysOn */\n  localParentSampled?: Sampler;\n  /** Sampler called for spans with a local parent which was not sampled. Default AlwaysOff */\n  localParentNotSampled?: Sampler;\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAgBA,SAEEA,kBAAkB,EAIlBC,UAAU,EACVC,KAAK,QACA,oBAAoB;AAC3B,SAASC,kBAAkB,QAAQ,qBAAqB;AACxD,SAASC,gBAAgB,QAAQ,oBAAoB;AACrD,SAASC,eAAe,QAAQ,mBAAmB;AAGnD;;;;AAIA,OAAM,MAAOC,kBAAkB;EACrBC,KAAK;EACLC,oBAAoB;EACpBC,uBAAuB;EACvBC,mBAAmB;EACnBC,sBAAsB;EAE9BC,YAAYC,MAAgC;IAC1C,IAAI,CAACN,KAAK,GAAGM,MAAM,CAACC,IAAI;IAExB,IAAI,CAAC,IAAI,CAACP,KAAK,EAAE;MACfJ,kBAAkB,CAChB,IAAIY,KAAK,CAAC,wDAAwD,CAAC,CACpE;MACD,IAAI,CAACR,KAAK,GAAG,IAAIF,eAAe,EAAE;;IAGpC,IAAI,CAACG,oBAAoB,GACvBK,MAAM,CAACG,mBAAmB,IAAI,IAAIX,eAAe,EAAE;IACrD,IAAI,CAACI,uBAAuB,GAC1BI,MAAM,CAACI,sBAAsB,IAAI,IAAIb,gBAAgB,EAAE;IACzD,IAAI,CAACM,mBAAmB,GACtBG,MAAM,CAACK,kBAAkB,IAAI,IAAIb,eAAe,EAAE;IACpD,IAAI,CAACM,sBAAsB,GACzBE,MAAM,CAACM,qBAAqB,IAAI,IAAIf,gBAAgB,EAAE;EAC1D;EAEAgB,YAAYA,CACVC,OAAgB,EAChBC,OAAe,EACfC,QAAgB,EAChBC,QAAkB,EAClBC,UAAsB,EACtBC,KAAa;IAEb,MAAMC,aAAa,GAAGzB,KAAK,CAAC0B,cAAc,CAACP,OAAO,CAAC;IAEnD,IAAI,CAACM,aAAa,IAAI,CAAC3B,kBAAkB,CAAC2B,aAAa,CAAC,EAAE;MACxD,OAAO,IAAI,CAACpB,KAAK,CAACa,YAAY,CAC5BC,OAAO,EACPC,OAAO,EACPC,QAAQ,EACRC,QAAQ,EACRC,UAAU,EACVC,KAAK,CACN;;IAGH,IAAIC,aAAa,CAACE,QAAQ,EAAE;MAC1B,IAAIF,aAAa,CAACG,UAAU,GAAG7B,UAAU,CAAC8B,OAAO,EAAE;QACjD,OAAO,IAAI,CAACvB,oBAAoB,CAACY,YAAY,CAC3CC,OAAO,EACPC,OAAO,EACPC,QAAQ,EACRC,QAAQ,EACRC,UAAU,EACVC,KAAK,CACN;;MAEH,OAAO,IAAI,CAACjB,uBAAuB,CAACW,YAAY,CAC9CC,OAAO,EACPC,OAAO,EACPC,QAAQ,EACRC,QAAQ,EACRC,UAAU,EACVC,KAAK,CACN;;IAGH,IAAIC,aAAa,CAACG,UAAU,GAAG7B,UAAU,CAAC8B,OAAO,EAAE;MACjD,OAAO,IAAI,CAACrB,mBAAmB,CAACU,YAAY,CAC1CC,OAAO,EACPC,OAAO,EACPC,QAAQ,EACRC,QAAQ,EACRC,UAAU,EACVC,KAAK,CACN;;IAGH,OAAO,IAAI,CAACf,sBAAsB,CAACS,YAAY,CAC7CC,OAAO,EACPC,OAAO,EACPC,QAAQ,EACRC,QAAQ,EACRC,UAAU,EACVC,KAAK,CACN;EACH;EAEAM,QAAQA,CAAA;IACN,OAAO,oBAAoB,IAAI,CAACzB,KAAK,CAACyB,QAAQ,EAAE,yBAAyB,IAAI,CAACxB,oBAAoB,CAACwB,QAAQ,EAAE,4BAA4B,IAAI,CAACvB,uBAAuB,CAACuB,QAAQ,EAAE,wBAAwB,IAAI,CAACtB,mBAAmB,CAACsB,QAAQ,EAAE,2BAA2B,IAAI,CAACrB,sBAAsB,CAACqB,QAAQ,EAAE,GAAG;EACjT","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { diag } from '@opentelemetry/api';\nimport { isObservableInstrument } from '../Instruments';\nimport { BatchObservableResultImpl, ObservableResultImpl } from '../ObservableResult';\nimport { callWithTimeout, PromiseAllSettled, isPromiseAllSettledRejectionResult, setEquals } from '../utils';\n/**\n * An internal interface for managing ObservableCallbacks.\n *\n * Every registered callback associated with a set of instruments are be evaluated\n * exactly once during collection prior to reading data for that instrument.\n */\nexport class ObservableRegistry {\n  _callbacks = [];\n  _batchCallbacks = [];\n  addCallback(callback, instrument) {\n    const idx = this._findCallback(callback, instrument);\n    if (idx >= 0) {\n      return;\n    }\n    this._callbacks.push({\n      callback,\n      instrument\n    });\n  }\n  removeCallback(callback, instrument) {\n    const idx = this._findCallback(callback, instrument);\n    if (idx < 0) {\n      return;\n    }\n    this._callbacks.splice(idx, 1);\n  }\n  addBatchCallback(callback, instruments) {\n    // Create a set of unique instruments.\n    const observableInstruments = new Set(instruments.filter(isObservableInstrument));\n    if (observableInstruments.size === 0) {\n      diag.error('BatchObservableCallback is not associated with valid instruments', instruments);\n      return;\n    }\n    const idx = this._findBatchCallback(callback, observableInstruments);\n    if (idx >= 0) {\n      return;\n    }\n    this._batchCallbacks.push({\n      callback,\n      instruments: observableInstruments\n    });\n  }\n  removeBatchCallback(callback, instruments) {\n    // Create a set of unique instruments.\n    const observableInstruments = new Set(instruments.filter(isObservableInstrument));\n    const idx = this._findBatchCallback(callback, observableInstruments);\n    if (idx < 0) {\n      return;\n    }\n    this._batchCallbacks.splice(idx, 1);\n  }\n  /**\n   * @returns a promise of rejected reasons for invoking callbacks.\n   */\n  async observe(collectionTime, timeoutMillis) {\n    const callbackFutures = this._observeCallbacks(collectionTime, timeoutMillis);\n    const batchCallbackFutures = this._observeBatchCallbacks(collectionTime, timeoutMillis);\n    const results = await PromiseAllSettled([...callbackFutures, ...batchCallbackFutures]);\n    const rejections = results.filter(isPromiseAllSettledRejectionResult).map(it => it.reason);\n    return rejections;\n  }\n  _observeCallbacks(observationTime, timeoutMillis) {\n    return this._callbacks.map(async ({\n      callback,\n      instrument\n    }) => {\n      const observableResult = new ObservableResultImpl(instrument._descriptor.name, instrument._descriptor.valueType);\n      let callPromise = Promise.resolve(callback(observableResult));\n      if (timeoutMillis != null) {\n        callPromise = callWithTimeout(callPromise, timeoutMillis);\n      }\n      await callPromise;\n      instrument._metricStorages.forEach(metricStorage => {\n        metricStorage.record(observableResult._buffer, observationTime);\n      });\n    });\n  }\n  _observeBatchCallbacks(observationTime, timeoutMillis) {\n    return this._batchCallbacks.map(async ({\n      callback,\n      instruments\n    }) => {\n      const observableResult = new BatchObservableResultImpl();\n      let callPromise = Promise.resolve(callback(observableResult));\n      if (timeoutMillis != null) {\n        callPromise = callWithTimeout(callPromise, timeoutMillis);\n      }\n      await callPromise;\n      instruments.forEach(instrument => {\n        const buffer = observableResult._buffer.get(instrument);\n        if (buffer == null) {\n          return;\n        }\n        instrument._metricStorages.forEach(metricStorage => {\n          metricStorage.record(buffer, observationTime);\n        });\n      });\n    });\n  }\n  _findCallback(callback, instrument) {\n    return this._callbacks.findIndex(record => {\n      return record.callback === callback && record.instrument === instrument;\n    });\n  }\n  _findBatchCallback(callback, instruments) {\n    return this._batchCallbacks.findIndex(record => {\n      return record.callback === callback && setEquals(record.instruments, instruments);\n    });\n  }\n}","map":{"version":3,"names":["diag","isObservableInstrument","BatchObservableResultImpl","ObservableResultImpl","callWithTimeout","PromiseAllSettled","isPromiseAllSettledRejectionResult","setEquals","ObservableRegistry","_callbacks","_batchCallbacks","addCallback","callback","instrument","idx","_findCallback","push","removeCallback","splice","addBatchCallback","instruments","observableInstruments","Set","filter","size","error","_findBatchCallback","removeBatchCallback","observe","collectionTime","timeoutMillis","callbackFutures","_observeCallbacks","batchCallbackFutures","_observeBatchCallbacks","results","rejections","map","it","reason","observationTime","observableResult","_descriptor","name","valueType","callPromise","Promise","resolve","_metricStorages","forEach","metricStorage","record","_buffer","buffer","get","findIndex"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/sdk-metrics/src/state/ObservableRegistry.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  diag,\n  HrTime,\n  BatchObservableCallback,\n  Observable,\n  ObservableCallback,\n} from '@opentelemetry/api';\nimport { isObservableInstrument, ObservableInstrument } from '../Instruments';\nimport {\n  BatchObservableResultImpl,\n  ObservableResultImpl,\n} from '../ObservableResult';\nimport {\n  callWithTimeout,\n  PromiseAllSettled,\n  isPromiseAllSettledRejectionResult,\n  setEquals,\n} from '../utils';\n\n/**\n * Records for single instrument observable callback.\n */\ninterface ObservableCallbackRecord {\n  callback: ObservableCallback;\n  instrument: ObservableInstrument;\n}\n\n/**\n * Records for multiple instruments observable callback.\n */\ninterface BatchObservableCallbackRecord {\n  callback: BatchObservableCallback;\n  instruments: Set<ObservableInstrument>;\n}\n\n/**\n * An internal interface for managing ObservableCallbacks.\n *\n * Every registered callback associated with a set of instruments are be evaluated\n * exactly once during collection prior to reading data for that instrument.\n */\nexport class ObservableRegistry {\n  private _callbacks: ObservableCallbackRecord[] = [];\n  private _batchCallbacks: BatchObservableCallbackRecord[] = [];\n\n  addCallback(callback: ObservableCallback, instrument: ObservableInstrument) {\n    const idx = this._findCallback(callback, instrument);\n    if (idx >= 0) {\n      return;\n    }\n    this._callbacks.push({ callback, instrument });\n  }\n\n  removeCallback(\n    callback: ObservableCallback,\n    instrument: ObservableInstrument\n  ) {\n    const idx = this._findCallback(callback, instrument);\n    if (idx < 0) {\n      return;\n    }\n    this._callbacks.splice(idx, 1);\n  }\n\n  addBatchCallback(\n    callback: BatchObservableCallback,\n    instruments: Observable[]\n  ) {\n    // Create a set of unique instruments.\n    const observableInstruments = new Set(\n      instruments.filter(isObservableInstrument)\n    );\n    if (observableInstruments.size === 0) {\n      diag.error(\n        'BatchObservableCallback is not associated with valid instruments',\n        instruments\n      );\n      return;\n    }\n    const idx = this._findBatchCallback(callback, observableInstruments);\n    if (idx >= 0) {\n      return;\n    }\n    this._batchCallbacks.push({ callback, instruments: observableInstruments });\n  }\n\n  removeBatchCallback(\n    callback: BatchObservableCallback,\n    instruments: Observable[]\n  ) {\n    // Create a set of unique instruments.\n    const observableInstruments = new Set(\n      instruments.filter(isObservableInstrument)\n    );\n    const idx = this._findBatchCallback(callback, observableInstruments);\n    if (idx < 0) {\n      return;\n    }\n    this._batchCallbacks.splice(idx, 1);\n  }\n\n  /**\n   * @returns a promise of rejected reasons for invoking callbacks.\n   */\n  async observe(\n    collectionTime: HrTime,\n    timeoutMillis?: number\n  ): Promise<unknown[]> {\n    const callbackFutures = this._observeCallbacks(\n      collectionTime,\n      timeoutMillis\n    );\n    const batchCallbackFutures = this._observeBatchCallbacks(\n      collectionTime,\n      timeoutMillis\n    );\n\n    const results = await PromiseAllSettled([\n      ...callbackFutures,\n      ...batchCallbackFutures,\n    ]);\n\n    const rejections = results\n      .filter(isPromiseAllSettledRejectionResult)\n      .map(it => it.reason);\n    return rejections;\n  }\n\n  private _observeCallbacks(observationTime: HrTime, timeoutMillis?: number) {\n    return this._callbacks.map(async ({ callback, instrument }) => {\n      const observableResult = new ObservableResultImpl(\n        instrument._descriptor.name,\n        instrument._descriptor.valueType\n      );\n      let callPromise: Promise<void> = Promise.resolve(\n        callback(observableResult)\n      );\n      if (timeoutMillis != null) {\n        callPromise = callWithTimeout(callPromise, timeoutMillis);\n      }\n      await callPromise;\n      instrument._metricStorages.forEach(metricStorage => {\n        metricStorage.record(observableResult._buffer, observationTime);\n      });\n    });\n  }\n\n  private _observeBatchCallbacks(\n    observationTime: HrTime,\n    timeoutMillis?: number\n  ) {\n    return this._batchCallbacks.map(async ({ callback, instruments }) => {\n      const observableResult = new BatchObservableResultImpl();\n      let callPromise: Promise<void> = Promise.resolve(\n        callback(observableResult)\n      );\n      if (timeoutMillis != null) {\n        callPromise = callWithTimeout(callPromise, timeoutMillis);\n      }\n      await callPromise;\n      instruments.forEach(instrument => {\n        const buffer = observableResult._buffer.get(instrument);\n        if (buffer == null) {\n          return;\n        }\n        instrument._metricStorages.forEach(metricStorage => {\n          metricStorage.record(buffer, observationTime);\n        });\n      });\n    });\n  }\n\n  private _findCallback(\n    callback: ObservableCallback,\n    instrument: ObservableInstrument\n  ) {\n    return this._callbacks.findIndex(record => {\n      return record.callback === callback && record.instrument === instrument;\n    });\n  }\n\n  private _findBatchCallback(\n    callback: BatchObservableCallback,\n    instruments: Set<ObservableInstrument>\n  ) {\n    return this._batchCallbacks.findIndex(record => {\n      return (\n        record.callback === callback &&\n        setEquals(record.instruments, instruments)\n      );\n    });\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAgBA,SACEA,IAAI,QAKC,oBAAoB;AAC3B,SAASC,sBAAsB,QAA8B,gBAAgB;AAC7E,SACEC,yBAAyB,EACzBC,oBAAoB,QACf,qBAAqB;AAC5B,SACEC,eAAe,EACfC,iBAAiB,EACjBC,kCAAkC,EAClCC,SAAS,QACJ,UAAU;AAkBjB;;;;;;AAMA,OAAM,MAAOC,kBAAkB;EACrBC,UAAU,GAA+B,EAAE;EAC3CC,eAAe,GAAoC,EAAE;EAE7DC,WAAWA,CAACC,QAA4B,EAAEC,UAAgC;IACxE,MAAMC,GAAG,GAAG,IAAI,CAACC,aAAa,CAACH,QAAQ,EAAEC,UAAU,CAAC;IACpD,IAAIC,GAAG,IAAI,CAAC,EAAE;MACZ;;IAEF,IAAI,CAACL,UAAU,CAACO,IAAI,CAAC;MAAEJ,QAAQ;MAAEC;IAAU,CAAE,CAAC;EAChD;EAEAI,cAAcA,CACZL,QAA4B,EAC5BC,UAAgC;IAEhC,MAAMC,GAAG,GAAG,IAAI,CAACC,aAAa,CAACH,QAAQ,EAAEC,UAAU,CAAC;IACpD,IAAIC,GAAG,GAAG,CAAC,EAAE;MACX;;IAEF,IAAI,CAACL,UAAU,CAACS,MAAM,CAACJ,GAAG,EAAE,CAAC,CAAC;EAChC;EAEAK,gBAAgBA,CACdP,QAAiC,EACjCQ,WAAyB;IAEzB;IACA,MAAMC,qBAAqB,GAAG,IAAIC,GAAG,CACnCF,WAAW,CAACG,MAAM,CAACtB,sBAAsB,CAAC,CAC3C;IACD,IAAIoB,qBAAqB,CAACG,IAAI,KAAK,CAAC,EAAE;MACpCxB,IAAI,CAACyB,KAAK,CACR,kEAAkE,EAClEL,WAAW,CACZ;MACD;;IAEF,MAAMN,GAAG,GAAG,IAAI,CAACY,kBAAkB,CAACd,QAAQ,EAAES,qBAAqB,CAAC;IACpE,IAAIP,GAAG,IAAI,CAAC,EAAE;MACZ;;IAEF,IAAI,CAACJ,eAAe,CAACM,IAAI,CAAC;MAAEJ,QAAQ;MAAEQ,WAAW,EAAEC;IAAqB,CAAE,CAAC;EAC7E;EAEAM,mBAAmBA,CACjBf,QAAiC,EACjCQ,WAAyB;IAEzB;IACA,MAAMC,qBAAqB,GAAG,IAAIC,GAAG,CACnCF,WAAW,CAACG,MAAM,CAACtB,sBAAsB,CAAC,CAC3C;IACD,MAAMa,GAAG,GAAG,IAAI,CAACY,kBAAkB,CAACd,QAAQ,EAAES,qBAAqB,CAAC;IACpE,IAAIP,GAAG,GAAG,CAAC,EAAE;MACX;;IAEF,IAAI,CAACJ,eAAe,CAACQ,MAAM,CAACJ,GAAG,EAAE,CAAC,CAAC;EACrC;EAEA;;;EAGA,MAAMc,OAAOA,CACXC,cAAsB,EACtBC,aAAsB;IAEtB,MAAMC,eAAe,GAAG,IAAI,CAACC,iBAAiB,CAC5CH,cAAc,EACdC,aAAa,CACd;IACD,MAAMG,oBAAoB,GAAG,IAAI,CAACC,sBAAsB,CACtDL,cAAc,EACdC,aAAa,CACd;IAED,MAAMK,OAAO,GAAG,MAAM9B,iBAAiB,CAAC,CACtC,GAAG0B,eAAe,EAClB,GAAGE,oBAAoB,CACxB,CAAC;IAEF,MAAMG,UAAU,GAAGD,OAAO,CACvBZ,MAAM,CAACjB,kCAAkC,CAAC,CAC1C+B,GAAG,CAACC,EAAE,IAAIA,EAAE,CAACC,MAAM,CAAC;IACvB,OAAOH,UAAU;EACnB;EAEQJ,iBAAiBA,CAACQ,eAAuB,EAAEV,aAAsB;IACvE,OAAO,IAAI,CAACrB,UAAU,CAAC4B,GAAG,CAAC,OAAO;MAAEzB,QAAQ;MAAEC;IAAU,CAAE,KAAI;MAC5D,MAAM4B,gBAAgB,GAAG,IAAItC,oBAAoB,CAC/CU,UAAU,CAAC6B,WAAW,CAACC,IAAI,EAC3B9B,UAAU,CAAC6B,WAAW,CAACE,SAAS,CACjC;MACD,IAAIC,WAAW,GAAkBC,OAAO,CAACC,OAAO,CAC9CnC,QAAQ,CAAC6B,gBAAgB,CAAC,CAC3B;MACD,IAAIX,aAAa,IAAI,IAAI,EAAE;QACzBe,WAAW,GAAGzC,eAAe,CAACyC,WAAW,EAAEf,aAAa,CAAC;;MAE3D,MAAMe,WAAW;MACjBhC,UAAU,CAACmC,eAAe,CAACC,OAAO,CAACC,aAAa,IAAG;QACjDA,aAAa,CAACC,MAAM,CAACV,gBAAgB,CAACW,OAAO,EAAEZ,eAAe,CAAC;MACjE,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EAEQN,sBAAsBA,CAC5BM,eAAuB,EACvBV,aAAsB;IAEtB,OAAO,IAAI,CAACpB,eAAe,CAAC2B,GAAG,CAAC,OAAO;MAAEzB,QAAQ;MAAEQ;IAAW,CAAE,KAAI;MAClE,MAAMqB,gBAAgB,GAAG,IAAIvC,yBAAyB,EAAE;MACxD,IAAI2C,WAAW,GAAkBC,OAAO,CAACC,OAAO,CAC9CnC,QAAQ,CAAC6B,gBAAgB,CAAC,CAC3B;MACD,IAAIX,aAAa,IAAI,IAAI,EAAE;QACzBe,WAAW,GAAGzC,eAAe,CAACyC,WAAW,EAAEf,aAAa,CAAC;;MAE3D,MAAMe,WAAW;MACjBzB,WAAW,CAAC6B,OAAO,CAACpC,UAAU,IAAG;QAC/B,MAAMwC,MAAM,GAAGZ,gBAAgB,CAACW,OAAO,CAACE,GAAG,CAACzC,UAAU,CAAC;QACvD,IAAIwC,MAAM,IAAI,IAAI,EAAE;UAClB;;QAEFxC,UAAU,CAACmC,eAAe,CAACC,OAAO,CAACC,aAAa,IAAG;UACjDA,aAAa,CAACC,MAAM,CAACE,MAAM,EAAEb,eAAe,CAAC;QAC/C,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EAEQzB,aAAaA,CACnBH,QAA4B,EAC5BC,UAAgC;IAEhC,OAAO,IAAI,CAACJ,UAAU,CAAC8C,SAAS,CAACJ,MAAM,IAAG;MACxC,OAAOA,MAAM,CAACvC,QAAQ,KAAKA,QAAQ,IAAIuC,MAAM,CAACtC,UAAU,KAAKA,UAAU;IACzE,CAAC,CAAC;EACJ;EAEQa,kBAAkBA,CACxBd,QAAiC,EACjCQ,WAAsC;IAEtC,OAAO,IAAI,CAACV,eAAe,CAAC6C,SAAS,CAACJ,MAAM,IAAG;MAC7C,OACEA,MAAM,CAACvC,QAAQ,KAAKA,QAAQ,IAC5BL,SAAS,CAAC4C,MAAM,CAAC/B,WAAW,EAAEA,WAAW,CAAC;IAE9C,CAAC,CAAC;EACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { diag } from '@opentelemetry/api';\nimport { ATTR_SERVICE_NAME } from '@opentelemetry/semantic-conventions';\nimport { getStringFromEnv } from '@opentelemetry/core';\n/**\n * EnvDetector can be used to detect the presence of and create a Resource\n * from the OTEL_RESOURCE_ATTRIBUTES environment variable.\n */\nclass EnvDetector {\n  // Type, attribute keys, and attribute values should not exceed 256 characters.\n  _MAX_LENGTH = 255;\n  // OTEL_RESOURCE_ATTRIBUTES is a comma-separated list of attributes.\n  _COMMA_SEPARATOR = ',';\n  // OTEL_RESOURCE_ATTRIBUTES contains key value pair separated by '='.\n  _LABEL_KEY_VALUE_SPLITTER = '=';\n  _ERROR_MESSAGE_INVALID_CHARS = 'should be a ASCII string with a length greater than 0 and not exceed ' + this._MAX_LENGTH + ' characters.';\n  _ERROR_MESSAGE_INVALID_VALUE = 'should be a ASCII string with a length not exceed ' + this._MAX_LENGTH + ' characters.';\n  /**\n   * Returns a {@link Resource} populated with attributes from the\n   * OTEL_RESOURCE_ATTRIBUTES environment variable. Note this is an async\n   * function to conform to the Detector interface.\n   *\n   * @param config The resource detection config\n   */\n  detect(_config) {\n    const attributes = {};\n    const rawAttributes = getStringFromEnv('OTEL_RESOURCE_ATTRIBUTES');\n    const serviceName = getStringFromEnv('OTEL_SERVICE_NAME');\n    if (rawAttributes) {\n      try {\n        const parsedAttributes = this._parseResourceAttributes(rawAttributes);\n        Object.assign(attributes, parsedAttributes);\n      } catch (e) {\n        diag.debug(`EnvDetector failed: ${e.message}`);\n      }\n    }\n    if (serviceName) {\n      attributes[ATTR_SERVICE_NAME] = serviceName;\n    }\n    return {\n      attributes\n    };\n  }\n  /**\n   * Creates an attribute map from the OTEL_RESOURCE_ATTRIBUTES environment\n   * variable.\n   *\n   * OTEL_RESOURCE_ATTRIBUTES: A comma-separated list of attributes describing\n   * the source in more detail, e.g. “key1=val1,key2=val2”. Domain names and\n   * paths are accepted as attribute keys. Values may be quoted or unquoted in\n   * general. If a value contains whitespace, =, or \" characters, it must\n   * always be quoted.\n   *\n   * @param rawEnvAttributes The resource attributes as a comma-separated list\n   * of key/value pairs.\n   * @returns The sanitized resource attributes.\n   */\n  _parseResourceAttributes(rawEnvAttributes) {\n    if (!rawEnvAttributes) return {};\n    const attributes = {};\n    const rawAttributes = rawEnvAttributes.split(this._COMMA_SEPARATOR, -1);\n    for (const rawAttribute of rawAttributes) {\n      const keyValuePair = rawAttribute.split(this._LABEL_KEY_VALUE_SPLITTER, -1);\n      if (keyValuePair.length !== 2) {\n        continue;\n      }\n      let [key, value] = keyValuePair;\n      // Leading and trailing whitespaces are trimmed.\n      key = key.trim();\n      value = value.trim().split(/^\"|\"$/).join('');\n      if (!this._isValidAndNotEmpty(key)) {\n        throw new Error(`Attribute key ${this._ERROR_MESSAGE_INVALID_CHARS}`);\n      }\n      if (!this._isValid(value)) {\n        throw new Error(`Attribute value ${this._ERROR_MESSAGE_INVALID_VALUE}`);\n      }\n      attributes[key] = decodeURIComponent(value);\n    }\n    return attributes;\n  }\n  /**\n   * Determines whether the given String is a valid printable ASCII string with\n   * a length not exceed _MAX_LENGTH characters.\n   *\n   * @param str The String to be validated.\n   * @returns Whether the String is valid.\n   */\n  _isValid(name) {\n    return name.length <= this._MAX_LENGTH && this._isBaggageOctetString(name);\n  }\n  // https://www.w3.org/TR/baggage/#definition\n  _isBaggageOctetString(str) {\n    for (let i = 0; i < str.length; i++) {\n      const ch = str.charCodeAt(i);\n      if (ch < 0x21 || ch === 0x2c || ch === 0x3b || ch === 0x5c || ch > 0x7e) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Determines whether the given String is a valid printable ASCII string with\n   * a length greater than 0 and not exceed _MAX_LENGTH characters.\n   *\n   * @param str The String to be validated.\n   * @returns Whether the String is valid and not empty.\n   */\n  _isValidAndNotEmpty(str) {\n    return str.length > 0 && this._isValid(str);\n  }\n}\nexport const envDetector = new EnvDetector();","map":{"version":3,"names":["diag","ATTR_SERVICE_NAME","getStringFromEnv","EnvDetector","_MAX_LENGTH","_COMMA_SEPARATOR","_LABEL_KEY_VALUE_SPLITTER","_ERROR_MESSAGE_INVALID_CHARS","_ERROR_MESSAGE_INVALID_VALUE","detect","_config","attributes","rawAttributes","serviceName","parsedAttributes","_parseResourceAttributes","Object","assign","e","debug","message","rawEnvAttributes","split","rawAttribute","keyValuePair","length","key","value","trim","join","_isValidAndNotEmpty","Error","_isValid","decodeURIComponent","name","_isBaggageOctetString","str","i","ch","charCodeAt","envDetector"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/resources/src/detectors/EnvDetector.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Attributes, diag } from '@opentelemetry/api';\nimport { ATTR_SERVICE_NAME } from '@opentelemetry/semantic-conventions';\nimport { ResourceDetectionConfig } from '../config';\nimport { DetectedResource, ResourceDetector } from '../types';\nimport { getStringFromEnv } from '@opentelemetry/core';\n\n/**\n * EnvDetector can be used to detect the presence of and create a Resource\n * from the OTEL_RESOURCE_ATTRIBUTES environment variable.\n */\nclass EnvDetector implements ResourceDetector {\n  // Type, attribute keys, and attribute values should not exceed 256 characters.\n  private readonly _MAX_LENGTH = 255;\n\n  // OTEL_RESOURCE_ATTRIBUTES is a comma-separated list of attributes.\n  private readonly _COMMA_SEPARATOR = ',';\n\n  // OTEL_RESOURCE_ATTRIBUTES contains key value pair separated by '='.\n  private readonly _LABEL_KEY_VALUE_SPLITTER = '=';\n\n  private readonly _ERROR_MESSAGE_INVALID_CHARS =\n    'should be a ASCII string with a length greater than 0 and not exceed ' +\n    this._MAX_LENGTH +\n    ' characters.';\n\n  private readonly _ERROR_MESSAGE_INVALID_VALUE =\n    'should be a ASCII string with a length not exceed ' +\n    this._MAX_LENGTH +\n    ' characters.';\n\n  /**\n   * Returns a {@link Resource} populated with attributes from the\n   * OTEL_RESOURCE_ATTRIBUTES environment variable. Note this is an async\n   * function to conform to the Detector interface.\n   *\n   * @param config The resource detection config\n   */\n  detect(_config?: ResourceDetectionConfig): DetectedResource {\n    const attributes: Attributes = {};\n\n    const rawAttributes = getStringFromEnv('OTEL_RESOURCE_ATTRIBUTES');\n    const serviceName = getStringFromEnv('OTEL_SERVICE_NAME');\n\n    if (rawAttributes) {\n      try {\n        const parsedAttributes = this._parseResourceAttributes(rawAttributes);\n        Object.assign(attributes, parsedAttributes);\n      } catch (e) {\n        diag.debug(`EnvDetector failed: ${e.message}`);\n      }\n    }\n\n    if (serviceName) {\n      attributes[ATTR_SERVICE_NAME] = serviceName;\n    }\n\n    return { attributes };\n  }\n\n  /**\n   * Creates an attribute map from the OTEL_RESOURCE_ATTRIBUTES environment\n   * variable.\n   *\n   * OTEL_RESOURCE_ATTRIBUTES: A comma-separated list of attributes describing\n   * the source in more detail, e.g. “key1=val1,key2=val2”. Domain names and\n   * paths are accepted as attribute keys. Values may be quoted or unquoted in\n   * general. If a value contains whitespace, =, or \" characters, it must\n   * always be quoted.\n   *\n   * @param rawEnvAttributes The resource attributes as a comma-separated list\n   * of key/value pairs.\n   * @returns The sanitized resource attributes.\n   */\n  private _parseResourceAttributes(rawEnvAttributes?: string): Attributes {\n    if (!rawEnvAttributes) return {};\n\n    const attributes: Attributes = {};\n    const rawAttributes: string[] = rawEnvAttributes.split(\n      this._COMMA_SEPARATOR,\n      -1\n    );\n    for (const rawAttribute of rawAttributes) {\n      const keyValuePair: string[] = rawAttribute.split(\n        this._LABEL_KEY_VALUE_SPLITTER,\n        -1\n      );\n      if (keyValuePair.length !== 2) {\n        continue;\n      }\n      let [key, value] = keyValuePair;\n      // Leading and trailing whitespaces are trimmed.\n      key = key.trim();\n      value = value.trim().split(/^\"|\"$/).join('');\n      if (!this._isValidAndNotEmpty(key)) {\n        throw new Error(`Attribute key ${this._ERROR_MESSAGE_INVALID_CHARS}`);\n      }\n      if (!this._isValid(value)) {\n        throw new Error(`Attribute value ${this._ERROR_MESSAGE_INVALID_VALUE}`);\n      }\n      attributes[key] = decodeURIComponent(value);\n    }\n    return attributes;\n  }\n\n  /**\n   * Determines whether the given String is a valid printable ASCII string with\n   * a length not exceed _MAX_LENGTH characters.\n   *\n   * @param str The String to be validated.\n   * @returns Whether the String is valid.\n   */\n  private _isValid(name: string): boolean {\n    return name.length <= this._MAX_LENGTH && this._isBaggageOctetString(name);\n  }\n\n  // https://www.w3.org/TR/baggage/#definition\n  private _isBaggageOctetString(str: string): boolean {\n    for (let i = 0; i < str.length; i++) {\n      const ch = str.charCodeAt(i);\n      if (ch < 0x21 || ch === 0x2c || ch === 0x3b || ch === 0x5c || ch > 0x7e) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the given String is a valid printable ASCII string with\n   * a length greater than 0 and not exceed _MAX_LENGTH characters.\n   *\n   * @param str The String to be validated.\n   * @returns Whether the String is valid and not empty.\n   */\n  private _isValidAndNotEmpty(str: string): boolean {\n    return str.length > 0 && this._isValid(str);\n  }\n}\n\nexport const envDetector = new EnvDetector();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
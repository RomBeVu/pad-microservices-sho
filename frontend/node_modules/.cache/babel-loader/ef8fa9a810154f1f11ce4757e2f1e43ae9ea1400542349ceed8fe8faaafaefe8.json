{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { AggregatorKind } from './types';\nimport { DataPointType, InstrumentType } from '../export/MetricData';\nimport { diag } from '@opentelemetry/api';\nimport { Buckets } from './exponential-histogram/Buckets';\nimport { getMapping } from './exponential-histogram/mapping/getMapping';\nimport { nextGreaterSquare } from './exponential-histogram/util';\n// HighLow is a utility class used for computing a common scale for\n// two exponential histogram accumulations\nclass HighLow {\n  low;\n  high;\n  static combine(h1, h2) {\n    return new HighLow(Math.min(h1.low, h2.low), Math.max(h1.high, h2.high));\n  }\n  constructor(low, high) {\n    this.low = low;\n    this.high = high;\n  }\n}\nconst MAX_SCALE = 20;\nconst DEFAULT_MAX_SIZE = 160;\nconst MIN_MAX_SIZE = 2;\nexport class ExponentialHistogramAccumulation {\n  startTime;\n  _maxSize;\n  _recordMinMax;\n  _sum;\n  _count;\n  _zeroCount;\n  _min;\n  _max;\n  _positive;\n  _negative;\n  _mapping;\n  constructor(startTime = startTime, _maxSize = DEFAULT_MAX_SIZE, _recordMinMax = true, _sum = 0, _count = 0, _zeroCount = 0, _min = Number.POSITIVE_INFINITY, _max = Number.NEGATIVE_INFINITY, _positive = new Buckets(), _negative = new Buckets(), _mapping = getMapping(MAX_SCALE)) {\n    this.startTime = startTime;\n    this._maxSize = _maxSize;\n    this._recordMinMax = _recordMinMax;\n    this._sum = _sum;\n    this._count = _count;\n    this._zeroCount = _zeroCount;\n    this._min = _min;\n    this._max = _max;\n    this._positive = _positive;\n    this._negative = _negative;\n    this._mapping = _mapping;\n    if (this._maxSize < MIN_MAX_SIZE) {\n      diag.warn(`Exponential Histogram Max Size set to ${this._maxSize}, \\\n                changing to the minimum size of: ${MIN_MAX_SIZE}`);\n      this._maxSize = MIN_MAX_SIZE;\n    }\n  }\n  /**\n   * record updates a histogram with a single count\n   * @param {Number} value\n   */\n  record(value) {\n    this.updateByIncrement(value, 1);\n  }\n  /**\n   * Sets the start time for this accumulation\n   * @param {HrTime} startTime\n   */\n  setStartTime(startTime) {\n    this.startTime = startTime;\n  }\n  /**\n   * Returns the datapoint representation of this accumulation\n   * @param {HrTime} startTime\n   */\n  toPointValue() {\n    return {\n      hasMinMax: this._recordMinMax,\n      min: this.min,\n      max: this.max,\n      sum: this.sum,\n      positive: {\n        offset: this.positive.offset,\n        bucketCounts: this.positive.counts()\n      },\n      negative: {\n        offset: this.negative.offset,\n        bucketCounts: this.negative.counts()\n      },\n      count: this.count,\n      scale: this.scale,\n      zeroCount: this.zeroCount\n    };\n  }\n  /**\n   * @returns {Number} The sum of values recorded by this accumulation\n   */\n  get sum() {\n    return this._sum;\n  }\n  /**\n   * @returns {Number} The minimum value recorded by this accumulation\n   */\n  get min() {\n    return this._min;\n  }\n  /**\n   * @returns {Number} The maximum value recorded by this accumulation\n   */\n  get max() {\n    return this._max;\n  }\n  /**\n   * @returns {Number} The count of values recorded by this accumulation\n   */\n  get count() {\n    return this._count;\n  }\n  /**\n   * @returns {Number} The number of 0 values recorded by this accumulation\n   */\n  get zeroCount() {\n    return this._zeroCount;\n  }\n  /**\n   * @returns {Number} The scale used by this accumulation\n   */\n  get scale() {\n    if (this._count === this._zeroCount) {\n      // all zeros! scale doesn't matter, use zero\n      return 0;\n    }\n    return this._mapping.scale;\n  }\n  /**\n   * positive holds the positive values\n   * @returns {Buckets}\n   */\n  get positive() {\n    return this._positive;\n  }\n  /**\n   * negative holds the negative values by their absolute value\n   * @returns {Buckets}\n   */\n  get negative() {\n    return this._negative;\n  }\n  /**\n   * updateByIncr supports updating a histogram with a non-negative\n   * increment.\n   * @param value\n   * @param increment\n   */\n  updateByIncrement(value, increment) {\n    // NaN does not fall into any bucket, is not zero and should not be counted,\n    // NaN is never greater than max nor less than min, therefore return as there's nothing for us to do.\n    if (Number.isNaN(value)) {\n      return;\n    }\n    if (value > this._max) {\n      this._max = value;\n    }\n    if (value < this._min) {\n      this._min = value;\n    }\n    this._count += increment;\n    if (value === 0) {\n      this._zeroCount += increment;\n      return;\n    }\n    this._sum += value * increment;\n    if (value > 0) {\n      this._updateBuckets(this._positive, value, increment);\n    } else {\n      this._updateBuckets(this._negative, -value, increment);\n    }\n  }\n  /**\n   * merge combines data from previous value into self\n   * @param {ExponentialHistogramAccumulation} previous\n   */\n  merge(previous) {\n    if (this._count === 0) {\n      this._min = previous.min;\n      this._max = previous.max;\n    } else if (previous.count !== 0) {\n      if (previous.min < this.min) {\n        this._min = previous.min;\n      }\n      if (previous.max > this.max) {\n        this._max = previous.max;\n      }\n    }\n    this.startTime = previous.startTime;\n    this._sum += previous.sum;\n    this._count += previous.count;\n    this._zeroCount += previous.zeroCount;\n    const minScale = this._minScale(previous);\n    this._downscale(this.scale - minScale);\n    this._mergeBuckets(this.positive, previous, previous.positive, minScale);\n    this._mergeBuckets(this.negative, previous, previous.negative, minScale);\n  }\n  /**\n   * diff subtracts other from self\n   * @param {ExponentialHistogramAccumulation} other\n   */\n  diff(other) {\n    this._min = Infinity;\n    this._max = -Infinity;\n    this._sum -= other.sum;\n    this._count -= other.count;\n    this._zeroCount -= other.zeroCount;\n    const minScale = this._minScale(other);\n    this._downscale(this.scale - minScale);\n    this._diffBuckets(this.positive, other, other.positive, minScale);\n    this._diffBuckets(this.negative, other, other.negative, minScale);\n  }\n  /**\n   * clone returns a deep copy of self\n   * @returns {ExponentialHistogramAccumulation}\n   */\n  clone() {\n    return new ExponentialHistogramAccumulation(this.startTime, this._maxSize, this._recordMinMax, this._sum, this._count, this._zeroCount, this._min, this._max, this.positive.clone(), this.negative.clone(), this._mapping);\n  }\n  /**\n   * _updateBuckets maps the incoming value to a bucket index for the current\n   * scale. If the bucket index is outside of the range of the backing array,\n   * it will rescale the backing array and update the mapping for the new scale.\n   */\n  _updateBuckets(buckets, value, increment) {\n    let index = this._mapping.mapToIndex(value);\n    // rescale the mapping if needed\n    let rescalingNeeded = false;\n    let high = 0;\n    let low = 0;\n    if (buckets.length === 0) {\n      buckets.indexStart = index;\n      buckets.indexEnd = buckets.indexStart;\n      buckets.indexBase = buckets.indexStart;\n    } else if (index < buckets.indexStart && buckets.indexEnd - index >= this._maxSize) {\n      rescalingNeeded = true;\n      low = index;\n      high = buckets.indexEnd;\n    } else if (index > buckets.indexEnd && index - buckets.indexStart >= this._maxSize) {\n      rescalingNeeded = true;\n      low = buckets.indexStart;\n      high = index;\n    }\n    // rescale and compute index at new scale\n    if (rescalingNeeded) {\n      const change = this._changeScale(high, low);\n      this._downscale(change);\n      index = this._mapping.mapToIndex(value);\n    }\n    this._incrementIndexBy(buckets, index, increment);\n  }\n  /**\n   * _incrementIndexBy increments the count of the bucket specified by `index`.\n   * If the index is outside of the range [buckets.indexStart, buckets.indexEnd]\n   * the boundaries of the backing array will be adjusted and more buckets will\n   * be added if needed.\n   */\n  _incrementIndexBy(buckets, index, increment) {\n    if (increment === 0) {\n      // nothing to do for a zero increment, can happen during a merge operation\n      return;\n    }\n    if (buckets.length === 0) {\n      buckets.indexStart = buckets.indexEnd = buckets.indexBase = index;\n    }\n    if (index < buckets.indexStart) {\n      const span = buckets.indexEnd - index;\n      if (span >= buckets.backing.length) {\n        this._grow(buckets, span + 1);\n      }\n      buckets.indexStart = index;\n    } else if (index > buckets.indexEnd) {\n      const span = index - buckets.indexStart;\n      if (span >= buckets.backing.length) {\n        this._grow(buckets, span + 1);\n      }\n      buckets.indexEnd = index;\n    }\n    let bucketIndex = index - buckets.indexBase;\n    if (bucketIndex < 0) {\n      bucketIndex += buckets.backing.length;\n    }\n    buckets.incrementBucket(bucketIndex, increment);\n  }\n  /**\n   * grow resizes the backing array by doubling in size up to maxSize.\n   * This extends the array with a bunch of zeros and copies the\n   * existing counts to the same position.\n   */\n  _grow(buckets, needed) {\n    const size = buckets.backing.length;\n    const bias = buckets.indexBase - buckets.indexStart;\n    const oldPositiveLimit = size - bias;\n    let newSize = nextGreaterSquare(needed);\n    if (newSize > this._maxSize) {\n      newSize = this._maxSize;\n    }\n    const newPositiveLimit = newSize - bias;\n    buckets.backing.growTo(newSize, oldPositiveLimit, newPositiveLimit);\n  }\n  /**\n   * _changeScale computes how much downscaling is needed by shifting the\n   * high and low values until they are separated by no more than size.\n   */\n  _changeScale(high, low) {\n    let change = 0;\n    while (high - low >= this._maxSize) {\n      high >>= 1;\n      low >>= 1;\n      change++;\n    }\n    return change;\n  }\n  /**\n   * _downscale subtracts `change` from the current mapping scale.\n   */\n  _downscale(change) {\n    if (change === 0) {\n      return;\n    }\n    if (change < 0) {\n      // Note: this should be impossible. If we get here it's because\n      // there is a bug in the implementation.\n      throw new Error(`impossible change of scale: ${this.scale}`);\n    }\n    const newScale = this._mapping.scale - change;\n    this._positive.downscale(change);\n    this._negative.downscale(change);\n    this._mapping = getMapping(newScale);\n  }\n  /**\n   * _minScale is used by diff and merge to compute an ideal combined scale\n   */\n  _minScale(other) {\n    const minScale = Math.min(this.scale, other.scale);\n    const highLowPos = HighLow.combine(this._highLowAtScale(this.positive, this.scale, minScale), this._highLowAtScale(other.positive, other.scale, minScale));\n    const highLowNeg = HighLow.combine(this._highLowAtScale(this.negative, this.scale, minScale), this._highLowAtScale(other.negative, other.scale, minScale));\n    return Math.min(minScale - this._changeScale(highLowPos.high, highLowPos.low), minScale - this._changeScale(highLowNeg.high, highLowNeg.low));\n  }\n  /**\n   * _highLowAtScale is used by diff and merge to compute an ideal combined scale.\n   */\n  _highLowAtScale(buckets, currentScale, newScale) {\n    if (buckets.length === 0) {\n      return new HighLow(0, -1);\n    }\n    const shift = currentScale - newScale;\n    return new HighLow(buckets.indexStart >> shift, buckets.indexEnd >> shift);\n  }\n  /**\n   * _mergeBuckets translates index values from another histogram and\n   * adds the values into the corresponding buckets of this histogram.\n   */\n  _mergeBuckets(ours, other, theirs, scale) {\n    const theirOffset = theirs.offset;\n    const theirChange = other.scale - scale;\n    for (let i = 0; i < theirs.length; i++) {\n      this._incrementIndexBy(ours, theirOffset + i >> theirChange, theirs.at(i));\n    }\n  }\n  /**\n   * _diffBuckets translates index values from another histogram and\n   * subtracts the values in the corresponding buckets of this histogram.\n   */\n  _diffBuckets(ours, other, theirs, scale) {\n    const theirOffset = theirs.offset;\n    const theirChange = other.scale - scale;\n    for (let i = 0; i < theirs.length; i++) {\n      const ourIndex = theirOffset + i >> theirChange;\n      let bucketIndex = ourIndex - ours.indexBase;\n      if (bucketIndex < 0) {\n        bucketIndex += ours.backing.length;\n      }\n      ours.decrementBucket(bucketIndex, theirs.at(i));\n    }\n    ours.trim();\n  }\n}\n/**\n * Aggregator for ExponentialHistogramAccumulations\n */\nexport class ExponentialHistogramAggregator {\n  _maxSize;\n  _recordMinMax;\n  kind = AggregatorKind.EXPONENTIAL_HISTOGRAM;\n  /**\n   * @param _maxSize Maximum number of buckets for each of the positive\n   *    and negative ranges, exclusive of the zero-bucket.\n   * @param _recordMinMax If set to true, min and max will be recorded.\n   *    Otherwise, min and max will not be recorded.\n   */\n  constructor(_maxSize, _recordMinMax) {\n    this._maxSize = _maxSize;\n    this._recordMinMax = _recordMinMax;\n  }\n  createAccumulation(startTime) {\n    return new ExponentialHistogramAccumulation(startTime, this._maxSize, this._recordMinMax);\n  }\n  /**\n   * Return the result of the merge of two exponential histogram accumulations.\n   */\n  merge(previous, delta) {\n    const result = delta.clone();\n    result.merge(previous);\n    return result;\n  }\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   */\n  diff(previous, current) {\n    const result = current.clone();\n    result.diff(previous);\n    return result;\n  }\n  toMetricData(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {\n    return {\n      descriptor,\n      aggregationTemporality,\n      dataPointType: DataPointType.EXPONENTIAL_HISTOGRAM,\n      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {\n        const pointValue = accumulation.toPointValue();\n        // determine if instrument allows negative values.\n        const allowsNegativeValues = descriptor.type === InstrumentType.GAUGE || descriptor.type === InstrumentType.UP_DOWN_COUNTER || descriptor.type === InstrumentType.OBSERVABLE_GAUGE || descriptor.type === InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;\n        return {\n          attributes,\n          startTime: accumulation.startTime,\n          endTime,\n          value: {\n            min: pointValue.hasMinMax ? pointValue.min : undefined,\n            max: pointValue.hasMinMax ? pointValue.max : undefined,\n            sum: !allowsNegativeValues ? pointValue.sum : undefined,\n            positive: {\n              offset: pointValue.positive.offset,\n              bucketCounts: pointValue.positive.bucketCounts\n            },\n            negative: {\n              offset: pointValue.negative.offset,\n              bucketCounts: pointValue.negative.bucketCounts\n            },\n            count: pointValue.count,\n            scale: pointValue.scale,\n            zeroCount: pointValue.zeroCount\n          }\n        };\n      })\n    };\n  }\n}","map":{"version":3,"names":["AggregatorKind","DataPointType","InstrumentType","diag","Buckets","getMapping","nextGreaterSquare","HighLow","low","high","combine","h1","h2","Math","min","max","constructor","MAX_SCALE","DEFAULT_MAX_SIZE","MIN_MAX_SIZE","ExponentialHistogramAccumulation","startTime","_maxSize","_recordMinMax","_sum","_count","_zeroCount","_min","_max","_positive","_negative","_mapping","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","warn","record","value","updateByIncrement","setStartTime","toPointValue","hasMinMax","sum","positive","offset","bucketCounts","counts","negative","count","scale","zeroCount","increment","isNaN","_updateBuckets","merge","previous","minScale","_minScale","_downscale","_mergeBuckets","diff","other","Infinity","_diffBuckets","clone","buckets","index","mapToIndex","rescalingNeeded","length","indexStart","indexEnd","indexBase","change","_changeScale","_incrementIndexBy","span","backing","_grow","bucketIndex","incrementBucket","needed","size","bias","oldPositiveLimit","newSize","newPositiveLimit","growTo","Error","newScale","downscale","highLowPos","_highLowAtScale","highLowNeg","currentScale","shift","ours","theirs","theirOffset","theirChange","i","at","ourIndex","decrementBucket","trim","ExponentialHistogramAggregator","kind","EXPONENTIAL_HISTOGRAM","createAccumulation","delta","result","current","toMetricData","descriptor","aggregationTemporality","accumulationByAttributes","endTime","dataPointType","dataPoints","map","attributes","accumulation","pointValue","allowsNegativeValues","type","GAUGE","UP_DOWN_COUNTER","OBSERVABLE_GAUGE","OBSERVABLE_UP_DOWN_COUNTER","undefined"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/sdk-metrics/src/aggregator/ExponentialHistogram.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Accumulation,\n  AccumulationRecord,\n  Aggregator,\n  AggregatorKind,\n  ExponentialHistogram,\n} from './types';\nimport {\n  DataPointType,\n  ExponentialHistogramMetricData,\n  InstrumentType,\n} from '../export/MetricData';\nimport { diag, HrTime } from '@opentelemetry/api';\nimport { Maybe } from '../utils';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\nimport { Buckets } from './exponential-histogram/Buckets';\nimport { getMapping } from './exponential-histogram/mapping/getMapping';\nimport { Mapping } from './exponential-histogram/mapping/types';\nimport { nextGreaterSquare } from './exponential-histogram/util';\n\n/**\n * Internal value type for ExponentialHistogramAggregation.\n * Differs from the exported type as undefined sum/min/max complicate arithmetic\n * performed by this aggregation, but are required to be undefined in the exported types.\n */\ninterface InternalHistogram extends ExponentialHistogram {\n  hasMinMax: boolean;\n  min: number;\n  max: number;\n  sum: number;\n}\n\n// HighLow is a utility class used for computing a common scale for\n// two exponential histogram accumulations\nclass HighLow {\n  static combine(h1: HighLow, h2: HighLow): HighLow {\n    return new HighLow(Math.min(h1.low, h2.low), Math.max(h1.high, h2.high));\n  }\n  constructor(\n    public low: number,\n    public high: number\n  ) {}\n}\n\nconst MAX_SCALE = 20;\nconst DEFAULT_MAX_SIZE = 160;\nconst MIN_MAX_SIZE = 2;\n\nexport class ExponentialHistogramAccumulation implements Accumulation {\n  constructor(\n    public startTime: HrTime = startTime,\n    private _maxSize = DEFAULT_MAX_SIZE,\n    private _recordMinMax = true,\n    private _sum = 0,\n    private _count = 0,\n    private _zeroCount = 0,\n    private _min = Number.POSITIVE_INFINITY,\n    private _max = Number.NEGATIVE_INFINITY,\n    private _positive = new Buckets(),\n    private _negative = new Buckets(),\n    private _mapping: Mapping = getMapping(MAX_SCALE)\n  ) {\n    if (this._maxSize < MIN_MAX_SIZE) {\n      diag.warn(`Exponential Histogram Max Size set to ${this._maxSize}, \\\n                changing to the minimum size of: ${MIN_MAX_SIZE}`);\n      this._maxSize = MIN_MAX_SIZE;\n    }\n  }\n\n  /**\n   * record updates a histogram with a single count\n   * @param {Number} value\n   */\n  record(value: number) {\n    this.updateByIncrement(value, 1);\n  }\n\n  /**\n   * Sets the start time for this accumulation\n   * @param {HrTime} startTime\n   */\n  setStartTime(startTime: HrTime): void {\n    this.startTime = startTime;\n  }\n\n  /**\n   * Returns the datapoint representation of this accumulation\n   * @param {HrTime} startTime\n   */\n  toPointValue(): InternalHistogram {\n    return {\n      hasMinMax: this._recordMinMax,\n      min: this.min,\n      max: this.max,\n      sum: this.sum,\n      positive: {\n        offset: this.positive.offset,\n        bucketCounts: this.positive.counts(),\n      },\n      negative: {\n        offset: this.negative.offset,\n        bucketCounts: this.negative.counts(),\n      },\n      count: this.count,\n      scale: this.scale,\n      zeroCount: this.zeroCount,\n    };\n  }\n\n  /**\n   * @returns {Number} The sum of values recorded by this accumulation\n   */\n  get sum(): number {\n    return this._sum;\n  }\n\n  /**\n   * @returns {Number} The minimum value recorded by this accumulation\n   */\n  get min(): number {\n    return this._min;\n  }\n\n  /**\n   * @returns {Number} The maximum value recorded by this accumulation\n   */\n  get max(): number {\n    return this._max;\n  }\n\n  /**\n   * @returns {Number} The count of values recorded by this accumulation\n   */\n  get count(): number {\n    return this._count;\n  }\n\n  /**\n   * @returns {Number} The number of 0 values recorded by this accumulation\n   */\n  get zeroCount(): number {\n    return this._zeroCount;\n  }\n\n  /**\n   * @returns {Number} The scale used by this accumulation\n   */\n  get scale(): number {\n    if (this._count === this._zeroCount) {\n      // all zeros! scale doesn't matter, use zero\n      return 0;\n    }\n    return this._mapping.scale;\n  }\n\n  /**\n   * positive holds the positive values\n   * @returns {Buckets}\n   */\n  get positive(): Buckets {\n    return this._positive;\n  }\n\n  /**\n   * negative holds the negative values by their absolute value\n   * @returns {Buckets}\n   */\n  get negative(): Buckets {\n    return this._negative;\n  }\n\n  /**\n   * updateByIncr supports updating a histogram with a non-negative\n   * increment.\n   * @param value\n   * @param increment\n   */\n  updateByIncrement(value: number, increment: number) {\n    // NaN does not fall into any bucket, is not zero and should not be counted,\n    // NaN is never greater than max nor less than min, therefore return as there's nothing for us to do.\n    if (Number.isNaN(value)) {\n      return;\n    }\n\n    if (value > this._max) {\n      this._max = value;\n    }\n    if (value < this._min) {\n      this._min = value;\n    }\n\n    this._count += increment;\n\n    if (value === 0) {\n      this._zeroCount += increment;\n      return;\n    }\n\n    this._sum += value * increment;\n\n    if (value > 0) {\n      this._updateBuckets(this._positive, value, increment);\n    } else {\n      this._updateBuckets(this._negative, -value, increment);\n    }\n  }\n\n  /**\n   * merge combines data from previous value into self\n   * @param {ExponentialHistogramAccumulation} previous\n   */\n  merge(previous: ExponentialHistogramAccumulation) {\n    if (this._count === 0) {\n      this._min = previous.min;\n      this._max = previous.max;\n    } else if (previous.count !== 0) {\n      if (previous.min < this.min) {\n        this._min = previous.min;\n      }\n      if (previous.max > this.max) {\n        this._max = previous.max;\n      }\n    }\n\n    this.startTime = previous.startTime;\n    this._sum += previous.sum;\n    this._count += previous.count;\n    this._zeroCount += previous.zeroCount;\n\n    const minScale = this._minScale(previous);\n\n    this._downscale(this.scale - minScale);\n\n    this._mergeBuckets(this.positive, previous, previous.positive, minScale);\n    this._mergeBuckets(this.negative, previous, previous.negative, minScale);\n  }\n\n  /**\n   * diff subtracts other from self\n   * @param {ExponentialHistogramAccumulation} other\n   */\n  diff(other: ExponentialHistogramAccumulation) {\n    this._min = Infinity;\n    this._max = -Infinity;\n    this._sum -= other.sum;\n    this._count -= other.count;\n    this._zeroCount -= other.zeroCount;\n\n    const minScale = this._minScale(other);\n\n    this._downscale(this.scale - minScale);\n\n    this._diffBuckets(this.positive, other, other.positive, minScale);\n    this._diffBuckets(this.negative, other, other.negative, minScale);\n  }\n\n  /**\n   * clone returns a deep copy of self\n   * @returns {ExponentialHistogramAccumulation}\n   */\n  clone(): ExponentialHistogramAccumulation {\n    return new ExponentialHistogramAccumulation(\n      this.startTime,\n      this._maxSize,\n      this._recordMinMax,\n      this._sum,\n      this._count,\n      this._zeroCount,\n      this._min,\n      this._max,\n      this.positive.clone(),\n      this.negative.clone(),\n      this._mapping\n    );\n  }\n\n  /**\n   * _updateBuckets maps the incoming value to a bucket index for the current\n   * scale. If the bucket index is outside of the range of the backing array,\n   * it will rescale the backing array and update the mapping for the new scale.\n   */\n  private _updateBuckets(buckets: Buckets, value: number, increment: number) {\n    let index = this._mapping.mapToIndex(value);\n\n    // rescale the mapping if needed\n    let rescalingNeeded = false;\n    let high = 0;\n    let low = 0;\n\n    if (buckets.length === 0) {\n      buckets.indexStart = index;\n      buckets.indexEnd = buckets.indexStart;\n      buckets.indexBase = buckets.indexStart;\n    } else if (\n      index < buckets.indexStart &&\n      buckets.indexEnd - index >= this._maxSize\n    ) {\n      rescalingNeeded = true;\n      low = index;\n      high = buckets.indexEnd;\n    } else if (\n      index > buckets.indexEnd &&\n      index - buckets.indexStart >= this._maxSize\n    ) {\n      rescalingNeeded = true;\n      low = buckets.indexStart;\n      high = index;\n    }\n\n    // rescale and compute index at new scale\n    if (rescalingNeeded) {\n      const change = this._changeScale(high, low);\n      this._downscale(change);\n      index = this._mapping.mapToIndex(value);\n    }\n\n    this._incrementIndexBy(buckets, index, increment);\n  }\n\n  /**\n   * _incrementIndexBy increments the count of the bucket specified by `index`.\n   * If the index is outside of the range [buckets.indexStart, buckets.indexEnd]\n   * the boundaries of the backing array will be adjusted and more buckets will\n   * be added if needed.\n   */\n  private _incrementIndexBy(\n    buckets: Buckets,\n    index: number,\n    increment: number\n  ) {\n    if (increment === 0) {\n      // nothing to do for a zero increment, can happen during a merge operation\n      return;\n    }\n\n    if (buckets.length === 0) {\n      buckets.indexStart = buckets.indexEnd = buckets.indexBase = index;\n    }\n\n    if (index < buckets.indexStart) {\n      const span = buckets.indexEnd - index;\n      if (span >= buckets.backing.length) {\n        this._grow(buckets, span + 1);\n      }\n      buckets.indexStart = index;\n    } else if (index > buckets.indexEnd) {\n      const span = index - buckets.indexStart;\n      if (span >= buckets.backing.length) {\n        this._grow(buckets, span + 1);\n      }\n      buckets.indexEnd = index;\n    }\n\n    let bucketIndex = index - buckets.indexBase;\n    if (bucketIndex < 0) {\n      bucketIndex += buckets.backing.length;\n    }\n    buckets.incrementBucket(bucketIndex, increment);\n  }\n\n  /**\n   * grow resizes the backing array by doubling in size up to maxSize.\n   * This extends the array with a bunch of zeros and copies the\n   * existing counts to the same position.\n   */\n  private _grow(buckets: Buckets, needed: number) {\n    const size = buckets.backing.length;\n    const bias = buckets.indexBase - buckets.indexStart;\n    const oldPositiveLimit = size - bias;\n    let newSize = nextGreaterSquare(needed);\n    if (newSize > this._maxSize) {\n      newSize = this._maxSize;\n    }\n    const newPositiveLimit = newSize - bias;\n    buckets.backing.growTo(newSize, oldPositiveLimit, newPositiveLimit);\n  }\n\n  /**\n   * _changeScale computes how much downscaling is needed by shifting the\n   * high and low values until they are separated by no more than size.\n   */\n  private _changeScale(high: number, low: number): number {\n    let change = 0;\n    while (high - low >= this._maxSize) {\n      high >>= 1;\n      low >>= 1;\n      change++;\n    }\n    return change;\n  }\n\n  /**\n   * _downscale subtracts `change` from the current mapping scale.\n   */\n  private _downscale(change: number) {\n    if (change === 0) {\n      return;\n    }\n    if (change < 0) {\n      // Note: this should be impossible. If we get here it's because\n      // there is a bug in the implementation.\n      throw new Error(`impossible change of scale: ${this.scale}`);\n    }\n    const newScale = this._mapping.scale - change;\n\n    this._positive.downscale(change);\n    this._negative.downscale(change);\n\n    this._mapping = getMapping(newScale);\n  }\n\n  /**\n   * _minScale is used by diff and merge to compute an ideal combined scale\n   */\n  private _minScale(other: ExponentialHistogramAccumulation): number {\n    const minScale = Math.min(this.scale, other.scale);\n\n    const highLowPos = HighLow.combine(\n      this._highLowAtScale(this.positive, this.scale, minScale),\n      this._highLowAtScale(other.positive, other.scale, minScale)\n    );\n\n    const highLowNeg = HighLow.combine(\n      this._highLowAtScale(this.negative, this.scale, minScale),\n      this._highLowAtScale(other.negative, other.scale, minScale)\n    );\n\n    return Math.min(\n      minScale - this._changeScale(highLowPos.high, highLowPos.low),\n      minScale - this._changeScale(highLowNeg.high, highLowNeg.low)\n    );\n  }\n\n  /**\n   * _highLowAtScale is used by diff and merge to compute an ideal combined scale.\n   */\n  private _highLowAtScale(\n    buckets: Buckets,\n    currentScale: number,\n    newScale: number\n  ): HighLow {\n    if (buckets.length === 0) {\n      return new HighLow(0, -1);\n    }\n    const shift = currentScale - newScale;\n    return new HighLow(buckets.indexStart >> shift, buckets.indexEnd >> shift);\n  }\n\n  /**\n   * _mergeBuckets translates index values from another histogram and\n   * adds the values into the corresponding buckets of this histogram.\n   */\n  private _mergeBuckets(\n    ours: Buckets,\n    other: ExponentialHistogramAccumulation,\n    theirs: Buckets,\n    scale: number\n  ) {\n    const theirOffset = theirs.offset;\n    const theirChange = other.scale - scale;\n\n    for (let i = 0; i < theirs.length; i++) {\n      this._incrementIndexBy(\n        ours,\n        (theirOffset + i) >> theirChange,\n        theirs.at(i)\n      );\n    }\n  }\n\n  /**\n   * _diffBuckets translates index values from another histogram and\n   * subtracts the values in the corresponding buckets of this histogram.\n   */\n  private _diffBuckets(\n    ours: Buckets,\n    other: ExponentialHistogramAccumulation,\n    theirs: Buckets,\n    scale: number\n  ) {\n    const theirOffset = theirs.offset;\n    const theirChange = other.scale - scale;\n\n    for (let i = 0; i < theirs.length; i++) {\n      const ourIndex = (theirOffset + i) >> theirChange;\n      let bucketIndex = ourIndex - ours.indexBase;\n      if (bucketIndex < 0) {\n        bucketIndex += ours.backing.length;\n      }\n      ours.decrementBucket(bucketIndex, theirs.at(i));\n    }\n\n    ours.trim();\n  }\n}\n\n/**\n * Aggregator for ExponentialHistogramAccumulations\n */\nexport class ExponentialHistogramAggregator\n  implements Aggregator<ExponentialHistogramAccumulation>\n{\n  public kind: AggregatorKind.EXPONENTIAL_HISTOGRAM =\n    AggregatorKind.EXPONENTIAL_HISTOGRAM;\n\n  /**\n   * @param _maxSize Maximum number of buckets for each of the positive\n   *    and negative ranges, exclusive of the zero-bucket.\n   * @param _recordMinMax If set to true, min and max will be recorded.\n   *    Otherwise, min and max will not be recorded.\n   */\n  constructor(\n    readonly _maxSize: number,\n    private readonly _recordMinMax: boolean\n  ) {}\n\n  createAccumulation(startTime: HrTime) {\n    return new ExponentialHistogramAccumulation(\n      startTime,\n      this._maxSize,\n      this._recordMinMax\n    );\n  }\n\n  /**\n   * Return the result of the merge of two exponential histogram accumulations.\n   */\n  merge(\n    previous: ExponentialHistogramAccumulation,\n    delta: ExponentialHistogramAccumulation\n  ): ExponentialHistogramAccumulation {\n    const result = delta.clone();\n    result.merge(previous);\n\n    return result;\n  }\n\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   */\n  diff(\n    previous: ExponentialHistogramAccumulation,\n    current: ExponentialHistogramAccumulation\n  ): ExponentialHistogramAccumulation {\n    const result = current.clone();\n    result.diff(previous);\n\n    return result;\n  }\n\n  toMetricData(\n    descriptor: InstrumentDescriptor,\n    aggregationTemporality: AggregationTemporality,\n    accumulationByAttributes: AccumulationRecord<ExponentialHistogramAccumulation>[],\n    endTime: HrTime\n  ): Maybe<ExponentialHistogramMetricData> {\n    return {\n      descriptor,\n      aggregationTemporality,\n      dataPointType: DataPointType.EXPONENTIAL_HISTOGRAM,\n      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {\n        const pointValue = accumulation.toPointValue();\n\n        // determine if instrument allows negative values.\n        const allowsNegativeValues =\n          descriptor.type === InstrumentType.GAUGE ||\n          descriptor.type === InstrumentType.UP_DOWN_COUNTER ||\n          descriptor.type === InstrumentType.OBSERVABLE_GAUGE ||\n          descriptor.type === InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;\n\n        return {\n          attributes,\n          startTime: accumulation.startTime,\n          endTime,\n          value: {\n            min: pointValue.hasMinMax ? pointValue.min : undefined,\n            max: pointValue.hasMinMax ? pointValue.max : undefined,\n            sum: !allowsNegativeValues ? pointValue.sum : undefined,\n            positive: {\n              offset: pointValue.positive.offset,\n              bucketCounts: pointValue.positive.bucketCounts,\n            },\n            negative: {\n              offset: pointValue.negative.offset,\n              bucketCounts: pointValue.negative.bucketCounts,\n            },\n            count: pointValue.count,\n            scale: pointValue.scale,\n            zeroCount: pointValue.zeroCount,\n          },\n        };\n      }),\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { AggregatorKind } from './types';\nimport { DataPointType, InstrumentType } from '../export/MetricData';\nimport { binarySearchUB } from '../utils';\nfunction createNewEmptyCheckpoint(boundaries) {\n  const counts = boundaries.map(() => 0);\n  counts.push(0);\n  return {\n    buckets: {\n      boundaries,\n      counts\n    },\n    sum: 0,\n    count: 0,\n    hasMinMax: false,\n    min: Infinity,\n    max: -Infinity\n  };\n}\nexport class HistogramAccumulation {\n  startTime;\n  _boundaries;\n  _recordMinMax;\n  _current;\n  constructor(startTime, _boundaries, _recordMinMax = true, _current = createNewEmptyCheckpoint(_boundaries)) {\n    this.startTime = startTime;\n    this._boundaries = _boundaries;\n    this._recordMinMax = _recordMinMax;\n    this._current = _current;\n  }\n  record(value) {\n    // NaN does not fall into any bucket, is not zero and should not be counted,\n    // NaN is never greater than max nor less than min, therefore return as there's nothing for us to do.\n    if (Number.isNaN(value)) {\n      return;\n    }\n    this._current.count += 1;\n    this._current.sum += value;\n    if (this._recordMinMax) {\n      this._current.min = Math.min(value, this._current.min);\n      this._current.max = Math.max(value, this._current.max);\n      this._current.hasMinMax = true;\n    }\n    const idx = binarySearchUB(this._boundaries, value);\n    this._current.buckets.counts[idx] += 1;\n  }\n  setStartTime(startTime) {\n    this.startTime = startTime;\n  }\n  toPointValue() {\n    return this._current;\n  }\n}\n/**\n * Basic aggregator which observes events and counts them in pre-defined buckets\n * and provides the total sum and count of all observations.\n */\nexport class HistogramAggregator {\n  _boundaries;\n  _recordMinMax;\n  kind = AggregatorKind.HISTOGRAM;\n  /**\n   * @param _boundaries sorted upper bounds of recorded values.\n   * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.\n   */\n  constructor(_boundaries, _recordMinMax) {\n    this._boundaries = _boundaries;\n    this._recordMinMax = _recordMinMax;\n  }\n  createAccumulation(startTime) {\n    return new HistogramAccumulation(startTime, this._boundaries, this._recordMinMax);\n  }\n  /**\n   * Return the result of the merge of two histogram accumulations. As long as one Aggregator\n   * instance produces all Accumulations with constant boundaries we don't need to worry about\n   * merging accumulations with different boundaries.\n   */\n  merge(previous, delta) {\n    const previousValue = previous.toPointValue();\n    const deltaValue = delta.toPointValue();\n    const previousCounts = previousValue.buckets.counts;\n    const deltaCounts = deltaValue.buckets.counts;\n    const mergedCounts = new Array(previousCounts.length);\n    for (let idx = 0; idx < previousCounts.length; idx++) {\n      mergedCounts[idx] = previousCounts[idx] + deltaCounts[idx];\n    }\n    let min = Infinity;\n    let max = -Infinity;\n    if (this._recordMinMax) {\n      if (previousValue.hasMinMax && deltaValue.hasMinMax) {\n        min = Math.min(previousValue.min, deltaValue.min);\n        max = Math.max(previousValue.max, deltaValue.max);\n      } else if (previousValue.hasMinMax) {\n        min = previousValue.min;\n        max = previousValue.max;\n      } else if (deltaValue.hasMinMax) {\n        min = deltaValue.min;\n        max = deltaValue.max;\n      }\n    }\n    return new HistogramAccumulation(previous.startTime, previousValue.buckets.boundaries, this._recordMinMax, {\n      buckets: {\n        boundaries: previousValue.buckets.boundaries,\n        counts: mergedCounts\n      },\n      count: previousValue.count + deltaValue.count,\n      sum: previousValue.sum + deltaValue.sum,\n      hasMinMax: this._recordMinMax && (previousValue.hasMinMax || deltaValue.hasMinMax),\n      min: min,\n      max: max\n    });\n  }\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   */\n  diff(previous, current) {\n    const previousValue = previous.toPointValue();\n    const currentValue = current.toPointValue();\n    const previousCounts = previousValue.buckets.counts;\n    const currentCounts = currentValue.buckets.counts;\n    const diffedCounts = new Array(previousCounts.length);\n    for (let idx = 0; idx < previousCounts.length; idx++) {\n      diffedCounts[idx] = currentCounts[idx] - previousCounts[idx];\n    }\n    return new HistogramAccumulation(current.startTime, previousValue.buckets.boundaries, this._recordMinMax, {\n      buckets: {\n        boundaries: previousValue.buckets.boundaries,\n        counts: diffedCounts\n      },\n      count: currentValue.count - previousValue.count,\n      sum: currentValue.sum - previousValue.sum,\n      hasMinMax: false,\n      min: Infinity,\n      max: -Infinity\n    });\n  }\n  toMetricData(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {\n    return {\n      descriptor,\n      aggregationTemporality,\n      dataPointType: DataPointType.HISTOGRAM,\n      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {\n        const pointValue = accumulation.toPointValue();\n        // determine if instrument allows negative values.\n        const allowsNegativeValues = descriptor.type === InstrumentType.GAUGE || descriptor.type === InstrumentType.UP_DOWN_COUNTER || descriptor.type === InstrumentType.OBSERVABLE_GAUGE || descriptor.type === InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;\n        return {\n          attributes,\n          startTime: accumulation.startTime,\n          endTime,\n          value: {\n            min: pointValue.hasMinMax ? pointValue.min : undefined,\n            max: pointValue.hasMinMax ? pointValue.max : undefined,\n            sum: !allowsNegativeValues ? pointValue.sum : undefined,\n            buckets: pointValue.buckets,\n            count: pointValue.count\n          }\n        };\n      })\n    };\n  }\n}","map":{"version":3,"names":["AggregatorKind","DataPointType","InstrumentType","binarySearchUB","createNewEmptyCheckpoint","boundaries","counts","map","push","buckets","sum","count","hasMinMax","min","Infinity","max","HistogramAccumulation","startTime","_boundaries","_recordMinMax","_current","constructor","record","value","Number","isNaN","Math","idx","setStartTime","toPointValue","HistogramAggregator","kind","HISTOGRAM","createAccumulation","merge","previous","delta","previousValue","deltaValue","previousCounts","deltaCounts","mergedCounts","Array","length","diff","current","currentValue","currentCounts","diffedCounts","toMetricData","descriptor","aggregationTemporality","accumulationByAttributes","endTime","dataPointType","dataPoints","attributes","accumulation","pointValue","allowsNegativeValues","type","GAUGE","UP_DOWN_COUNTER","OBSERVABLE_GAUGE","OBSERVABLE_UP_DOWN_COUNTER","undefined"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/sdk-metrics/src/aggregator/Histogram.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Accumulation,\n  AccumulationRecord,\n  Aggregator,\n  AggregatorKind,\n} from './types';\nimport {\n  DataPointType,\n  HistogramMetricData,\n  InstrumentType,\n} from '../export/MetricData';\nimport { HrTime } from '@opentelemetry/api';\nimport { binarySearchUB, Maybe } from '../utils';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\n\n/**\n * Internal value type for HistogramAggregation.\n * Differs from the exported type as undefined sum/min/max complicate arithmetic\n * performed by this aggregation, but are required to be undefined in the exported types.\n */\ninterface InternalHistogram {\n  buckets: {\n    boundaries: number[];\n    counts: number[];\n  };\n  sum: number;\n  count: number;\n  hasMinMax: boolean;\n  min: number;\n  max: number;\n}\n\nfunction createNewEmptyCheckpoint(boundaries: number[]): InternalHistogram {\n  const counts = boundaries.map(() => 0);\n  counts.push(0);\n  return {\n    buckets: {\n      boundaries,\n      counts,\n    },\n    sum: 0,\n    count: 0,\n    hasMinMax: false,\n    min: Infinity,\n    max: -Infinity,\n  };\n}\n\nexport class HistogramAccumulation implements Accumulation {\n  constructor(\n    public startTime: HrTime,\n    private readonly _boundaries: number[],\n    private _recordMinMax = true,\n    private _current: InternalHistogram = createNewEmptyCheckpoint(_boundaries)\n  ) {}\n\n  record(value: number): void {\n    // NaN does not fall into any bucket, is not zero and should not be counted,\n    // NaN is never greater than max nor less than min, therefore return as there's nothing for us to do.\n    if (Number.isNaN(value)) {\n      return;\n    }\n\n    this._current.count += 1;\n    this._current.sum += value;\n\n    if (this._recordMinMax) {\n      this._current.min = Math.min(value, this._current.min);\n      this._current.max = Math.max(value, this._current.max);\n      this._current.hasMinMax = true;\n    }\n\n    const idx = binarySearchUB(this._boundaries, value);\n    this._current.buckets.counts[idx] += 1;\n  }\n\n  setStartTime(startTime: HrTime): void {\n    this.startTime = startTime;\n  }\n\n  toPointValue(): InternalHistogram {\n    return this._current;\n  }\n}\n\n/**\n * Basic aggregator which observes events and counts them in pre-defined buckets\n * and provides the total sum and count of all observations.\n */\nexport class HistogramAggregator implements Aggregator<HistogramAccumulation> {\n  public kind: AggregatorKind.HISTOGRAM = AggregatorKind.HISTOGRAM;\n\n  /**\n   * @param _boundaries sorted upper bounds of recorded values.\n   * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.\n   */\n  constructor(\n    private readonly _boundaries: number[],\n    private readonly _recordMinMax: boolean\n  ) {}\n\n  createAccumulation(startTime: HrTime) {\n    return new HistogramAccumulation(\n      startTime,\n      this._boundaries,\n      this._recordMinMax\n    );\n  }\n\n  /**\n   * Return the result of the merge of two histogram accumulations. As long as one Aggregator\n   * instance produces all Accumulations with constant boundaries we don't need to worry about\n   * merging accumulations with different boundaries.\n   */\n  merge(\n    previous: HistogramAccumulation,\n    delta: HistogramAccumulation\n  ): HistogramAccumulation {\n    const previousValue = previous.toPointValue();\n    const deltaValue = delta.toPointValue();\n\n    const previousCounts = previousValue.buckets.counts;\n    const deltaCounts = deltaValue.buckets.counts;\n\n    const mergedCounts = new Array(previousCounts.length);\n    for (let idx = 0; idx < previousCounts.length; idx++) {\n      mergedCounts[idx] = previousCounts[idx] + deltaCounts[idx];\n    }\n\n    let min = Infinity;\n    let max = -Infinity;\n\n    if (this._recordMinMax) {\n      if (previousValue.hasMinMax && deltaValue.hasMinMax) {\n        min = Math.min(previousValue.min, deltaValue.min);\n        max = Math.max(previousValue.max, deltaValue.max);\n      } else if (previousValue.hasMinMax) {\n        min = previousValue.min;\n        max = previousValue.max;\n      } else if (deltaValue.hasMinMax) {\n        min = deltaValue.min;\n        max = deltaValue.max;\n      }\n    }\n\n    return new HistogramAccumulation(\n      previous.startTime,\n      previousValue.buckets.boundaries,\n      this._recordMinMax,\n      {\n        buckets: {\n          boundaries: previousValue.buckets.boundaries,\n          counts: mergedCounts,\n        },\n        count: previousValue.count + deltaValue.count,\n        sum: previousValue.sum + deltaValue.sum,\n        hasMinMax:\n          this._recordMinMax &&\n          (previousValue.hasMinMax || deltaValue.hasMinMax),\n        min: min,\n        max: max,\n      }\n    );\n  }\n\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   */\n  diff(\n    previous: HistogramAccumulation,\n    current: HistogramAccumulation\n  ): HistogramAccumulation {\n    const previousValue = previous.toPointValue();\n    const currentValue = current.toPointValue();\n\n    const previousCounts = previousValue.buckets.counts;\n    const currentCounts = currentValue.buckets.counts;\n\n    const diffedCounts = new Array(previousCounts.length);\n    for (let idx = 0; idx < previousCounts.length; idx++) {\n      diffedCounts[idx] = currentCounts[idx] - previousCounts[idx];\n    }\n\n    return new HistogramAccumulation(\n      current.startTime,\n      previousValue.buckets.boundaries,\n      this._recordMinMax,\n      {\n        buckets: {\n          boundaries: previousValue.buckets.boundaries,\n          counts: diffedCounts,\n        },\n        count: currentValue.count - previousValue.count,\n        sum: currentValue.sum - previousValue.sum,\n        hasMinMax: false,\n        min: Infinity,\n        max: -Infinity,\n      }\n    );\n  }\n\n  toMetricData(\n    descriptor: InstrumentDescriptor,\n    aggregationTemporality: AggregationTemporality,\n    accumulationByAttributes: AccumulationRecord<HistogramAccumulation>[],\n    endTime: HrTime\n  ): Maybe<HistogramMetricData> {\n    return {\n      descriptor,\n      aggregationTemporality,\n      dataPointType: DataPointType.HISTOGRAM,\n      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {\n        const pointValue = accumulation.toPointValue();\n\n        // determine if instrument allows negative values.\n        const allowsNegativeValues =\n          descriptor.type === InstrumentType.GAUGE ||\n          descriptor.type === InstrumentType.UP_DOWN_COUNTER ||\n          descriptor.type === InstrumentType.OBSERVABLE_GAUGE ||\n          descriptor.type === InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;\n\n        return {\n          attributes,\n          startTime: accumulation.startTime,\n          endTime,\n          value: {\n            min: pointValue.hasMinMax ? pointValue.min : undefined,\n            max: pointValue.hasMinMax ? pointValue.max : undefined,\n            sum: !allowsNegativeValues ? pointValue.sum : undefined,\n            buckets: pointValue.buckets,\n            count: pointValue.count,\n          },\n        };\n      }),\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { AggregatorKind } from './types';\nimport { DataPointType } from '../export/MetricData';\nexport class SumAccumulation {\n  startTime;\n  monotonic;\n  _current;\n  reset;\n  constructor(startTime, monotonic, _current = 0, reset = false) {\n    this.startTime = startTime;\n    this.monotonic = monotonic;\n    this._current = _current;\n    this.reset = reset;\n  }\n  record(value) {\n    if (this.monotonic && value < 0) {\n      return;\n    }\n    this._current += value;\n  }\n  setStartTime(startTime) {\n    this.startTime = startTime;\n  }\n  toPointValue() {\n    return this._current;\n  }\n}\n/** Basic aggregator which calculates a Sum from individual measurements. */\nexport class SumAggregator {\n  monotonic;\n  kind = AggregatorKind.SUM;\n  constructor(monotonic) {\n    this.monotonic = monotonic;\n  }\n  createAccumulation(startTime) {\n    return new SumAccumulation(startTime, this.monotonic);\n  }\n  /**\n   * Returns the result of the merge of the given accumulations.\n   */\n  merge(previous, delta) {\n    const prevPv = previous.toPointValue();\n    const deltaPv = delta.toPointValue();\n    if (delta.reset) {\n      return new SumAccumulation(delta.startTime, this.monotonic, deltaPv, delta.reset);\n    }\n    return new SumAccumulation(previous.startTime, this.monotonic, prevPv + deltaPv);\n  }\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   */\n  diff(previous, current) {\n    const prevPv = previous.toPointValue();\n    const currPv = current.toPointValue();\n    /**\n     * If the SumAggregator is a monotonic one and the previous point value is\n     * greater than the current one, a reset is deemed to be happened.\n     * Return the current point value to prevent the value from been reset.\n     */\n    if (this.monotonic && prevPv > currPv) {\n      return new SumAccumulation(current.startTime, this.monotonic, currPv, true);\n    }\n    return new SumAccumulation(current.startTime, this.monotonic, currPv - prevPv);\n  }\n  toMetricData(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {\n    return {\n      descriptor,\n      aggregationTemporality,\n      dataPointType: DataPointType.SUM,\n      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {\n        return {\n          attributes,\n          startTime: accumulation.startTime,\n          endTime,\n          value: accumulation.toPointValue()\n        };\n      }),\n      isMonotonic: this.monotonic\n    };\n  }\n}","map":{"version":3,"names":["AggregatorKind","DataPointType","SumAccumulation","startTime","monotonic","_current","reset","constructor","record","value","setStartTime","toPointValue","SumAggregator","kind","SUM","createAccumulation","merge","previous","delta","prevPv","deltaPv","diff","current","currPv","toMetricData","descriptor","aggregationTemporality","accumulationByAttributes","endTime","dataPointType","dataPoints","map","attributes","accumulation","isMonotonic"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/sdk-metrics/src/aggregator/Sum.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Sum,\n  AggregatorKind,\n  Aggregator,\n  Accumulation,\n  AccumulationRecord,\n} from './types';\nimport { HrTime } from '@opentelemetry/api';\nimport { DataPointType, SumMetricData } from '../export/MetricData';\nimport { Maybe } from '../utils';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\n\nexport class SumAccumulation implements Accumulation {\n  constructor(\n    public startTime: HrTime,\n    public monotonic: boolean,\n    private _current: number = 0,\n    public reset = false\n  ) {}\n\n  record(value: number): void {\n    if (this.monotonic && value < 0) {\n      return;\n    }\n    this._current += value;\n  }\n\n  setStartTime(startTime: HrTime): void {\n    this.startTime = startTime;\n  }\n\n  toPointValue(): Sum {\n    return this._current;\n  }\n}\n\n/** Basic aggregator which calculates a Sum from individual measurements. */\nexport class SumAggregator implements Aggregator<SumAccumulation> {\n  public kind: AggregatorKind.SUM = AggregatorKind.SUM;\n\n  constructor(public monotonic: boolean) {}\n\n  createAccumulation(startTime: HrTime) {\n    return new SumAccumulation(startTime, this.monotonic);\n  }\n\n  /**\n   * Returns the result of the merge of the given accumulations.\n   */\n  merge(previous: SumAccumulation, delta: SumAccumulation): SumAccumulation {\n    const prevPv = previous.toPointValue();\n    const deltaPv = delta.toPointValue();\n    if (delta.reset) {\n      return new SumAccumulation(\n        delta.startTime,\n        this.monotonic,\n        deltaPv,\n        delta.reset\n      );\n    }\n    return new SumAccumulation(\n      previous.startTime,\n      this.monotonic,\n      prevPv + deltaPv\n    );\n  }\n\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   */\n  diff(previous: SumAccumulation, current: SumAccumulation): SumAccumulation {\n    const prevPv = previous.toPointValue();\n    const currPv = current.toPointValue();\n    /**\n     * If the SumAggregator is a monotonic one and the previous point value is\n     * greater than the current one, a reset is deemed to be happened.\n     * Return the current point value to prevent the value from been reset.\n     */\n    if (this.monotonic && prevPv > currPv) {\n      return new SumAccumulation(\n        current.startTime,\n        this.monotonic,\n        currPv,\n        true\n      );\n    }\n    return new SumAccumulation(\n      current.startTime,\n      this.monotonic,\n      currPv - prevPv\n    );\n  }\n\n  toMetricData(\n    descriptor: InstrumentDescriptor,\n    aggregationTemporality: AggregationTemporality,\n    accumulationByAttributes: AccumulationRecord<SumAccumulation>[],\n    endTime: HrTime\n  ): Maybe<SumMetricData> {\n    return {\n      descriptor,\n      aggregationTemporality,\n      dataPointType: DataPointType.SUM,\n      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {\n        return {\n          attributes,\n          startTime: accumulation.startTime,\n          endTime,\n          value: accumulation.toPointValue(),\n        };\n      }),\n      isMonotonic: this.monotonic,\n    };\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAgBA,SAEEA,cAAc,QAIT,SAAS;AAEhB,SAASC,aAAa,QAAuB,sBAAsB;AAKnE,OAAM,MAAOC,eAAe;EAEjBC,SAAA;EACAC,SAAA;EACCC,QAAA;EACDC,KAAA;EAJTC,YACSJ,SAAiB,EACjBC,SAAkB,EACjBC,QAAA,GAAmB,CAAC,EACrBC,KAAA,GAAQ,KAAK;IAHb,KAAAH,SAAS,GAATA,SAAS;IACT,KAAAC,SAAS,GAATA,SAAS;IACR,KAAAC,QAAQ,GAARA,QAAQ;IACT,KAAAC,KAAK,GAALA,KAAK;EACX;EAEHE,MAAMA,CAACC,KAAa;IAClB,IAAI,IAAI,CAACL,SAAS,IAAIK,KAAK,GAAG,CAAC,EAAE;MAC/B;;IAEF,IAAI,CAACJ,QAAQ,IAAII,KAAK;EACxB;EAEAC,YAAYA,CAACP,SAAiB;IAC5B,IAAI,CAACA,SAAS,GAAGA,SAAS;EAC5B;EAEAQ,YAAYA,CAAA;IACV,OAAO,IAAI,CAACN,QAAQ;EACtB;;AAGF;AACA,OAAM,MAAOO,aAAa;EAGLR,SAAA;EAFZS,IAAI,GAAuBb,cAAc,CAACc,GAAG;EAEpDP,YAAmBH,SAAkB;IAAlB,KAAAA,SAAS,GAATA,SAAS;EAAY;EAExCW,kBAAkBA,CAACZ,SAAiB;IAClC,OAAO,IAAID,eAAe,CAACC,SAAS,EAAE,IAAI,CAACC,SAAS,CAAC;EACvD;EAEA;;;EAGAY,KAAKA,CAACC,QAAyB,EAAEC,KAAsB;IACrD,MAAMC,MAAM,GAAGF,QAAQ,CAACN,YAAY,EAAE;IACtC,MAAMS,OAAO,GAAGF,KAAK,CAACP,YAAY,EAAE;IACpC,IAAIO,KAAK,CAACZ,KAAK,EAAE;MACf,OAAO,IAAIJ,eAAe,CACxBgB,KAAK,CAACf,SAAS,EACf,IAAI,CAACC,SAAS,EACdgB,OAAO,EACPF,KAAK,CAACZ,KAAK,CACZ;;IAEH,OAAO,IAAIJ,eAAe,CACxBe,QAAQ,CAACd,SAAS,EAClB,IAAI,CAACC,SAAS,EACde,MAAM,GAAGC,OAAO,CACjB;EACH;EAEA;;;EAGAC,IAAIA,CAACJ,QAAyB,EAAEK,OAAwB;IACtD,MAAMH,MAAM,GAAGF,QAAQ,CAACN,YAAY,EAAE;IACtC,MAAMY,MAAM,GAAGD,OAAO,CAACX,YAAY,EAAE;IACrC;;;;;IAKA,IAAI,IAAI,CAACP,SAAS,IAAIe,MAAM,GAAGI,MAAM,EAAE;MACrC,OAAO,IAAIrB,eAAe,CACxBoB,OAAO,CAACnB,SAAS,EACjB,IAAI,CAACC,SAAS,EACdmB,MAAM,EACN,IAAI,CACL;;IAEH,OAAO,IAAIrB,eAAe,CACxBoB,OAAO,CAACnB,SAAS,EACjB,IAAI,CAACC,SAAS,EACdmB,MAAM,GAAGJ,MAAM,CAChB;EACH;EAEAK,YAAYA,CACVC,UAAgC,EAChCC,sBAA8C,EAC9CC,wBAA+D,EAC/DC,OAAe;IAEf,OAAO;MACLH,UAAU;MACVC,sBAAsB;MACtBG,aAAa,EAAE5B,aAAa,CAACa,GAAG;MAChCgB,UAAU,EAAEH,wBAAwB,CAACI,GAAG,CAAC,CAAC,CAACC,UAAU,EAAEC,YAAY,CAAC,KAAI;QACtE,OAAO;UACLD,UAAU;UACV7B,SAAS,EAAE8B,YAAY,CAAC9B,SAAS;UACjCyB,OAAO;UACPnB,KAAK,EAAEwB,YAAY,CAACtB,YAAY;SACjC;MACH,CAAC,CAAC;MACFuB,WAAW,EAAE,IAAI,CAAC9B;KACnB;EACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
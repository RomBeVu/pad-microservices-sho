{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { AttributeHashMap } from './HashMap';\n/**\n * Internal interface.\n *\n * Provides unique reporting for each collector. Allows synchronous collection\n * of metrics and reports given temporality values.\n */\nexport class TemporalMetricProcessor {\n  _aggregator;\n  _unreportedAccumulations = new Map();\n  _reportHistory = new Map();\n  constructor(_aggregator, collectorHandles) {\n    this._aggregator = _aggregator;\n    collectorHandles.forEach(handle => {\n      this._unreportedAccumulations.set(handle, []);\n    });\n  }\n  /**\n   * Builds the {@link MetricData} streams to report against a specific MetricCollector.\n   * @param collector The information of the MetricCollector.\n   * @param collectors The registered collectors.\n   * @param instrumentDescriptor The instrumentation descriptor that these metrics generated with.\n   * @param currentAccumulations The current accumulation of metric data from instruments.\n   * @param collectionTime The current collection timestamp.\n   * @returns The {@link MetricData} points or `null`.\n   */\n  buildMetrics(collector, instrumentDescriptor, currentAccumulations, collectionTime) {\n    this._stashAccumulations(currentAccumulations);\n    const unreportedAccumulations = this._getMergedUnreportedAccumulations(collector);\n    let result = unreportedAccumulations;\n    let aggregationTemporality;\n    // Check our last report time.\n    if (this._reportHistory.has(collector)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const last = this._reportHistory.get(collector);\n      const lastCollectionTime = last.collectionTime;\n      aggregationTemporality = last.aggregationTemporality;\n      // Use aggregation temporality + instrument to determine if we do a merge or a diff of\n      // previous. We have the following four scenarios:\n      // 1. Cumulative Aggregation (temporality) + Delta recording (sync instrument).\n      //    Here we merge with our last record to get a cumulative aggregation.\n      // 2. Cumulative Aggregation + Cumulative recording (async instrument).\n      //    Cumulative records are converted to delta recording with DeltaMetricProcessor.\n      //    Here we merge with our last record to get a cumulative aggregation.\n      // 3. Delta Aggregation + Delta recording\n      //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.\n      // 4. Delta Aggregation + Cumulative recording.\n      //    Cumulative records are converted to delta recording with DeltaMetricProcessor.\n      //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.\n      if (aggregationTemporality === AggregationTemporality.CUMULATIVE) {\n        // We need to make sure the current delta recording gets merged into the previous cumulative\n        // for the next cumulative recording.\n        result = TemporalMetricProcessor.merge(last.accumulations, unreportedAccumulations, this._aggregator);\n      } else {\n        result = TemporalMetricProcessor.calibrateStartTime(last.accumulations, unreportedAccumulations, lastCollectionTime);\n      }\n    } else {\n      // Call into user code to select aggregation temporality for the instrument.\n      aggregationTemporality = collector.selectAggregationTemporality(instrumentDescriptor.type);\n    }\n    // Update last reported (cumulative) accumulation.\n    this._reportHistory.set(collector, {\n      accumulations: result,\n      collectionTime,\n      aggregationTemporality\n    });\n    const accumulationRecords = AttributesMapToAccumulationRecords(result);\n    // do not convert to metric data if there is nothing to convert.\n    if (accumulationRecords.length === 0) {\n      return undefined;\n    }\n    return this._aggregator.toMetricData(instrumentDescriptor, aggregationTemporality, accumulationRecords, /* endTime */collectionTime);\n  }\n  _stashAccumulations(currentAccumulation) {\n    const registeredCollectors = this._unreportedAccumulations.keys();\n    for (const collector of registeredCollectors) {\n      let stash = this._unreportedAccumulations.get(collector);\n      if (stash === undefined) {\n        stash = [];\n        this._unreportedAccumulations.set(collector, stash);\n      }\n      stash.push(currentAccumulation);\n    }\n  }\n  _getMergedUnreportedAccumulations(collector) {\n    let result = new AttributeHashMap();\n    const unreportedList = this._unreportedAccumulations.get(collector);\n    this._unreportedAccumulations.set(collector, []);\n    if (unreportedList === undefined) {\n      return result;\n    }\n    for (const it of unreportedList) {\n      result = TemporalMetricProcessor.merge(result, it, this._aggregator);\n    }\n    return result;\n  }\n  static merge(last, current, aggregator) {\n    const result = last;\n    const iterator = current.entries();\n    let next = iterator.next();\n    while (next.done !== true) {\n      const [key, record, hash] = next.value;\n      if (last.has(key, hash)) {\n        const lastAccumulation = last.get(key, hash);\n        // last.has() returned true, lastAccumulation is present.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const accumulation = aggregator.merge(lastAccumulation, record);\n        result.set(key, accumulation, hash);\n      } else {\n        result.set(key, record, hash);\n      }\n      next = iterator.next();\n    }\n    return result;\n  }\n  /**\n   * Calibrate the reported metric streams' startTime to lastCollectionTime. Leaves\n   * the new stream to be the initial observation time unchanged.\n   */\n  static calibrateStartTime(last, current, lastCollectionTime) {\n    for (const [key, hash] of last.keys()) {\n      const currentAccumulation = current.get(key, hash);\n      currentAccumulation?.setStartTime(lastCollectionTime);\n    }\n    return current;\n  }\n}\n// TypeScript complains about converting 3 elements tuple to AccumulationRecord<T>.\nfunction AttributesMapToAccumulationRecords(map) {\n  return Array.from(map.entries());\n}","map":{"version":3,"names":["AggregationTemporality","AttributeHashMap","TemporalMetricProcessor","_aggregator","_unreportedAccumulations","Map","_reportHistory","constructor","collectorHandles","forEach","handle","set","buildMetrics","collector","instrumentDescriptor","currentAccumulations","collectionTime","_stashAccumulations","unreportedAccumulations","_getMergedUnreportedAccumulations","result","aggregationTemporality","has","last","get","lastCollectionTime","CUMULATIVE","merge","accumulations","calibrateStartTime","selectAggregationTemporality","type","accumulationRecords","AttributesMapToAccumulationRecords","length","undefined","toMetricData","currentAccumulation","registeredCollectors","keys","stash","push","unreportedList","it","current","aggregator","iterator","entries","next","done","key","record","hash","value","lastAccumulation","accumulation","setStartTime","map","Array","from"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/sdk-metrics/src/state/TemporalMetricProcessor.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HrTime } from '@opentelemetry/api';\nimport {\n  Accumulation,\n  AccumulationRecord,\n  Aggregator,\n} from '../aggregator/types';\nimport { MetricData } from '../export/MetricData';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { Maybe } from '../utils';\nimport { MetricCollectorHandle } from './MetricCollector';\nimport { AttributeHashMap } from './HashMap';\n\n/**\n * Remembers what was presented to a specific exporter.\n */\ninterface LastReportedHistory<T extends Maybe<Accumulation>> {\n  /**\n   * The last accumulation of metric data.\n   */\n  accumulations: AttributeHashMap<T>;\n  /**\n   * The timestamp the data was reported.\n   */\n  collectionTime: HrTime;\n  /**\n   * The AggregationTemporality used to aggregate reports.\n   */\n  aggregationTemporality: AggregationTemporality;\n}\n\n/**\n * Internal interface.\n *\n * Provides unique reporting for each collector. Allows synchronous collection\n * of metrics and reports given temporality values.\n */\nexport class TemporalMetricProcessor<T extends Maybe<Accumulation>> {\n  private _unreportedAccumulations = new Map<\n    MetricCollectorHandle,\n    AttributeHashMap<T>[]\n  >();\n  private _reportHistory = new Map<\n    MetricCollectorHandle,\n    LastReportedHistory<T>\n  >();\n\n  constructor(\n    private _aggregator: Aggregator<T>,\n    collectorHandles: MetricCollectorHandle[]\n  ) {\n    collectorHandles.forEach(handle => {\n      this._unreportedAccumulations.set(handle, []);\n    });\n  }\n\n  /**\n   * Builds the {@link MetricData} streams to report against a specific MetricCollector.\n   * @param collector The information of the MetricCollector.\n   * @param collectors The registered collectors.\n   * @param instrumentDescriptor The instrumentation descriptor that these metrics generated with.\n   * @param currentAccumulations The current accumulation of metric data from instruments.\n   * @param collectionTime The current collection timestamp.\n   * @returns The {@link MetricData} points or `null`.\n   */\n  buildMetrics(\n    collector: MetricCollectorHandle,\n    instrumentDescriptor: InstrumentDescriptor,\n    currentAccumulations: AttributeHashMap<T>,\n    collectionTime: HrTime\n  ): Maybe<MetricData> {\n    this._stashAccumulations(currentAccumulations);\n    const unreportedAccumulations =\n      this._getMergedUnreportedAccumulations(collector);\n\n    let result = unreportedAccumulations;\n    let aggregationTemporality: AggregationTemporality;\n    // Check our last report time.\n    if (this._reportHistory.has(collector)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const last = this._reportHistory.get(collector)!;\n      const lastCollectionTime = last.collectionTime;\n      aggregationTemporality = last.aggregationTemporality;\n\n      // Use aggregation temporality + instrument to determine if we do a merge or a diff of\n      // previous. We have the following four scenarios:\n      // 1. Cumulative Aggregation (temporality) + Delta recording (sync instrument).\n      //    Here we merge with our last record to get a cumulative aggregation.\n      // 2. Cumulative Aggregation + Cumulative recording (async instrument).\n      //    Cumulative records are converted to delta recording with DeltaMetricProcessor.\n      //    Here we merge with our last record to get a cumulative aggregation.\n      // 3. Delta Aggregation + Delta recording\n      //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.\n      // 4. Delta Aggregation + Cumulative recording.\n      //    Cumulative records are converted to delta recording with DeltaMetricProcessor.\n      //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.\n      if (aggregationTemporality === AggregationTemporality.CUMULATIVE) {\n        // We need to make sure the current delta recording gets merged into the previous cumulative\n        // for the next cumulative recording.\n        result = TemporalMetricProcessor.merge(\n          last.accumulations,\n          unreportedAccumulations,\n          this._aggregator\n        );\n      } else {\n        result = TemporalMetricProcessor.calibrateStartTime(\n          last.accumulations,\n          unreportedAccumulations,\n          lastCollectionTime\n        );\n      }\n    } else {\n      // Call into user code to select aggregation temporality for the instrument.\n      aggregationTemporality = collector.selectAggregationTemporality(\n        instrumentDescriptor.type\n      );\n    }\n\n    // Update last reported (cumulative) accumulation.\n    this._reportHistory.set(collector, {\n      accumulations: result,\n      collectionTime,\n      aggregationTemporality,\n    });\n\n    const accumulationRecords = AttributesMapToAccumulationRecords(result);\n\n    // do not convert to metric data if there is nothing to convert.\n    if (accumulationRecords.length === 0) {\n      return undefined;\n    }\n\n    return this._aggregator.toMetricData(\n      instrumentDescriptor,\n      aggregationTemporality,\n      accumulationRecords,\n      /* endTime */ collectionTime\n    );\n  }\n\n  private _stashAccumulations(currentAccumulation: AttributeHashMap<T>) {\n    const registeredCollectors = this._unreportedAccumulations.keys();\n    for (const collector of registeredCollectors) {\n      let stash = this._unreportedAccumulations.get(collector);\n      if (stash === undefined) {\n        stash = [];\n        this._unreportedAccumulations.set(collector, stash);\n      }\n      stash.push(currentAccumulation);\n    }\n  }\n\n  private _getMergedUnreportedAccumulations(collector: MetricCollectorHandle) {\n    let result = new AttributeHashMap<T>();\n    const unreportedList = this._unreportedAccumulations.get(collector);\n    this._unreportedAccumulations.set(collector, []);\n    if (unreportedList === undefined) {\n      return result;\n    }\n    for (const it of unreportedList) {\n      result = TemporalMetricProcessor.merge(result, it, this._aggregator);\n    }\n    return result;\n  }\n\n  static merge<T extends Maybe<Accumulation>>(\n    last: AttributeHashMap<T>,\n    current: AttributeHashMap<T>,\n    aggregator: Aggregator<T>\n  ) {\n    const result = last;\n    const iterator = current.entries();\n    let next = iterator.next();\n    while (next.done !== true) {\n      const [key, record, hash] = next.value;\n      if (last.has(key, hash)) {\n        const lastAccumulation = last.get(key, hash);\n        // last.has() returned true, lastAccumulation is present.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const accumulation = aggregator.merge(lastAccumulation!, record);\n        result.set(key, accumulation, hash);\n      } else {\n        result.set(key, record, hash);\n      }\n\n      next = iterator.next();\n    }\n    return result;\n  }\n\n  /**\n   * Calibrate the reported metric streams' startTime to lastCollectionTime. Leaves\n   * the new stream to be the initial observation time unchanged.\n   */\n  static calibrateStartTime<T extends Maybe<Accumulation>>(\n    last: AttributeHashMap<T>,\n    current: AttributeHashMap<T>,\n    lastCollectionTime: HrTime\n  ) {\n    for (const [key, hash] of last.keys()) {\n      const currentAccumulation = current.get(key, hash);\n      currentAccumulation?.setStartTime(lastCollectionTime);\n    }\n    return current;\n  }\n}\n\n// TypeScript complains about converting 3 elements tuple to AccumulationRecord<T>.\nfunction AttributesMapToAccumulationRecords<T>(\n  map: AttributeHashMap<T>\n): AccumulationRecord<T>[] {\n  return Array.from(map.entries()) as unknown as AccumulationRecord<T>[];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
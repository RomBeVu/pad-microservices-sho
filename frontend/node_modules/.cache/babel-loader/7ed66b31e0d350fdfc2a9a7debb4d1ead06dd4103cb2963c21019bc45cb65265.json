{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as api from '@opentelemetry/api';\nimport { SumAggregator, DropAggregator, LastValueAggregator, HistogramAggregator, ExponentialHistogramAggregator } from '../aggregator';\nimport { InstrumentType } from '../export/MetricData';\n/**\n * The default drop aggregation.\n */\nclass DropAggregation {\n  static DEFAULT_INSTANCE = new DropAggregator();\n  createAggregator(_instrument) {\n    return DropAggregation.DEFAULT_INSTANCE;\n  }\n}\nexport { DropAggregation };\n/**\n * The default sum aggregation.\n */\nclass SumAggregation {\n  static MONOTONIC_INSTANCE = new SumAggregator(true);\n  static NON_MONOTONIC_INSTANCE = new SumAggregator(false);\n  createAggregator(instrument) {\n    switch (instrument.type) {\n      case InstrumentType.COUNTER:\n      case InstrumentType.OBSERVABLE_COUNTER:\n      case InstrumentType.HISTOGRAM:\n        {\n          return SumAggregation.MONOTONIC_INSTANCE;\n        }\n      default:\n        {\n          return SumAggregation.NON_MONOTONIC_INSTANCE;\n        }\n    }\n  }\n}\nexport { SumAggregation };\n/**\n * The default last value aggregation.\n */\nclass LastValueAggregation {\n  static DEFAULT_INSTANCE = new LastValueAggregator();\n  createAggregator(_instrument) {\n    return LastValueAggregation.DEFAULT_INSTANCE;\n  }\n}\nexport { LastValueAggregation };\n/**\n * The default histogram aggregation.\n\n */\nclass HistogramAggregation {\n  static DEFAULT_INSTANCE = new HistogramAggregator([0, 5, 10, 25, 50, 75, 100, 250, 500, 750, 1000, 2500, 5000, 7500, 10000], true);\n  createAggregator(_instrument) {\n    return HistogramAggregation.DEFAULT_INSTANCE;\n  }\n}\nexport { HistogramAggregation };\n/**\n * The explicit bucket histogram aggregation.\n */\nexport class ExplicitBucketHistogramAggregation {\n  _recordMinMax;\n  _boundaries;\n  /**\n   * @param boundaries the bucket boundaries of the histogram aggregation\n   * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.\n   */\n  constructor(boundaries, _recordMinMax = true) {\n    this._recordMinMax = _recordMinMax;\n    if (boundaries == null) {\n      throw new Error('ExplicitBucketHistogramAggregation should be created with explicit boundaries, if a single bucket histogram is required, please pass an empty array');\n    }\n    // Copy the boundaries array for modification.\n    boundaries = boundaries.concat();\n    // We need to an ordered set to be able to correctly compute count for each\n    // boundary since we'll iterate on each in order.\n    boundaries = boundaries.sort((a, b) => a - b);\n    // Remove all Infinity from the boundaries.\n    const minusInfinityIndex = boundaries.lastIndexOf(-Infinity);\n    let infinityIndex = boundaries.indexOf(Infinity);\n    if (infinityIndex === -1) {\n      infinityIndex = undefined;\n    }\n    this._boundaries = boundaries.slice(minusInfinityIndex + 1, infinityIndex);\n  }\n  createAggregator(_instrument) {\n    return new HistogramAggregator(this._boundaries, this._recordMinMax);\n  }\n}\nexport class ExponentialHistogramAggregation {\n  _maxSize;\n  _recordMinMax;\n  constructor(_maxSize = 160, _recordMinMax = true) {\n    this._maxSize = _maxSize;\n    this._recordMinMax = _recordMinMax;\n  }\n  createAggregator(_instrument) {\n    return new ExponentialHistogramAggregator(this._maxSize, this._recordMinMax);\n  }\n}\n/**\n * The default aggregation.\n */\nexport class DefaultAggregation {\n  _resolve(instrument) {\n    // cast to unknown to disable complaints on the (unreachable) fallback.\n    switch (instrument.type) {\n      case InstrumentType.COUNTER:\n      case InstrumentType.UP_DOWN_COUNTER:\n      case InstrumentType.OBSERVABLE_COUNTER:\n      case InstrumentType.OBSERVABLE_UP_DOWN_COUNTER:\n        {\n          return SUM_AGGREGATION;\n        }\n      case InstrumentType.GAUGE:\n      case InstrumentType.OBSERVABLE_GAUGE:\n        {\n          return LAST_VALUE_AGGREGATION;\n        }\n      case InstrumentType.HISTOGRAM:\n        {\n          if (instrument.advice.explicitBucketBoundaries) {\n            return new ExplicitBucketHistogramAggregation(instrument.advice.explicitBucketBoundaries);\n          }\n          return HISTOGRAM_AGGREGATION;\n        }\n    }\n    api.diag.warn(`Unable to recognize instrument type: ${instrument.type}`);\n    return DROP_AGGREGATION;\n  }\n  createAggregator(instrument) {\n    return this._resolve(instrument).createAggregator(instrument);\n  }\n}\nexport const DROP_AGGREGATION = new DropAggregation();\nexport const SUM_AGGREGATION = new SumAggregation();\nexport const LAST_VALUE_AGGREGATION = new LastValueAggregation();\nexport const HISTOGRAM_AGGREGATION = new HistogramAggregation();\nexport const EXPONENTIAL_HISTOGRAM_AGGREGATION = new ExponentialHistogramAggregation();\nexport const DEFAULT_AGGREGATION = new DefaultAggregation();","map":{"version":3,"names":["api","SumAggregator","DropAggregator","LastValueAggregator","HistogramAggregator","ExponentialHistogramAggregator","InstrumentType","DropAggregation","DEFAULT_INSTANCE","createAggregator","_instrument","SumAggregation","MONOTONIC_INSTANCE","NON_MONOTONIC_INSTANCE","instrument","type","COUNTER","OBSERVABLE_COUNTER","HISTOGRAM","LastValueAggregation","HistogramAggregation","ExplicitBucketHistogramAggregation","_recordMinMax","_boundaries","constructor","boundaries","Error","concat","sort","a","b","minusInfinityIndex","lastIndexOf","Infinity","infinityIndex","indexOf","undefined","slice","ExponentialHistogramAggregation","_maxSize","DefaultAggregation","_resolve","UP_DOWN_COUNTER","OBSERVABLE_UP_DOWN_COUNTER","SUM_AGGREGATION","GAUGE","OBSERVABLE_GAUGE","LAST_VALUE_AGGREGATION","advice","explicitBucketBoundaries","HISTOGRAM_AGGREGATION","diag","warn","DROP_AGGREGATION","EXPONENTIAL_HISTOGRAM_AGGREGATION","DEFAULT_AGGREGATION"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/sdk-metrics/src/view/Aggregation.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport {\n  Aggregator,\n  SumAggregator,\n  DropAggregator,\n  LastValueAggregator,\n  HistogramAggregator,\n  ExponentialHistogramAggregator,\n} from '../aggregator';\nimport { Accumulation } from '../aggregator/types';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\nimport { Maybe } from '../utils';\nimport { InstrumentType } from '../export/MetricData';\n\n/**\n * Configures how measurements are combined into metrics for views.\n *\n * Aggregation provides a set of built-in aggregations via static methods.\n */\nexport interface Aggregation {\n  createAggregator(\n    instrument: InstrumentDescriptor\n  ): Aggregator<Maybe<Accumulation>>;\n}\n\n/**\n * The default drop aggregation.\n */\nexport class DropAggregation implements Aggregation {\n  private static DEFAULT_INSTANCE = new DropAggregator();\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return DropAggregation.DEFAULT_INSTANCE;\n  }\n}\n\n/**\n * The default sum aggregation.\n */\nexport class SumAggregation implements Aggregation {\n  private static MONOTONIC_INSTANCE = new SumAggregator(true);\n  private static NON_MONOTONIC_INSTANCE = new SumAggregator(false);\n  createAggregator(instrument: InstrumentDescriptor) {\n    switch (instrument.type) {\n      case InstrumentType.COUNTER:\n      case InstrumentType.OBSERVABLE_COUNTER:\n      case InstrumentType.HISTOGRAM: {\n        return SumAggregation.MONOTONIC_INSTANCE;\n      }\n      default: {\n        return SumAggregation.NON_MONOTONIC_INSTANCE;\n      }\n    }\n  }\n}\n\n/**\n * The default last value aggregation.\n */\nexport class LastValueAggregation implements Aggregation {\n  private static DEFAULT_INSTANCE = new LastValueAggregator();\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return LastValueAggregation.DEFAULT_INSTANCE;\n  }\n}\n\n/**\n * The default histogram aggregation.\n\n */\nexport class HistogramAggregation implements Aggregation {\n  private static DEFAULT_INSTANCE = new HistogramAggregator(\n    [0, 5, 10, 25, 50, 75, 100, 250, 500, 750, 1000, 2500, 5000, 7500, 10000],\n    true\n  );\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return HistogramAggregation.DEFAULT_INSTANCE;\n  }\n}\n\n/**\n * The explicit bucket histogram aggregation.\n */\nexport class ExplicitBucketHistogramAggregation implements Aggregation {\n  private _boundaries: number[];\n\n  /**\n   * @param boundaries the bucket boundaries of the histogram aggregation\n   * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.\n   */\n  constructor(\n    boundaries: number[],\n    private readonly _recordMinMax = true\n  ) {\n    if (boundaries == null) {\n      throw new Error(\n        'ExplicitBucketHistogramAggregation should be created with explicit boundaries, if a single bucket histogram is required, please pass an empty array'\n      );\n    }\n    // Copy the boundaries array for modification.\n    boundaries = boundaries.concat();\n    // We need to an ordered set to be able to correctly compute count for each\n    // boundary since we'll iterate on each in order.\n    boundaries = boundaries.sort((a, b) => a - b);\n    // Remove all Infinity from the boundaries.\n    const minusInfinityIndex = boundaries.lastIndexOf(-Infinity);\n    let infinityIndex: number | undefined = boundaries.indexOf(Infinity);\n    if (infinityIndex === -1) {\n      infinityIndex = undefined;\n    }\n    this._boundaries = boundaries.slice(minusInfinityIndex + 1, infinityIndex);\n  }\n\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return new HistogramAggregator(this._boundaries, this._recordMinMax);\n  }\n}\n\nexport class ExponentialHistogramAggregation implements Aggregation {\n  constructor(\n    private readonly _maxSize: number = 160,\n    private readonly _recordMinMax = true\n  ) {}\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return new ExponentialHistogramAggregator(\n      this._maxSize,\n      this._recordMinMax\n    );\n  }\n}\n\n/**\n * The default aggregation.\n */\nexport class DefaultAggregation implements Aggregation {\n  private _resolve(instrument: InstrumentDescriptor): Aggregation {\n    // cast to unknown to disable complaints on the (unreachable) fallback.\n    switch (instrument.type as unknown) {\n      case InstrumentType.COUNTER:\n      case InstrumentType.UP_DOWN_COUNTER:\n      case InstrumentType.OBSERVABLE_COUNTER:\n      case InstrumentType.OBSERVABLE_UP_DOWN_COUNTER: {\n        return SUM_AGGREGATION;\n      }\n      case InstrumentType.GAUGE:\n      case InstrumentType.OBSERVABLE_GAUGE: {\n        return LAST_VALUE_AGGREGATION;\n      }\n      case InstrumentType.HISTOGRAM: {\n        if (instrument.advice.explicitBucketBoundaries) {\n          return new ExplicitBucketHistogramAggregation(\n            instrument.advice.explicitBucketBoundaries\n          );\n        }\n        return HISTOGRAM_AGGREGATION;\n      }\n    }\n    api.diag.warn(`Unable to recognize instrument type: ${instrument.type}`);\n    return DROP_AGGREGATION;\n  }\n\n  createAggregator(\n    instrument: InstrumentDescriptor\n  ): Aggregator<Maybe<Accumulation>> {\n    return this._resolve(instrument).createAggregator(instrument);\n  }\n}\n\nexport const DROP_AGGREGATION = new DropAggregation();\nexport const SUM_AGGREGATION = new SumAggregation();\nexport const LAST_VALUE_AGGREGATION = new LastValueAggregation();\nexport const HISTOGRAM_AGGREGATION = new HistogramAggregation();\nexport const EXPONENTIAL_HISTOGRAM_AGGREGATION =\n  new ExponentialHistogramAggregation();\nexport const DEFAULT_AGGREGATION = new DefaultAggregation();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
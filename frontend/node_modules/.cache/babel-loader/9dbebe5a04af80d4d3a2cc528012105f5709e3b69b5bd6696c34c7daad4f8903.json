{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as api from '@opentelemetry/api';\nimport { callWithTimeout, FlatMap } from '../utils';\nimport { DEFAULT_AGGREGATION_SELECTOR, DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR } from './AggregationSelector';\n/**\n * A registered reader of metrics that, when linked to a {@link MetricProducer}, offers global\n * control over metrics.\n */\nexport class MetricReader {\n  // Tracks the shutdown state.\n  // TODO: use BindOncePromise here once a new version of @opentelemetry/core is available.\n  _shutdown = false;\n  // Additional MetricProducers which will be combined with the SDK's output\n  _metricProducers;\n  // MetricProducer used by this instance which produces metrics from the SDK\n  _sdkMetricProducer;\n  _aggregationTemporalitySelector;\n  _aggregationSelector;\n  _cardinalitySelector;\n  constructor(options) {\n    this._aggregationSelector = options?.aggregationSelector ?? DEFAULT_AGGREGATION_SELECTOR;\n    this._aggregationTemporalitySelector = options?.aggregationTemporalitySelector ?? DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR;\n    this._metricProducers = options?.metricProducers ?? [];\n    this._cardinalitySelector = options?.cardinalitySelector;\n  }\n  setMetricProducer(metricProducer) {\n    if (this._sdkMetricProducer) {\n      throw new Error('MetricReader can not be bound to a MeterProvider again.');\n    }\n    this._sdkMetricProducer = metricProducer;\n    this.onInitialized();\n  }\n  selectAggregation(instrumentType) {\n    return this._aggregationSelector(instrumentType);\n  }\n  selectAggregationTemporality(instrumentType) {\n    return this._aggregationTemporalitySelector(instrumentType);\n  }\n  selectCardinalityLimit(instrumentType) {\n    return this._cardinalitySelector ? this._cardinalitySelector(instrumentType) : 2000; // default value if no selector is provided\n  }\n  /**\n   * Handle once the SDK has initialized this {@link MetricReader}\n   * Overriding this method is optional.\n   */\n  onInitialized() {\n    // Default implementation is empty.\n  }\n  async collect(options) {\n    if (this._sdkMetricProducer === undefined) {\n      throw new Error('MetricReader is not bound to a MetricProducer');\n    }\n    // Subsequent invocations to collect are not allowed. SDKs SHOULD return some failure for these calls.\n    if (this._shutdown) {\n      throw new Error('MetricReader is shutdown');\n    }\n    const [sdkCollectionResults, ...additionalCollectionResults] = await Promise.all([this._sdkMetricProducer.collect({\n      timeoutMillis: options?.timeoutMillis\n    }), ...this._metricProducers.map(producer => producer.collect({\n      timeoutMillis: options?.timeoutMillis\n    }))]);\n    // Merge the results, keeping the SDK's Resource\n    const errors = sdkCollectionResults.errors.concat(FlatMap(additionalCollectionResults, result => result.errors));\n    const resource = sdkCollectionResults.resourceMetrics.resource;\n    const scopeMetrics = sdkCollectionResults.resourceMetrics.scopeMetrics.concat(FlatMap(additionalCollectionResults, result => result.resourceMetrics.scopeMetrics));\n    return {\n      resourceMetrics: {\n        resource,\n        scopeMetrics\n      },\n      errors\n    };\n  }\n  async shutdown(options) {\n    // Do not call shutdown again if it has already been called.\n    if (this._shutdown) {\n      api.diag.error('Cannot call shutdown twice.');\n      return;\n    }\n    // No timeout if timeoutMillis is undefined or null.\n    if (options?.timeoutMillis == null) {\n      await this.onShutdown();\n    } else {\n      await callWithTimeout(this.onShutdown(), options.timeoutMillis);\n    }\n    this._shutdown = true;\n  }\n  async forceFlush(options) {\n    if (this._shutdown) {\n      api.diag.warn('Cannot forceFlush on already shutdown MetricReader.');\n      return;\n    }\n    // No timeout if timeoutMillis is undefined or null.\n    if (options?.timeoutMillis == null) {\n      await this.onForceFlush();\n      return;\n    }\n    await callWithTimeout(this.onForceFlush(), options.timeoutMillis);\n  }\n}","map":{"version":3,"names":["api","callWithTimeout","FlatMap","DEFAULT_AGGREGATION_SELECTOR","DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR","MetricReader","_shutdown","_metricProducers","_sdkMetricProducer","_aggregationTemporalitySelector","_aggregationSelector","_cardinalitySelector","constructor","options","aggregationSelector","aggregationTemporalitySelector","metricProducers","cardinalitySelector","setMetricProducer","metricProducer","Error","onInitialized","selectAggregation","instrumentType","selectAggregationTemporality","selectCardinalityLimit","collect","undefined","sdkCollectionResults","additionalCollectionResults","Promise","all","timeoutMillis","map","producer","errors","concat","result","resource","resourceMetrics","scopeMetrics","shutdown","diag","error","onShutdown","forceFlush","warn","onForceFlush"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/sdk-metrics/src/export/MetricReader.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport { AggregationTemporality } from './AggregationTemporality';\nimport { MetricProducer } from './MetricProducer';\nimport { CollectionResult, InstrumentType } from './MetricData';\nimport { callWithTimeout, FlatMap } from '../utils';\nimport {\n  CollectionOptions,\n  ForceFlushOptions,\n  ShutdownOptions,\n} from '../types';\nimport {\n  AggregationSelector,\n  AggregationTemporalitySelector,\n  DEFAULT_AGGREGATION_SELECTOR,\n  DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR,\n} from './AggregationSelector';\nimport { AggregationOption } from '../view/AggregationOption';\nimport { CardinalitySelector } from './CardinalitySelector';\n\nexport interface MetricReaderOptions {\n  /**\n   * Aggregation selector based on metric instrument types. If no views are\n   * configured for a metric instrument, a per-metric-reader aggregation is\n   * selected with this selector.\n   *\n   * <p> NOTE: the provided function MUST be pure\n   */\n  aggregationSelector?: AggregationSelector;\n  /**\n   * Aggregation temporality selector based on metric instrument types. If\n   * not configured, cumulative is used for all instruments.\n   *\n   * <p> NOTE: the provided function MUST be pure\n   */\n  aggregationTemporalitySelector?: AggregationTemporalitySelector;\n  /**\n   * Cardinality selector based on metric instrument types. If not configured,\n   * a default value is used.\n   *\n   * <p> NOTE: the provided function MUST be pure\n   */\n  cardinalitySelector?: CardinalitySelector;\n  /**\n   * **Note, this option is experimental**. Additional MetricProducers to use as a source of\n   * aggregated metric data in addition to the SDK's metric data. The resource returned by\n   * these MetricProducers is ignored; the SDK's resource will be used instead.\n   * @experimental\n   */\n  metricProducers?: MetricProducer[];\n}\n\n/**\n * Reads metrics from the SDK. Implementations MUST follow the Metric Reader Specification as well as the requirements\n * listed in this interface. Consider extending {@link MetricReader} to get a specification-compliant base implementation\n * of this interface\n */\nexport interface IMetricReader {\n  /**\n   * Set the {@link MetricProducer} used by this instance. **This should only be called once by the\n   * SDK and should be considered internal.**\n   *\n   * <p> NOTE: implementations MUST throw when called more than once\n   *\n   * @param metricProducer\n   */\n  setMetricProducer(metricProducer: MetricProducer): void;\n\n  /**\n   * Select the {@link AggregationOption} for the given {@link InstrumentType} for this\n   * reader.\n   *\n   * <p> NOTE: implementations MUST be pure\n   */\n  selectAggregation(instrumentType: InstrumentType): AggregationOption;\n\n  /**\n   * Select the {@link AggregationTemporality} for the given\n   * {@link InstrumentType} for this reader.\n   *\n   * <p> NOTE: implementations MUST be pure\n   */\n  selectAggregationTemporality(\n    instrumentType: InstrumentType\n  ): AggregationTemporality;\n\n  /**\n   * Select the cardinality limit for the given {@link InstrumentType} for this\n   * reader.\n   *\n   * <p> NOTE: implementations MUST be pure\n   */\n  selectCardinalityLimit(instrumentType: InstrumentType): number;\n\n  /**\n   * Collect all metrics from the associated {@link MetricProducer}\n   */\n  collect(options?: CollectionOptions): Promise<CollectionResult>;\n\n  /**\n   * Shuts down the metric reader, the promise will reject after the optional timeout or resolve after completion.\n   *\n   * <p> NOTE: this operation MAY continue even after the promise rejects due to a timeout.\n   * @param options options with timeout.\n   */\n  shutdown(options?: ShutdownOptions): Promise<void>;\n\n  /**\n   * Flushes metrics read by this reader, the promise will reject after the optional timeout or resolve after completion.\n   *\n   * <p> NOTE: this operation MAY continue even after the promise rejects due to a timeout.\n   * @param options options with timeout.\n   */\n  forceFlush(options?: ForceFlushOptions): Promise<void>;\n}\n\n/**\n * A registered reader of metrics that, when linked to a {@link MetricProducer}, offers global\n * control over metrics.\n */\nexport abstract class MetricReader implements IMetricReader {\n  // Tracks the shutdown state.\n  // TODO: use BindOncePromise here once a new version of @opentelemetry/core is available.\n  private _shutdown = false;\n  // Additional MetricProducers which will be combined with the SDK's output\n  private _metricProducers: MetricProducer[];\n  // MetricProducer used by this instance which produces metrics from the SDK\n  private _sdkMetricProducer?: MetricProducer;\n  private readonly _aggregationTemporalitySelector: AggregationTemporalitySelector;\n  private readonly _aggregationSelector: AggregationSelector;\n  private readonly _cardinalitySelector?: CardinalitySelector;\n\n  constructor(options?: MetricReaderOptions) {\n    this._aggregationSelector =\n      options?.aggregationSelector ?? DEFAULT_AGGREGATION_SELECTOR;\n    this._aggregationTemporalitySelector =\n      options?.aggregationTemporalitySelector ??\n      DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR;\n    this._metricProducers = options?.metricProducers ?? [];\n    this._cardinalitySelector = options?.cardinalitySelector;\n  }\n\n  setMetricProducer(metricProducer: MetricProducer) {\n    if (this._sdkMetricProducer) {\n      throw new Error(\n        'MetricReader can not be bound to a MeterProvider again.'\n      );\n    }\n    this._sdkMetricProducer = metricProducer;\n    this.onInitialized();\n  }\n\n  selectAggregation(instrumentType: InstrumentType): AggregationOption {\n    return this._aggregationSelector(instrumentType);\n  }\n\n  selectAggregationTemporality(\n    instrumentType: InstrumentType\n  ): AggregationTemporality {\n    return this._aggregationTemporalitySelector(instrumentType);\n  }\n\n  selectCardinalityLimit(instrumentType: InstrumentType): number {\n    return this._cardinalitySelector\n      ? this._cardinalitySelector(instrumentType)\n      : 2000; // default value if no selector is provided\n  }\n\n  /**\n   * Handle once the SDK has initialized this {@link MetricReader}\n   * Overriding this method is optional.\n   */\n  protected onInitialized(): void {\n    // Default implementation is empty.\n  }\n\n  /**\n   * Handle a shutdown signal by the SDK.\n   *\n   * <p> For push exporters, this should shut down any intervals and close any open connections.\n   * @protected\n   */\n  protected abstract onShutdown(): Promise<void>;\n\n  /**\n   * Handle a force flush signal by the SDK.\n   *\n   * <p> In all scenarios metrics should be collected via {@link collect()}.\n   * <p> For push exporters, this should collect and report metrics.\n   * @protected\n   */\n  protected abstract onForceFlush(): Promise<void>;\n\n  async collect(options?: CollectionOptions): Promise<CollectionResult> {\n    if (this._sdkMetricProducer === undefined) {\n      throw new Error('MetricReader is not bound to a MetricProducer');\n    }\n\n    // Subsequent invocations to collect are not allowed. SDKs SHOULD return some failure for these calls.\n    if (this._shutdown) {\n      throw new Error('MetricReader is shutdown');\n    }\n\n    const [sdkCollectionResults, ...additionalCollectionResults] =\n      await Promise.all([\n        this._sdkMetricProducer.collect({\n          timeoutMillis: options?.timeoutMillis,\n        }),\n        ...this._metricProducers.map(producer =>\n          producer.collect({\n            timeoutMillis: options?.timeoutMillis,\n          })\n        ),\n      ]);\n\n    // Merge the results, keeping the SDK's Resource\n    const errors = sdkCollectionResults.errors.concat(\n      FlatMap(additionalCollectionResults, result => result.errors)\n    );\n    const resource = sdkCollectionResults.resourceMetrics.resource;\n    const scopeMetrics =\n      sdkCollectionResults.resourceMetrics.scopeMetrics.concat(\n        FlatMap(\n          additionalCollectionResults,\n          result => result.resourceMetrics.scopeMetrics\n        )\n      );\n    return {\n      resourceMetrics: {\n        resource,\n        scopeMetrics,\n      },\n      errors,\n    };\n  }\n\n  async shutdown(options?: ShutdownOptions): Promise<void> {\n    // Do not call shutdown again if it has already been called.\n    if (this._shutdown) {\n      api.diag.error('Cannot call shutdown twice.');\n      return;\n    }\n\n    // No timeout if timeoutMillis is undefined or null.\n    if (options?.timeoutMillis == null) {\n      await this.onShutdown();\n    } else {\n      await callWithTimeout(this.onShutdown(), options.timeoutMillis);\n    }\n\n    this._shutdown = true;\n  }\n\n  async forceFlush(options?: ForceFlushOptions): Promise<void> {\n    if (this._shutdown) {\n      api.diag.warn('Cannot forceFlush on already shutdown MetricReader.');\n      return;\n    }\n\n    // No timeout if timeoutMillis is undefined or null.\n    if (options?.timeoutMillis == null) {\n      await this.onForceFlush();\n      return;\n    }\n\n    await callWithTimeout(this.onForceFlush(), options.timeoutMillis);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
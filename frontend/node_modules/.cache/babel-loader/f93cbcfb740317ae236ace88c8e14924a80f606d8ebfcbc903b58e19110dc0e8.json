{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport class Buckets {\n  backing;\n  indexBase;\n  indexStart;\n  indexEnd;\n  /**\n   * The term index refers to the number of the exponential histogram bucket\n   * used to determine its boundaries. The lower boundary of a bucket is\n   * determined by base ** index and the upper boundary of a bucket is\n   * determined by base ** (index + 1). index values are signed to account\n   * for values less than or equal to 1.\n   *\n   * indexBase is the index of the 0th position in the\n   * backing array, i.e., backing[0] is the count\n   * in the bucket with index `indexBase`.\n   *\n   * indexStart is the smallest index value represented\n   * in the backing array.\n   *\n   * indexEnd is the largest index value represented in\n   * the backing array.\n   */\n  constructor(backing = new BucketsBacking(), indexBase = 0, indexStart = 0, indexEnd = 0) {\n    this.backing = backing;\n    this.indexBase = indexBase;\n    this.indexStart = indexStart;\n    this.indexEnd = indexEnd;\n  }\n  /**\n   * Offset is the bucket index of the smallest entry in the counts array\n   * @returns {number}\n   */\n  get offset() {\n    return this.indexStart;\n  }\n  /**\n   * Buckets is a view into the backing array.\n   * @returns {number}\n   */\n  get length() {\n    if (this.backing.length === 0) {\n      return 0;\n    }\n    if (this.indexEnd === this.indexStart && this.at(0) === 0) {\n      return 0;\n    }\n    return this.indexEnd - this.indexStart + 1;\n  }\n  /**\n   * An array of counts, where count[i] carries the count\n   * of the bucket at index (offset+i).  count[i] is the count of\n   * values greater than base^(offset+i) and less than or equal to\n   * base^(offset+i+1).\n   * @returns {number} The logical counts based on the backing array\n   */\n  counts() {\n    return Array.from({\n      length: this.length\n    }, (_, i) => this.at(i));\n  }\n  /**\n   * At returns the count of the bucket at a position in the logical\n   * array of counts.\n   * @param position\n   * @returns {number}\n   */\n  at(position) {\n    const bias = this.indexBase - this.indexStart;\n    if (position < bias) {\n      position += this.backing.length;\n    }\n    position -= bias;\n    return this.backing.countAt(position);\n  }\n  /**\n   * incrementBucket increments the backing array index by `increment`\n   * @param bucketIndex\n   * @param increment\n   */\n  incrementBucket(bucketIndex, increment) {\n    this.backing.increment(bucketIndex, increment);\n  }\n  /**\n   * decrementBucket decrements the backing array index by `decrement`\n   * if decrement is greater than the current value, it's set to 0.\n   * @param bucketIndex\n   * @param decrement\n   */\n  decrementBucket(bucketIndex, decrement) {\n    this.backing.decrement(bucketIndex, decrement);\n  }\n  /**\n   * trim removes leading and / or trailing zero buckets (which can occur\n   * after diffing two histos) and rotates the backing array so that the\n   * smallest non-zero index is in the 0th position of the backing array\n   */\n  trim() {\n    for (let i = 0; i < this.length; i++) {\n      if (this.at(i) !== 0) {\n        this.indexStart += i;\n        break;\n      } else if (i === this.length - 1) {\n        //the entire array is zeroed out\n        this.indexStart = this.indexEnd = this.indexBase = 0;\n        return;\n      }\n    }\n    for (let i = this.length - 1; i >= 0; i--) {\n      if (this.at(i) !== 0) {\n        this.indexEnd -= this.length - i - 1;\n        break;\n      }\n    }\n    this._rotate();\n  }\n  /**\n   * downscale first rotates, then collapses 2**`by`-to-1 buckets.\n   * @param by\n   */\n  downscale(by) {\n    this._rotate();\n    const size = 1 + this.indexEnd - this.indexStart;\n    const each = 1 << by;\n    let inpos = 0;\n    let outpos = 0;\n    for (let pos = this.indexStart; pos <= this.indexEnd;) {\n      let mod = pos % each;\n      if (mod < 0) {\n        mod += each;\n      }\n      for (let i = mod; i < each && inpos < size; i++) {\n        this._relocateBucket(outpos, inpos);\n        inpos++;\n        pos++;\n      }\n      outpos++;\n    }\n    this.indexStart >>= by;\n    this.indexEnd >>= by;\n    this.indexBase = this.indexStart;\n  }\n  /**\n   * Clone returns a deep copy of Buckets\n   * @returns {Buckets}\n   */\n  clone() {\n    return new Buckets(this.backing.clone(), this.indexBase, this.indexStart, this.indexEnd);\n  }\n  /**\n   * _rotate shifts the backing array contents so that indexStart ==\n   * indexBase to simplify the downscale logic.\n   */\n  _rotate() {\n    const bias = this.indexBase - this.indexStart;\n    if (bias === 0) {\n      return;\n    } else if (bias > 0) {\n      this.backing.reverse(0, this.backing.length);\n      this.backing.reverse(0, bias);\n      this.backing.reverse(bias, this.backing.length);\n    } else {\n      // negative bias, this can happen when diffing two histograms\n      this.backing.reverse(0, this.backing.length);\n      this.backing.reverse(0, this.backing.length + bias);\n    }\n    this.indexBase = this.indexStart;\n  }\n  /**\n   * _relocateBucket adds the count in counts[src] to counts[dest] and\n   * resets count[src] to zero.\n   */\n  _relocateBucket(dest, src) {\n    if (dest === src) {\n      return;\n    }\n    this.incrementBucket(dest, this.backing.emptyBucket(src));\n  }\n}\n/**\n * BucketsBacking holds the raw buckets and some utility methods to\n * manage them.\n */\nclass BucketsBacking {\n  _counts;\n  constructor(_counts = [0]) {\n    this._counts = _counts;\n  }\n  /**\n   * length returns the physical size of the backing array, which\n   * is >= buckets.length()\n   */\n  get length() {\n    return this._counts.length;\n  }\n  /**\n   * countAt returns the count in a specific bucket\n   */\n  countAt(pos) {\n    return this._counts[pos];\n  }\n  /**\n   * growTo grows a backing array and copies old entries\n   * into their correct new positions.\n   */\n  growTo(newSize, oldPositiveLimit, newPositiveLimit) {\n    const tmp = new Array(newSize).fill(0);\n    tmp.splice(newPositiveLimit, this._counts.length - oldPositiveLimit, ...this._counts.slice(oldPositiveLimit));\n    tmp.splice(0, oldPositiveLimit, ...this._counts.slice(0, oldPositiveLimit));\n    this._counts = tmp;\n  }\n  /**\n   * reverse the items in the backing array in the range [from, limit).\n   */\n  reverse(from, limit) {\n    const num = Math.floor((from + limit) / 2) - from;\n    for (let i = 0; i < num; i++) {\n      const tmp = this._counts[from + i];\n      this._counts[from + i] = this._counts[limit - i - 1];\n      this._counts[limit - i - 1] = tmp;\n    }\n  }\n  /**\n   * emptyBucket empties the count from a bucket, for\n   * moving into another.\n   */\n  emptyBucket(src) {\n    const tmp = this._counts[src];\n    this._counts[src] = 0;\n    return tmp;\n  }\n  /**\n   * increments a bucket by `increment`\n   */\n  increment(bucketIndex, increment) {\n    this._counts[bucketIndex] += increment;\n  }\n  /**\n   * decrements a bucket by `decrement`\n   */\n  decrement(bucketIndex, decrement) {\n    if (this._counts[bucketIndex] >= decrement) {\n      this._counts[bucketIndex] -= decrement;\n    } else {\n      // this should not happen, but we're being defensive against\n      // negative counts.\n      this._counts[bucketIndex] = 0;\n    }\n  }\n  /**\n   * clone returns a deep copy of BucketsBacking\n   */\n  clone() {\n    return new BucketsBacking([...this._counts]);\n  }\n}","map":{"version":3,"names":["Buckets","backing","indexBase","indexStart","indexEnd","constructor","BucketsBacking","offset","length","at","counts","Array","from","_","i","position","bias","countAt","incrementBucket","bucketIndex","increment","decrementBucket","decrement","trim","_rotate","downscale","by","size","each","inpos","outpos","pos","mod","_relocateBucket","clone","reverse","dest","src","emptyBucket","_counts","growTo","newSize","oldPositiveLimit","newPositiveLimit","tmp","fill","splice","slice","limit","num","Math","floor"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/sdk-metrics/src/aggregator/exponential-histogram/Buckets.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport class Buckets {\n  /**\n   * The term index refers to the number of the exponential histogram bucket\n   * used to determine its boundaries. The lower boundary of a bucket is\n   * determined by base ** index and the upper boundary of a bucket is\n   * determined by base ** (index + 1). index values are signed to account\n   * for values less than or equal to 1.\n   *\n   * indexBase is the index of the 0th position in the\n   * backing array, i.e., backing[0] is the count\n   * in the bucket with index `indexBase`.\n   *\n   * indexStart is the smallest index value represented\n   * in the backing array.\n   *\n   * indexEnd is the largest index value represented in\n   * the backing array.\n   */\n  constructor(\n    public backing = new BucketsBacking(),\n    public indexBase = 0,\n    public indexStart = 0,\n    public indexEnd = 0\n  ) {}\n\n  /**\n   * Offset is the bucket index of the smallest entry in the counts array\n   * @returns {number}\n   */\n  get offset(): number {\n    return this.indexStart;\n  }\n\n  /**\n   * Buckets is a view into the backing array.\n   * @returns {number}\n   */\n  get length(): number {\n    if (this.backing.length === 0) {\n      return 0;\n    }\n\n    if (this.indexEnd === this.indexStart && this.at(0) === 0) {\n      return 0;\n    }\n\n    return this.indexEnd - this.indexStart + 1;\n  }\n\n  /**\n   * An array of counts, where count[i] carries the count\n   * of the bucket at index (offset+i).  count[i] is the count of\n   * values greater than base^(offset+i) and less than or equal to\n   * base^(offset+i+1).\n   * @returns {number} The logical counts based on the backing array\n   */\n  counts(): number[] {\n    return Array.from({ length: this.length }, (_, i) => this.at(i));\n  }\n\n  /**\n   * At returns the count of the bucket at a position in the logical\n   * array of counts.\n   * @param position\n   * @returns {number}\n   */\n  at(position: number): number {\n    const bias = this.indexBase - this.indexStart;\n    if (position < bias) {\n      position += this.backing.length;\n    }\n\n    position -= bias;\n    return this.backing.countAt(position);\n  }\n\n  /**\n   * incrementBucket increments the backing array index by `increment`\n   * @param bucketIndex\n   * @param increment\n   */\n  incrementBucket(bucketIndex: number, increment: number) {\n    this.backing.increment(bucketIndex, increment);\n  }\n\n  /**\n   * decrementBucket decrements the backing array index by `decrement`\n   * if decrement is greater than the current value, it's set to 0.\n   * @param bucketIndex\n   * @param decrement\n   */\n  decrementBucket(bucketIndex: number, decrement: number) {\n    this.backing.decrement(bucketIndex, decrement);\n  }\n\n  /**\n   * trim removes leading and / or trailing zero buckets (which can occur\n   * after diffing two histos) and rotates the backing array so that the\n   * smallest non-zero index is in the 0th position of the backing array\n   */\n  trim() {\n    for (let i = 0; i < this.length; i++) {\n      if (this.at(i) !== 0) {\n        this.indexStart += i;\n        break;\n      } else if (i === this.length - 1) {\n        //the entire array is zeroed out\n        this.indexStart = this.indexEnd = this.indexBase = 0;\n        return;\n      }\n    }\n\n    for (let i = this.length - 1; i >= 0; i--) {\n      if (this.at(i) !== 0) {\n        this.indexEnd -= this.length - i - 1;\n        break;\n      }\n    }\n\n    this._rotate();\n  }\n\n  /**\n   * downscale first rotates, then collapses 2**`by`-to-1 buckets.\n   * @param by\n   */\n  downscale(by: number) {\n    this._rotate();\n\n    const size = 1 + this.indexEnd - this.indexStart;\n    const each = 1 << by;\n    let inpos = 0;\n    let outpos = 0;\n\n    for (let pos = this.indexStart; pos <= this.indexEnd; ) {\n      let mod = pos % each;\n      if (mod < 0) {\n        mod += each;\n      }\n      for (let i = mod; i < each && inpos < size; i++) {\n        this._relocateBucket(outpos, inpos);\n        inpos++;\n        pos++;\n      }\n      outpos++;\n    }\n\n    this.indexStart >>= by;\n    this.indexEnd >>= by;\n    this.indexBase = this.indexStart;\n  }\n\n  /**\n   * Clone returns a deep copy of Buckets\n   * @returns {Buckets}\n   */\n  clone(): Buckets {\n    return new Buckets(\n      this.backing.clone(),\n      this.indexBase,\n      this.indexStart,\n      this.indexEnd\n    );\n  }\n\n  /**\n   * _rotate shifts the backing array contents so that indexStart ==\n   * indexBase to simplify the downscale logic.\n   */\n  private _rotate() {\n    const bias = this.indexBase - this.indexStart;\n\n    if (bias === 0) {\n      return;\n    } else if (bias > 0) {\n      this.backing.reverse(0, this.backing.length);\n      this.backing.reverse(0, bias);\n      this.backing.reverse(bias, this.backing.length);\n    } else {\n      // negative bias, this can happen when diffing two histograms\n      this.backing.reverse(0, this.backing.length);\n      this.backing.reverse(0, this.backing.length + bias);\n    }\n    this.indexBase = this.indexStart;\n  }\n\n  /**\n   * _relocateBucket adds the count in counts[src] to counts[dest] and\n   * resets count[src] to zero.\n   */\n  private _relocateBucket(dest: number, src: number) {\n    if (dest === src) {\n      return;\n    }\n    this.incrementBucket(dest, this.backing.emptyBucket(src));\n  }\n}\n\n/**\n * BucketsBacking holds the raw buckets and some utility methods to\n * manage them.\n */\nclass BucketsBacking {\n  constructor(private _counts = [0]) {}\n\n  /**\n   * length returns the physical size of the backing array, which\n   * is >= buckets.length()\n   */\n  get length(): number {\n    return this._counts.length;\n  }\n\n  /**\n   * countAt returns the count in a specific bucket\n   */\n  countAt(pos: number): number {\n    return this._counts[pos];\n  }\n\n  /**\n   * growTo grows a backing array and copies old entries\n   * into their correct new positions.\n   */\n  growTo(newSize: number, oldPositiveLimit: number, newPositiveLimit: number) {\n    const tmp = new Array<number>(newSize).fill(0);\n    tmp.splice(\n      newPositiveLimit,\n      this._counts.length - oldPositiveLimit,\n      ...this._counts.slice(oldPositiveLimit)\n    );\n    tmp.splice(0, oldPositiveLimit, ...this._counts.slice(0, oldPositiveLimit));\n    this._counts = tmp;\n  }\n\n  /**\n   * reverse the items in the backing array in the range [from, limit).\n   */\n  reverse(from: number, limit: number) {\n    const num = Math.floor((from + limit) / 2) - from;\n    for (let i = 0; i < num; i++) {\n      const tmp = this._counts[from + i];\n      this._counts[from + i] = this._counts[limit - i - 1];\n      this._counts[limit - i - 1] = tmp;\n    }\n  }\n\n  /**\n   * emptyBucket empties the count from a bucket, for\n   * moving into another.\n   */\n  emptyBucket(src: number): number {\n    const tmp = this._counts[src];\n    this._counts[src] = 0;\n    return tmp;\n  }\n\n  /**\n   * increments a bucket by `increment`\n   */\n  increment(bucketIndex: number, increment: number) {\n    this._counts[bucketIndex] += increment;\n  }\n\n  /**\n   * decrements a bucket by `decrement`\n   */\n  decrement(bucketIndex: number, decrement: number) {\n    if (this._counts[bucketIndex] >= decrement) {\n      this._counts[bucketIndex] -= decrement;\n    } else {\n      // this should not happen, but we're being defensive against\n      // negative counts.\n      this._counts[bucketIndex] = 0;\n    }\n  }\n\n  /**\n   * clone returns a deep copy of BucketsBacking\n   */\n  clone(): BucketsBacking {\n    return new BucketsBacking([...this._counts]);\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAeA,OAAM,MAAOA,OAAO;EAmBTC,OAAA;EACAC,SAAA;EACAC,UAAA;EACAC,QAAA;EArBT;;;;;;;;;;;;;;;;;EAiBAC,YACSJ,OAAA,GAAU,IAAIK,cAAc,EAAE,EAC9BJ,SAAA,GAAY,CAAC,EACbC,UAAA,GAAa,CAAC,EACdC,QAAA,GAAW,CAAC;IAHZ,KAAAH,OAAO,GAAPA,OAAO;IACP,KAAAC,SAAS,GAATA,SAAS;IACT,KAAAC,UAAU,GAAVA,UAAU;IACV,KAAAC,QAAQ,GAARA,QAAQ;EACd;EAEH;;;;EAIA,IAAIG,MAAMA,CAAA;IACR,OAAO,IAAI,CAACJ,UAAU;EACxB;EAEA;;;;EAIA,IAAIK,MAAMA,CAAA;IACR,IAAI,IAAI,CAACP,OAAO,CAACO,MAAM,KAAK,CAAC,EAAE;MAC7B,OAAO,CAAC;;IAGV,IAAI,IAAI,CAACJ,QAAQ,KAAK,IAAI,CAACD,UAAU,IAAI,IAAI,CAACM,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;MACzD,OAAO,CAAC;;IAGV,OAAO,IAAI,CAACL,QAAQ,GAAG,IAAI,CAACD,UAAU,GAAG,CAAC;EAC5C;EAEA;;;;;;;EAOAO,MAAMA,CAAA;IACJ,OAAOC,KAAK,CAACC,IAAI,CAAC;MAAEJ,MAAM,EAAE,IAAI,CAACA;IAAM,CAAE,EAAE,CAACK,CAAC,EAAEC,CAAC,KAAK,IAAI,CAACL,EAAE,CAACK,CAAC,CAAC,CAAC;EAClE;EAEA;;;;;;EAMAL,EAAEA,CAACM,QAAgB;IACjB,MAAMC,IAAI,GAAG,IAAI,CAACd,SAAS,GAAG,IAAI,CAACC,UAAU;IAC7C,IAAIY,QAAQ,GAAGC,IAAI,EAAE;MACnBD,QAAQ,IAAI,IAAI,CAACd,OAAO,CAACO,MAAM;;IAGjCO,QAAQ,IAAIC,IAAI;IAChB,OAAO,IAAI,CAACf,OAAO,CAACgB,OAAO,CAACF,QAAQ,CAAC;EACvC;EAEA;;;;;EAKAG,eAAeA,CAACC,WAAmB,EAAEC,SAAiB;IACpD,IAAI,CAACnB,OAAO,CAACmB,SAAS,CAACD,WAAW,EAAEC,SAAS,CAAC;EAChD;EAEA;;;;;;EAMAC,eAAeA,CAACF,WAAmB,EAAEG,SAAiB;IACpD,IAAI,CAACrB,OAAO,CAACqB,SAAS,CAACH,WAAW,EAAEG,SAAS,CAAC;EAChD;EAEA;;;;;EAKAC,IAAIA,CAAA;IACF,KAAK,IAAIT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACN,MAAM,EAAEM,CAAC,EAAE,EAAE;MACpC,IAAI,IAAI,CAACL,EAAE,CAACK,CAAC,CAAC,KAAK,CAAC,EAAE;QACpB,IAAI,CAACX,UAAU,IAAIW,CAAC;QACpB;OACD,MAAM,IAAIA,CAAC,KAAK,IAAI,CAACN,MAAM,GAAG,CAAC,EAAE;QAChC;QACA,IAAI,CAACL,UAAU,GAAG,IAAI,CAACC,QAAQ,GAAG,IAAI,CAACF,SAAS,GAAG,CAAC;QACpD;;;IAIJ,KAAK,IAAIY,CAAC,GAAG,IAAI,CAACN,MAAM,GAAG,CAAC,EAAEM,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MACzC,IAAI,IAAI,CAACL,EAAE,CAACK,CAAC,CAAC,KAAK,CAAC,EAAE;QACpB,IAAI,CAACV,QAAQ,IAAI,IAAI,CAACI,MAAM,GAAGM,CAAC,GAAG,CAAC;QACpC;;;IAIJ,IAAI,CAACU,OAAO,EAAE;EAChB;EAEA;;;;EAIAC,SAASA,CAACC,EAAU;IAClB,IAAI,CAACF,OAAO,EAAE;IAEd,MAAMG,IAAI,GAAG,CAAC,GAAG,IAAI,CAACvB,QAAQ,GAAG,IAAI,CAACD,UAAU;IAChD,MAAMyB,IAAI,GAAG,CAAC,IAAIF,EAAE;IACpB,IAAIG,KAAK,GAAG,CAAC;IACb,IAAIC,MAAM,GAAG,CAAC;IAEd,KAAK,IAAIC,GAAG,GAAG,IAAI,CAAC5B,UAAU,EAAE4B,GAAG,IAAI,IAAI,CAAC3B,QAAQ,GAAI;MACtD,IAAI4B,GAAG,GAAGD,GAAG,GAAGH,IAAI;MACpB,IAAII,GAAG,GAAG,CAAC,EAAE;QACXA,GAAG,IAAIJ,IAAI;;MAEb,KAAK,IAAId,CAAC,GAAGkB,GAAG,EAAElB,CAAC,GAAGc,IAAI,IAAIC,KAAK,GAAGF,IAAI,EAAEb,CAAC,EAAE,EAAE;QAC/C,IAAI,CAACmB,eAAe,CAACH,MAAM,EAAED,KAAK,CAAC;QACnCA,KAAK,EAAE;QACPE,GAAG,EAAE;;MAEPD,MAAM,EAAE;;IAGV,IAAI,CAAC3B,UAAU,KAAKuB,EAAE;IACtB,IAAI,CAACtB,QAAQ,KAAKsB,EAAE;IACpB,IAAI,CAACxB,SAAS,GAAG,IAAI,CAACC,UAAU;EAClC;EAEA;;;;EAIA+B,KAAKA,CAAA;IACH,OAAO,IAAIlC,OAAO,CAChB,IAAI,CAACC,OAAO,CAACiC,KAAK,EAAE,EACpB,IAAI,CAAChC,SAAS,EACd,IAAI,CAACC,UAAU,EACf,IAAI,CAACC,QAAQ,CACd;EACH;EAEA;;;;EAIQoB,OAAOA,CAAA;IACb,MAAMR,IAAI,GAAG,IAAI,CAACd,SAAS,GAAG,IAAI,CAACC,UAAU;IAE7C,IAAIa,IAAI,KAAK,CAAC,EAAE;MACd;KACD,MAAM,IAAIA,IAAI,GAAG,CAAC,EAAE;MACnB,IAAI,CAACf,OAAO,CAACkC,OAAO,CAAC,CAAC,EAAE,IAAI,CAAClC,OAAO,CAACO,MAAM,CAAC;MAC5C,IAAI,CAACP,OAAO,CAACkC,OAAO,CAAC,CAAC,EAAEnB,IAAI,CAAC;MAC7B,IAAI,CAACf,OAAO,CAACkC,OAAO,CAACnB,IAAI,EAAE,IAAI,CAACf,OAAO,CAACO,MAAM,CAAC;KAChD,MAAM;MACL;MACA,IAAI,CAACP,OAAO,CAACkC,OAAO,CAAC,CAAC,EAAE,IAAI,CAAClC,OAAO,CAACO,MAAM,CAAC;MAC5C,IAAI,CAACP,OAAO,CAACkC,OAAO,CAAC,CAAC,EAAE,IAAI,CAAClC,OAAO,CAACO,MAAM,GAAGQ,IAAI,CAAC;;IAErD,IAAI,CAACd,SAAS,GAAG,IAAI,CAACC,UAAU;EAClC;EAEA;;;;EAIQ8B,eAAeA,CAACG,IAAY,EAAEC,GAAW;IAC/C,IAAID,IAAI,KAAKC,GAAG,EAAE;MAChB;;IAEF,IAAI,CAACnB,eAAe,CAACkB,IAAI,EAAE,IAAI,CAACnC,OAAO,CAACqC,WAAW,CAACD,GAAG,CAAC,CAAC;EAC3D;;AAGF;;;;AAIA,MAAM/B,cAAc;EACEiC,OAAA;EAApBlC,YAAoBkC,OAAA,GAAU,CAAC,CAAC,CAAC;IAAb,KAAAA,OAAO,GAAPA,OAAO;EAAS;EAEpC;;;;EAIA,IAAI/B,MAAMA,CAAA;IACR,OAAO,IAAI,CAAC+B,OAAO,CAAC/B,MAAM;EAC5B;EAEA;;;EAGAS,OAAOA,CAACc,GAAW;IACjB,OAAO,IAAI,CAACQ,OAAO,CAACR,GAAG,CAAC;EAC1B;EAEA;;;;EAIAS,MAAMA,CAACC,OAAe,EAAEC,gBAAwB,EAAEC,gBAAwB;IACxE,MAAMC,GAAG,GAAG,IAAIjC,KAAK,CAAS8B,OAAO,CAAC,CAACI,IAAI,CAAC,CAAC,CAAC;IAC9CD,GAAG,CAACE,MAAM,CACRH,gBAAgB,EAChB,IAAI,CAACJ,OAAO,CAAC/B,MAAM,GAAGkC,gBAAgB,EACtC,GAAG,IAAI,CAACH,OAAO,CAACQ,KAAK,CAACL,gBAAgB,CAAC,CACxC;IACDE,GAAG,CAACE,MAAM,CAAC,CAAC,EAAEJ,gBAAgB,EAAE,GAAG,IAAI,CAACH,OAAO,CAACQ,KAAK,CAAC,CAAC,EAAEL,gBAAgB,CAAC,CAAC;IAC3E,IAAI,CAACH,OAAO,GAAGK,GAAG;EACpB;EAEA;;;EAGAT,OAAOA,CAACvB,IAAY,EAAEoC,KAAa;IACjC,MAAMC,GAAG,GAAGC,IAAI,CAACC,KAAK,CAAC,CAACvC,IAAI,GAAGoC,KAAK,IAAI,CAAC,CAAC,GAAGpC,IAAI;IACjD,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmC,GAAG,EAAEnC,CAAC,EAAE,EAAE;MAC5B,MAAM8B,GAAG,GAAG,IAAI,CAACL,OAAO,CAAC3B,IAAI,GAAGE,CAAC,CAAC;MAClC,IAAI,CAACyB,OAAO,CAAC3B,IAAI,GAAGE,CAAC,CAAC,GAAG,IAAI,CAACyB,OAAO,CAACS,KAAK,GAAGlC,CAAC,GAAG,CAAC,CAAC;MACpD,IAAI,CAACyB,OAAO,CAACS,KAAK,GAAGlC,CAAC,GAAG,CAAC,CAAC,GAAG8B,GAAG;;EAErC;EAEA;;;;EAIAN,WAAWA,CAACD,GAAW;IACrB,MAAMO,GAAG,GAAG,IAAI,CAACL,OAAO,CAACF,GAAG,CAAC;IAC7B,IAAI,CAACE,OAAO,CAACF,GAAG,CAAC,GAAG,CAAC;IACrB,OAAOO,GAAG;EACZ;EAEA;;;EAGAxB,SAASA,CAACD,WAAmB,EAAEC,SAAiB;IAC9C,IAAI,CAACmB,OAAO,CAACpB,WAAW,CAAC,IAAIC,SAAS;EACxC;EAEA;;;EAGAE,SAASA,CAACH,WAAmB,EAAEG,SAAiB;IAC9C,IAAI,IAAI,CAACiB,OAAO,CAACpB,WAAW,CAAC,IAAIG,SAAS,EAAE;MAC1C,IAAI,CAACiB,OAAO,CAACpB,WAAW,CAAC,IAAIG,SAAS;KACvC,MAAM;MACL;MACA;MACA,IAAI,CAACiB,OAAO,CAACpB,WAAW,CAAC,GAAG,CAAC;;EAEjC;EAEA;;;EAGAe,KAAKA,CAAA;IACH,OAAO,IAAI5B,cAAc,CAAC,CAAC,GAAG,IAAI,CAACiC,OAAO,CAAC,CAAC;EAC9C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
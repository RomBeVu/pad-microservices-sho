{"ast":null,"code":"import { ValueType } from '@opentelemetry/api';\nimport { AggregationTemporality, DataPointType } from '@opentelemetry/sdk-metrics';\nimport { EAggregationTemporality } from './internal-types';\nimport { getOtlpEncoder } from '../common/utils';\nimport { createInstrumentationScope, createResource, toAttributes } from '../common/internal';\nexport function toResourceMetrics(resourceMetrics, options) {\n  const encoder = getOtlpEncoder(options);\n  return {\n    resource: createResource(resourceMetrics.resource),\n    schemaUrl: undefined,\n    scopeMetrics: toScopeMetrics(resourceMetrics.scopeMetrics, encoder)\n  };\n}\nexport function toScopeMetrics(scopeMetrics, encoder) {\n  return Array.from(scopeMetrics.map(metrics => ({\n    scope: createInstrumentationScope(metrics.scope),\n    metrics: metrics.metrics.map(metricData => toMetric(metricData, encoder)),\n    schemaUrl: metrics.scope.schemaUrl\n  })));\n}\nexport function toMetric(metricData, encoder) {\n  const out = {\n    name: metricData.descriptor.name,\n    description: metricData.descriptor.description,\n    unit: metricData.descriptor.unit\n  };\n  const aggregationTemporality = toAggregationTemporality(metricData.aggregationTemporality);\n  switch (metricData.dataPointType) {\n    case DataPointType.SUM:\n      out.sum = {\n        aggregationTemporality,\n        isMonotonic: metricData.isMonotonic,\n        dataPoints: toSingularDataPoints(metricData, encoder)\n      };\n      break;\n    case DataPointType.GAUGE:\n      out.gauge = {\n        dataPoints: toSingularDataPoints(metricData, encoder)\n      };\n      break;\n    case DataPointType.HISTOGRAM:\n      out.histogram = {\n        aggregationTemporality,\n        dataPoints: toHistogramDataPoints(metricData, encoder)\n      };\n      break;\n    case DataPointType.EXPONENTIAL_HISTOGRAM:\n      out.exponentialHistogram = {\n        aggregationTemporality,\n        dataPoints: toExponentialHistogramDataPoints(metricData, encoder)\n      };\n      break;\n  }\n  return out;\n}\nfunction toSingularDataPoint(dataPoint, valueType, encoder) {\n  const out = {\n    attributes: toAttributes(dataPoint.attributes),\n    startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),\n    timeUnixNano: encoder.encodeHrTime(dataPoint.endTime)\n  };\n  switch (valueType) {\n    case ValueType.INT:\n      out.asInt = dataPoint.value;\n      break;\n    case ValueType.DOUBLE:\n      out.asDouble = dataPoint.value;\n      break;\n  }\n  return out;\n}\nfunction toSingularDataPoints(metricData, encoder) {\n  return metricData.dataPoints.map(dataPoint => {\n    return toSingularDataPoint(dataPoint, metricData.descriptor.valueType, encoder);\n  });\n}\nfunction toHistogramDataPoints(metricData, encoder) {\n  return metricData.dataPoints.map(dataPoint => {\n    const histogram = dataPoint.value;\n    return {\n      attributes: toAttributes(dataPoint.attributes),\n      bucketCounts: histogram.buckets.counts,\n      explicitBounds: histogram.buckets.boundaries,\n      count: histogram.count,\n      sum: histogram.sum,\n      min: histogram.min,\n      max: histogram.max,\n      startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),\n      timeUnixNano: encoder.encodeHrTime(dataPoint.endTime)\n    };\n  });\n}\nfunction toExponentialHistogramDataPoints(metricData, encoder) {\n  return metricData.dataPoints.map(dataPoint => {\n    const histogram = dataPoint.value;\n    return {\n      attributes: toAttributes(dataPoint.attributes),\n      count: histogram.count,\n      min: histogram.min,\n      max: histogram.max,\n      sum: histogram.sum,\n      positive: {\n        offset: histogram.positive.offset,\n        bucketCounts: histogram.positive.bucketCounts\n      },\n      negative: {\n        offset: histogram.negative.offset,\n        bucketCounts: histogram.negative.bucketCounts\n      },\n      scale: histogram.scale,\n      zeroCount: histogram.zeroCount,\n      startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),\n      timeUnixNano: encoder.encodeHrTime(dataPoint.endTime)\n    };\n  });\n}\nfunction toAggregationTemporality(temporality) {\n  switch (temporality) {\n    case AggregationTemporality.DELTA:\n      return EAggregationTemporality.AGGREGATION_TEMPORALITY_DELTA;\n    case AggregationTemporality.CUMULATIVE:\n      return EAggregationTemporality.AGGREGATION_TEMPORALITY_CUMULATIVE;\n  }\n}\nexport function createExportMetricsServiceRequest(resourceMetrics, options) {\n  return {\n    resourceMetrics: resourceMetrics.map(metrics => toResourceMetrics(metrics, options))\n  };\n}","map":{"version":3,"names":["ValueType","AggregationTemporality","DataPointType","EAggregationTemporality","getOtlpEncoder","createInstrumentationScope","createResource","toAttributes","toResourceMetrics","resourceMetrics","options","encoder","resource","schemaUrl","undefined","scopeMetrics","toScopeMetrics","Array","from","map","metrics","scope","metricData","toMetric","out","name","descriptor","description","unit","aggregationTemporality","toAggregationTemporality","dataPointType","SUM","sum","isMonotonic","dataPoints","toSingularDataPoints","GAUGE","gauge","HISTOGRAM","histogram","toHistogramDataPoints","EXPONENTIAL_HISTOGRAM","exponentialHistogram","toExponentialHistogramDataPoints","toSingularDataPoint","dataPoint","valueType","attributes","startTimeUnixNano","encodeHrTime","startTime","timeUnixNano","endTime","INT","asInt","value","DOUBLE","asDouble","bucketCounts","buckets","counts","explicitBounds","boundaries","count","min","max","positive","offset","negative","scale","zeroCount","temporality","DELTA","AGGREGATION_TEMPORALITY_DELTA","CUMULATIVE","AGGREGATION_TEMPORALITY_CUMULATIVE","createExportMetricsServiceRequest"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/otlp-transformer/src/metrics/internal.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { OtlpEncodingOptions } from '../common/internal-types';\nimport { ValueType } from '@opentelemetry/api';\nimport {\n  AggregationTemporality,\n  DataPoint,\n  DataPointType,\n  ExponentialHistogram,\n  Histogram,\n  MetricData,\n  ResourceMetrics,\n  ScopeMetrics,\n} from '@opentelemetry/sdk-metrics';\nimport {\n  EAggregationTemporality,\n  IExponentialHistogramDataPoint,\n  IExportMetricsServiceRequest,\n  IHistogramDataPoint,\n  IMetric,\n  INumberDataPoint,\n  IResourceMetrics,\n  IScopeMetrics,\n} from './internal-types';\nimport { Encoder, getOtlpEncoder } from '../common/utils';\nimport {\n  createInstrumentationScope,\n  createResource,\n  toAttributes,\n} from '../common/internal';\n\nexport function toResourceMetrics(\n  resourceMetrics: ResourceMetrics,\n  options?: OtlpEncodingOptions\n): IResourceMetrics {\n  const encoder = getOtlpEncoder(options);\n  return {\n    resource: createResource(resourceMetrics.resource),\n    schemaUrl: undefined,\n    scopeMetrics: toScopeMetrics(resourceMetrics.scopeMetrics, encoder),\n  };\n}\n\nexport function toScopeMetrics(\n  scopeMetrics: ScopeMetrics[],\n  encoder: Encoder\n): IScopeMetrics[] {\n  return Array.from(\n    scopeMetrics.map(metrics => ({\n      scope: createInstrumentationScope(metrics.scope),\n      metrics: metrics.metrics.map(metricData => toMetric(metricData, encoder)),\n      schemaUrl: metrics.scope.schemaUrl,\n    }))\n  );\n}\n\nexport function toMetric(metricData: MetricData, encoder: Encoder): IMetric {\n  const out: IMetric = {\n    name: metricData.descriptor.name,\n    description: metricData.descriptor.description,\n    unit: metricData.descriptor.unit,\n  };\n\n  const aggregationTemporality = toAggregationTemporality(\n    metricData.aggregationTemporality\n  );\n\n  switch (metricData.dataPointType) {\n    case DataPointType.SUM:\n      out.sum = {\n        aggregationTemporality,\n        isMonotonic: metricData.isMonotonic,\n        dataPoints: toSingularDataPoints(metricData, encoder),\n      };\n      break;\n    case DataPointType.GAUGE:\n      out.gauge = {\n        dataPoints: toSingularDataPoints(metricData, encoder),\n      };\n      break;\n    case DataPointType.HISTOGRAM:\n      out.histogram = {\n        aggregationTemporality,\n        dataPoints: toHistogramDataPoints(metricData, encoder),\n      };\n      break;\n    case DataPointType.EXPONENTIAL_HISTOGRAM:\n      out.exponentialHistogram = {\n        aggregationTemporality,\n        dataPoints: toExponentialHistogramDataPoints(metricData, encoder),\n      };\n      break;\n  }\n\n  return out;\n}\n\nfunction toSingularDataPoint(\n  dataPoint:\n    | DataPoint<number>\n    | DataPoint<Histogram>\n    | DataPoint<ExponentialHistogram>,\n  valueType: ValueType,\n  encoder: Encoder\n) {\n  const out: INumberDataPoint = {\n    attributes: toAttributes(dataPoint.attributes),\n    startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),\n    timeUnixNano: encoder.encodeHrTime(dataPoint.endTime),\n  };\n\n  switch (valueType) {\n    case ValueType.INT:\n      out.asInt = dataPoint.value as number;\n      break;\n    case ValueType.DOUBLE:\n      out.asDouble = dataPoint.value as number;\n      break;\n  }\n\n  return out;\n}\n\nfunction toSingularDataPoints(\n  metricData: MetricData,\n  encoder: Encoder\n): INumberDataPoint[] {\n  return metricData.dataPoints.map(dataPoint => {\n    return toSingularDataPoint(\n      dataPoint,\n      metricData.descriptor.valueType,\n      encoder\n    );\n  });\n}\n\nfunction toHistogramDataPoints(\n  metricData: MetricData,\n  encoder: Encoder\n): IHistogramDataPoint[] {\n  return metricData.dataPoints.map(dataPoint => {\n    const histogram = dataPoint.value as Histogram;\n    return {\n      attributes: toAttributes(dataPoint.attributes),\n      bucketCounts: histogram.buckets.counts,\n      explicitBounds: histogram.buckets.boundaries,\n      count: histogram.count,\n      sum: histogram.sum,\n      min: histogram.min,\n      max: histogram.max,\n      startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),\n      timeUnixNano: encoder.encodeHrTime(dataPoint.endTime),\n    };\n  });\n}\n\nfunction toExponentialHistogramDataPoints(\n  metricData: MetricData,\n  encoder: Encoder\n): IExponentialHistogramDataPoint[] {\n  return metricData.dataPoints.map(dataPoint => {\n    const histogram = dataPoint.value as ExponentialHistogram;\n    return {\n      attributes: toAttributes(dataPoint.attributes),\n      count: histogram.count,\n      min: histogram.min,\n      max: histogram.max,\n      sum: histogram.sum,\n      positive: {\n        offset: histogram.positive.offset,\n        bucketCounts: histogram.positive.bucketCounts,\n      },\n      negative: {\n        offset: histogram.negative.offset,\n        bucketCounts: histogram.negative.bucketCounts,\n      },\n      scale: histogram.scale,\n      zeroCount: histogram.zeroCount,\n      startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),\n      timeUnixNano: encoder.encodeHrTime(dataPoint.endTime),\n    };\n  });\n}\n\nfunction toAggregationTemporality(\n  temporality: AggregationTemporality\n): EAggregationTemporality {\n  switch (temporality) {\n    case AggregationTemporality.DELTA:\n      return EAggregationTemporality.AGGREGATION_TEMPORALITY_DELTA;\n    case AggregationTemporality.CUMULATIVE:\n      return EAggregationTemporality.AGGREGATION_TEMPORALITY_CUMULATIVE;\n  }\n}\n\nexport function createExportMetricsServiceRequest(\n  resourceMetrics: ResourceMetrics[],\n  options?: OtlpEncodingOptions\n): IExportMetricsServiceRequest {\n  return {\n    resourceMetrics: resourceMetrics.map(metrics =>\n      toResourceMetrics(metrics, options)\n    ),\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { diag } from '@opentelemetry/api';\n/** Combines multiple propagators into a single propagator. */\nexport class CompositePropagator {\n  _propagators;\n  _fields;\n  /**\n   * Construct a composite propagator from a list of propagators.\n   *\n   * @param [config] Configuration object for composite propagator\n   */\n  constructor(config = {}) {\n    this._propagators = config.propagators ?? [];\n    this._fields = Array.from(new Set(this._propagators\n    // older propagators may not have fields function, null check to be sure\n    .map(p => typeof p.fields === 'function' ? p.fields() : []).reduce((x, y) => x.concat(y), [])));\n  }\n  /**\n   * Run each of the configured propagators with the given context and carrier.\n   * Propagators are run in the order they are configured, so if multiple\n   * propagators write the same carrier key, the propagator later in the list\n   * will \"win\".\n   *\n   * @param context Context to inject\n   * @param carrier Carrier into which context will be injected\n   */\n  inject(context, carrier, setter) {\n    for (const propagator of this._propagators) {\n      try {\n        propagator.inject(context, carrier, setter);\n      } catch (err) {\n        diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);\n      }\n    }\n  }\n  /**\n   * Run each of the configured propagators with the given context and carrier.\n   * Propagators are run in the order they are configured, so if multiple\n   * propagators write the same context key, the propagator later in the list\n   * will \"win\".\n   *\n   * @param context Context to add values to\n   * @param carrier Carrier from which to extract context\n   */\n  extract(context, carrier, getter) {\n    return this._propagators.reduce((ctx, propagator) => {\n      try {\n        return propagator.extract(ctx, carrier, getter);\n      } catch (err) {\n        diag.warn(`Failed to extract with ${propagator.constructor.name}. Err: ${err.message}`);\n      }\n      return ctx;\n    }, context);\n  }\n  fields() {\n    // return a new array so our fields cannot be modified\n    return this._fields.slice();\n  }\n}","map":{"version":3,"names":["diag","CompositePropagator","_propagators","_fields","constructor","config","propagators","Array","from","Set","map","p","fields","reduce","x","y","concat","inject","context","carrier","setter","propagator","err","warn","name","message","extract","getter","ctx","slice"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/core/src/propagation/composite.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Context,\n  TextMapGetter,\n  TextMapPropagator,\n  diag,\n  TextMapSetter,\n} from '@opentelemetry/api';\n\n/** Configuration object for composite propagator */\nexport interface CompositePropagatorConfig {\n  /**\n   * List of propagators to run. Propagators run in the\n   * list order. If a propagator later in the list writes the same context\n   * key as a propagator earlier in the list, the later on will \"win\".\n   */\n  propagators?: TextMapPropagator[];\n}\n\n/** Combines multiple propagators into a single propagator. */\nexport class CompositePropagator implements TextMapPropagator {\n  private readonly _propagators: TextMapPropagator[];\n  private readonly _fields: string[];\n\n  /**\n   * Construct a composite propagator from a list of propagators.\n   *\n   * @param [config] Configuration object for composite propagator\n   */\n  constructor(config: CompositePropagatorConfig = {}) {\n    this._propagators = config.propagators ?? [];\n\n    this._fields = Array.from(\n      new Set(\n        this._propagators\n          // older propagators may not have fields function, null check to be sure\n          .map(p => (typeof p.fields === 'function' ? p.fields() : []))\n          .reduce((x, y) => x.concat(y), [])\n      )\n    );\n  }\n\n  /**\n   * Run each of the configured propagators with the given context and carrier.\n   * Propagators are run in the order they are configured, so if multiple\n   * propagators write the same carrier key, the propagator later in the list\n   * will \"win\".\n   *\n   * @param context Context to inject\n   * @param carrier Carrier into which context will be injected\n   */\n  inject(context: Context, carrier: unknown, setter: TextMapSetter): void {\n    for (const propagator of this._propagators) {\n      try {\n        propagator.inject(context, carrier, setter);\n      } catch (err) {\n        diag.warn(\n          `Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`\n        );\n      }\n    }\n  }\n\n  /**\n   * Run each of the configured propagators with the given context and carrier.\n   * Propagators are run in the order they are configured, so if multiple\n   * propagators write the same context key, the propagator later in the list\n   * will \"win\".\n   *\n   * @param context Context to add values to\n   * @param carrier Carrier from which to extract context\n   */\n  extract(context: Context, carrier: unknown, getter: TextMapGetter): Context {\n    return this._propagators.reduce((ctx, propagator) => {\n      try {\n        return propagator.extract(ctx, carrier, getter);\n      } catch (err) {\n        diag.warn(\n          `Failed to extract with ${propagator.constructor.name}. Err: ${err.message}`\n        );\n      }\n      return ctx;\n    }, context);\n  }\n\n  fields(): string[] {\n    // return a new array so our fields cannot be modified\n    return this._fields.slice();\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAgBA,SAIEA,IAAI,QAEC,oBAAoB;AAY3B;AACA,OAAM,MAAOC,mBAAmB;EACbC,YAAY;EACZC,OAAO;EAExB;;;;;EAKAC,YAAYC,MAAA,GAAoC,EAAE;IAChD,IAAI,CAACH,YAAY,GAAGG,MAAM,CAACC,WAAW,IAAI,EAAE;IAE5C,IAAI,CAACH,OAAO,GAAGI,KAAK,CAACC,IAAI,CACvB,IAAIC,GAAG,CACL,IAAI,CAACP;IACH;IAAA,CACCQ,GAAG,CAACC,CAAC,IAAK,OAAOA,CAAC,CAACC,MAAM,KAAK,UAAU,GAAGD,CAAC,CAACC,MAAM,EAAE,GAAG,EAAG,CAAC,CAC5DC,MAAM,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACE,MAAM,CAACD,CAAC,CAAC,EAAE,EAAE,CAAC,CACrC,CACF;EACH;EAEA;;;;;;;;;EASAE,MAAMA,CAACC,OAAgB,EAAEC,OAAgB,EAAEC,MAAqB;IAC9D,KAAK,MAAMC,UAAU,IAAI,IAAI,CAACnB,YAAY,EAAE;MAC1C,IAAI;QACFmB,UAAU,CAACJ,MAAM,CAACC,OAAO,EAAEC,OAAO,EAAEC,MAAM,CAAC;OAC5C,CAAC,OAAOE,GAAG,EAAE;QACZtB,IAAI,CAACuB,IAAI,CACP,yBAAyBF,UAAU,CAACjB,WAAW,CAACoB,IAAI,UAAUF,GAAG,CAACG,OAAO,EAAE,CAC5E;;;EAGP;EAEA;;;;;;;;;EASAC,OAAOA,CAACR,OAAgB,EAAEC,OAAgB,EAAEQ,MAAqB;IAC/D,OAAO,IAAI,CAACzB,YAAY,CAACW,MAAM,CAAC,CAACe,GAAG,EAAEP,UAAU,KAAI;MAClD,IAAI;QACF,OAAOA,UAAU,CAACK,OAAO,CAACE,GAAG,EAAET,OAAO,EAAEQ,MAAM,CAAC;OAChD,CAAC,OAAOL,GAAG,EAAE;QACZtB,IAAI,CAACuB,IAAI,CACP,0BAA0BF,UAAU,CAACjB,WAAW,CAACoB,IAAI,UAAUF,GAAG,CAACG,OAAO,EAAE,CAC7E;;MAEH,OAAOG,GAAG;IACZ,CAAC,EAAEV,OAAO,CAAC;EACb;EAEAN,MAAMA,CAAA;IACJ;IACA,OAAO,IAAI,CAACT,OAAO,CAAC0B,KAAK,EAAE;EAC7B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
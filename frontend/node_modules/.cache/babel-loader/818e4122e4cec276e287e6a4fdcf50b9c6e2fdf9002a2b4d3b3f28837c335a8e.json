{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ExportResultCode } from '@opentelemetry/core';\nimport { OTLPExporterError } from './types';\nimport { createLoggingPartialSuccessResponseHandler } from './logging-response-handler';\nimport { diag } from '@opentelemetry/api';\nclass OTLPExportDelegate {\n  _transport;\n  _serializer;\n  _responseHandler;\n  _promiseQueue;\n  _timeout;\n  _diagLogger;\n  constructor(_transport, _serializer, _responseHandler, _promiseQueue, _timeout) {\n    this._transport = _transport;\n    this._serializer = _serializer;\n    this._responseHandler = _responseHandler;\n    this._promiseQueue = _promiseQueue;\n    this._timeout = _timeout;\n    this._diagLogger = diag.createComponentLogger({\n      namespace: 'OTLPExportDelegate'\n    });\n  }\n  export(internalRepresentation, resultCallback) {\n    this._diagLogger.debug('items to be sent', internalRepresentation);\n    // don't do any work if too many exports are in progress.\n    if (this._promiseQueue.hasReachedLimit()) {\n      resultCallback({\n        code: ExportResultCode.FAILED,\n        error: new Error('Concurrent export limit reached')\n      });\n      return;\n    }\n    const serializedRequest = this._serializer.serializeRequest(internalRepresentation);\n    if (serializedRequest == null) {\n      resultCallback({\n        code: ExportResultCode.FAILED,\n        error: new Error('Nothing to send')\n      });\n      return;\n    }\n    this._promiseQueue.pushPromise(this._transport.send(serializedRequest, this._timeout).then(response => {\n      if (response.status === 'success') {\n        if (response.data != null) {\n          try {\n            this._responseHandler.handleResponse(this._serializer.deserializeResponse(response.data));\n          } catch (e) {\n            this._diagLogger.warn('Export succeeded but could not deserialize response - is the response specification compliant?', e, response.data);\n          }\n        }\n        // No matter the response, we can consider the export still successful.\n        resultCallback({\n          code: ExportResultCode.SUCCESS\n        });\n        return;\n      } else if (response.status === 'failure' && response.error) {\n        resultCallback({\n          code: ExportResultCode.FAILED,\n          error: response.error\n        });\n        return;\n      } else if (response.status === 'retryable') {\n        resultCallback({\n          code: ExportResultCode.FAILED,\n          error: new OTLPExporterError('Export failed with retryable status')\n        });\n      } else {\n        resultCallback({\n          code: ExportResultCode.FAILED,\n          error: new OTLPExporterError('Export failed with unknown error')\n        });\n      }\n    }, reason => resultCallback({\n      code: ExportResultCode.FAILED,\n      error: reason\n    })));\n  }\n  forceFlush() {\n    return this._promiseQueue.awaitAll();\n  }\n  async shutdown() {\n    this._diagLogger.debug('shutdown started');\n    await this.forceFlush();\n    this._transport.shutdown();\n  }\n}\n/**\n * Creates a generic delegate for OTLP exports which only contains parts of the OTLP export that are shared across all\n * signals.\n */\nexport function createOtlpExportDelegate(components, settings) {\n  return new OTLPExportDelegate(components.transport, components.serializer, createLoggingPartialSuccessResponseHandler(), components.promiseHandler, settings.timeout);\n}","map":{"version":3,"names":["ExportResultCode","OTLPExporterError","createLoggingPartialSuccessResponseHandler","diag","OTLPExportDelegate","_transport","_serializer","_responseHandler","_promiseQueue","_timeout","_diagLogger","constructor","createComponentLogger","namespace","export","internalRepresentation","resultCallback","debug","hasReachedLimit","code","FAILED","error","Error","serializedRequest","serializeRequest","pushPromise","send","then","response","status","data","handleResponse","deserializeResponse","e","warn","SUCCESS","reason","forceFlush","awaitAll","shutdown","createOtlpExportDelegate","components","settings","transport","serializer","promiseHandler","timeout"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/otlp-exporter-base/src/otlp-export-delegate.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ExportResult, ExportResultCode } from '@opentelemetry/core';\nimport { IExporterTransport } from './exporter-transport';\nimport { IExportPromiseHandler } from './bounded-queue-export-promise-handler';\nimport { ISerializer } from '@opentelemetry/otlp-transformer';\nimport { OTLPExporterError } from './types';\nimport { IOtlpResponseHandler } from './response-handler';\nimport { createLoggingPartialSuccessResponseHandler } from './logging-response-handler';\nimport { diag, DiagLogger } from '@opentelemetry/api';\n\n/**\n * Internally shared export logic for OTLP.\n */\nexport interface IOtlpExportDelegate<Internal> {\n  export(\n    internalRepresentation: Internal,\n    resultCallback: (result: ExportResult) => void\n  ): void;\n  forceFlush(): Promise<void>;\n  shutdown(): Promise<void>;\n}\n\nclass OTLPExportDelegate<Internal, Response>\n  implements IOtlpExportDelegate<Internal>\n{\n  private _diagLogger: DiagLogger;\n  constructor(\n    private _transport: IExporterTransport,\n    private _serializer: ISerializer<Internal, Response>,\n    private _responseHandler: IOtlpResponseHandler<Response>,\n    private _promiseQueue: IExportPromiseHandler,\n    private _timeout: number\n  ) {\n    this._diagLogger = diag.createComponentLogger({\n      namespace: 'OTLPExportDelegate',\n    });\n  }\n\n  export(\n    internalRepresentation: Internal,\n    resultCallback: (result: ExportResult) => void\n  ): void {\n    this._diagLogger.debug('items to be sent', internalRepresentation);\n\n    // don't do any work if too many exports are in progress.\n    if (this._promiseQueue.hasReachedLimit()) {\n      resultCallback({\n        code: ExportResultCode.FAILED,\n        error: new Error('Concurrent export limit reached'),\n      });\n      return;\n    }\n\n    const serializedRequest = this._serializer.serializeRequest(\n      internalRepresentation\n    );\n\n    if (serializedRequest == null) {\n      resultCallback({\n        code: ExportResultCode.FAILED,\n        error: new Error('Nothing to send'),\n      });\n      return;\n    }\n\n    this._promiseQueue.pushPromise(\n      this._transport.send(serializedRequest, this._timeout).then(\n        response => {\n          if (response.status === 'success') {\n            if (response.data != null) {\n              try {\n                this._responseHandler.handleResponse(\n                  this._serializer.deserializeResponse(response.data)\n                );\n              } catch (e) {\n                this._diagLogger.warn(\n                  'Export succeeded but could not deserialize response - is the response specification compliant?',\n                  e,\n                  response.data\n                );\n              }\n            }\n            // No matter the response, we can consider the export still successful.\n            resultCallback({\n              code: ExportResultCode.SUCCESS,\n            });\n            return;\n          } else if (response.status === 'failure' && response.error) {\n            resultCallback({\n              code: ExportResultCode.FAILED,\n              error: response.error,\n            });\n            return;\n          } else if (response.status === 'retryable') {\n            resultCallback({\n              code: ExportResultCode.FAILED,\n              error: new OTLPExporterError(\n                'Export failed with retryable status'\n              ),\n            });\n          } else {\n            resultCallback({\n              code: ExportResultCode.FAILED,\n              error: new OTLPExporterError('Export failed with unknown error'),\n            });\n          }\n        },\n        reason =>\n          resultCallback({\n            code: ExportResultCode.FAILED,\n            error: reason,\n          })\n      )\n    );\n  }\n\n  forceFlush(): Promise<void> {\n    return this._promiseQueue.awaitAll();\n  }\n\n  async shutdown(): Promise<void> {\n    this._diagLogger.debug('shutdown started');\n    await this.forceFlush();\n    this._transport.shutdown();\n  }\n}\n\n/**\n * Creates a generic delegate for OTLP exports which only contains parts of the OTLP export that are shared across all\n * signals.\n */\nexport function createOtlpExportDelegate<Internal, Response>(\n  components: {\n    transport: IExporterTransport;\n    serializer: ISerializer<Internal, Response>;\n    promiseHandler: IExportPromiseHandler;\n  },\n  settings: { timeout: number }\n): IOtlpExportDelegate<Internal> {\n  return new OTLPExportDelegate(\n    components.transport,\n    components.serializer,\n    createLoggingPartialSuccessResponseHandler(),\n    components.promiseHandler,\n    settings.timeout\n  );\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAgBA,SAAuBA,gBAAgB,QAAQ,qBAAqB;AAIpE,SAASC,iBAAiB,QAAQ,SAAS;AAE3C,SAASC,0CAA0C,QAAQ,4BAA4B;AACvF,SAASC,IAAI,QAAoB,oBAAoB;AAcrD,MAAMC,kBAAkB;EAKZC,UAAA;EACAC,WAAA;EACAC,gBAAA;EACAC,aAAA;EACAC,QAAA;EANFC,WAAW;EACnBC,YACUN,UAA8B,EAC9BC,WAA4C,EAC5CC,gBAAgD,EAChDC,aAAoC,EACpCC,QAAgB;IAJhB,KAAAJ,UAAU,GAAVA,UAAU;IACV,KAAAC,WAAW,GAAXA,WAAW;IACX,KAAAC,gBAAgB,GAAhBA,gBAAgB;IAChB,KAAAC,aAAa,GAAbA,aAAa;IACb,KAAAC,QAAQ,GAARA,QAAQ;IAEhB,IAAI,CAACC,WAAW,GAAGP,IAAI,CAACS,qBAAqB,CAAC;MAC5CC,SAAS,EAAE;KACZ,CAAC;EACJ;EAEAC,MAAMA,CACJC,sBAAgC,EAChCC,cAA8C;IAE9C,IAAI,CAACN,WAAW,CAACO,KAAK,CAAC,kBAAkB,EAAEF,sBAAsB,CAAC;IAElE;IACA,IAAI,IAAI,CAACP,aAAa,CAACU,eAAe,EAAE,EAAE;MACxCF,cAAc,CAAC;QACbG,IAAI,EAAEnB,gBAAgB,CAACoB,MAAM;QAC7BC,KAAK,EAAE,IAAIC,KAAK,CAAC,iCAAiC;OACnD,CAAC;MACF;;IAGF,MAAMC,iBAAiB,GAAG,IAAI,CAACjB,WAAW,CAACkB,gBAAgB,CACzDT,sBAAsB,CACvB;IAED,IAAIQ,iBAAiB,IAAI,IAAI,EAAE;MAC7BP,cAAc,CAAC;QACbG,IAAI,EAAEnB,gBAAgB,CAACoB,MAAM;QAC7BC,KAAK,EAAE,IAAIC,KAAK,CAAC,iBAAiB;OACnC,CAAC;MACF;;IAGF,IAAI,CAACd,aAAa,CAACiB,WAAW,CAC5B,IAAI,CAACpB,UAAU,CAACqB,IAAI,CAACH,iBAAiB,EAAE,IAAI,CAACd,QAAQ,CAAC,CAACkB,IAAI,CACzDC,QAAQ,IAAG;MACT,IAAIA,QAAQ,CAACC,MAAM,KAAK,SAAS,EAAE;QACjC,IAAID,QAAQ,CAACE,IAAI,IAAI,IAAI,EAAE;UACzB,IAAI;YACF,IAAI,CAACvB,gBAAgB,CAACwB,cAAc,CAClC,IAAI,CAACzB,WAAW,CAAC0B,mBAAmB,CAACJ,QAAQ,CAACE,IAAI,CAAC,CACpD;WACF,CAAC,OAAOG,CAAC,EAAE;YACV,IAAI,CAACvB,WAAW,CAACwB,IAAI,CACnB,gGAAgG,EAChGD,CAAC,EACDL,QAAQ,CAACE,IAAI,CACd;;;QAGL;QACAd,cAAc,CAAC;UACbG,IAAI,EAAEnB,gBAAgB,CAACmC;SACxB,CAAC;QACF;OACD,MAAM,IAAIP,QAAQ,CAACC,MAAM,KAAK,SAAS,IAAID,QAAQ,CAACP,KAAK,EAAE;QAC1DL,cAAc,CAAC;UACbG,IAAI,EAAEnB,gBAAgB,CAACoB,MAAM;UAC7BC,KAAK,EAAEO,QAAQ,CAACP;SACjB,CAAC;QACF;OACD,MAAM,IAAIO,QAAQ,CAACC,MAAM,KAAK,WAAW,EAAE;QAC1Cb,cAAc,CAAC;UACbG,IAAI,EAAEnB,gBAAgB,CAACoB,MAAM;UAC7BC,KAAK,EAAE,IAAIpB,iBAAiB,CAC1B,qCAAqC;SAExC,CAAC;OACH,MAAM;QACLe,cAAc,CAAC;UACbG,IAAI,EAAEnB,gBAAgB,CAACoB,MAAM;UAC7BC,KAAK,EAAE,IAAIpB,iBAAiB,CAAC,kCAAkC;SAChE,CAAC;;IAEN,CAAC,EACDmC,MAAM,IACJpB,cAAc,CAAC;MACbG,IAAI,EAAEnB,gBAAgB,CAACoB,MAAM;MAC7BC,KAAK,EAAEe;KACR,CAAC,CACL,CACF;EACH;EAEAC,UAAUA,CAAA;IACR,OAAO,IAAI,CAAC7B,aAAa,CAAC8B,QAAQ,EAAE;EACtC;EAEA,MAAMC,QAAQA,CAAA;IACZ,IAAI,CAAC7B,WAAW,CAACO,KAAK,CAAC,kBAAkB,CAAC;IAC1C,MAAM,IAAI,CAACoB,UAAU,EAAE;IACvB,IAAI,CAAChC,UAAU,CAACkC,QAAQ,EAAE;EAC5B;;AAGF;;;;AAIA,OAAM,SAAUC,wBAAwBA,CACtCC,UAIC,EACDC,QAA6B;EAE7B,OAAO,IAAItC,kBAAkB,CAC3BqC,UAAU,CAACE,SAAS,EACpBF,UAAU,CAACG,UAAU,EACrB1C,0CAA0C,EAAE,EAC5CuC,UAAU,CAACI,cAAc,EACzBH,QAAQ,CAACI,OAAO,CACjB;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
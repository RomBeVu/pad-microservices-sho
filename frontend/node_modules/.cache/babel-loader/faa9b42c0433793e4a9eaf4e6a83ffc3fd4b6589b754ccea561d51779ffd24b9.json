{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { instrumentationScopeId } from '../utils';\nimport { ViewRegistry } from '../view/ViewRegistry';\nimport { MeterSharedState } from './MeterSharedState';\nimport { toAggregation } from '../view/AggregationOption';\n/**\n * An internal record for shared meter provider states.\n */\nexport class MeterProviderSharedState {\n  resource;\n  viewRegistry = new ViewRegistry();\n  metricCollectors = [];\n  meterSharedStates = new Map();\n  constructor(resource) {\n    this.resource = resource;\n  }\n  getMeterSharedState(instrumentationScope) {\n    const id = instrumentationScopeId(instrumentationScope);\n    let meterSharedState = this.meterSharedStates.get(id);\n    if (meterSharedState == null) {\n      meterSharedState = new MeterSharedState(this, instrumentationScope);\n      this.meterSharedStates.set(id, meterSharedState);\n    }\n    return meterSharedState;\n  }\n  selectAggregations(instrumentType) {\n    const result = [];\n    for (const collector of this.metricCollectors) {\n      result.push([collector, toAggregation(collector.selectAggregation(instrumentType))]);\n    }\n    return result;\n  }\n}","map":{"version":3,"names":["instrumentationScopeId","ViewRegistry","MeterSharedState","toAggregation","MeterProviderSharedState","resource","viewRegistry","metricCollectors","meterSharedStates","Map","constructor","getMeterSharedState","instrumentationScope","id","meterSharedState","get","set","selectAggregations","instrumentType","result","collector","push","selectAggregation"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/sdk-metrics/src/state/MeterProviderSharedState.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { InstrumentationScope } from '@opentelemetry/core';\nimport { Resource } from '@opentelemetry/resources';\nimport { instrumentationScopeId } from '../utils';\nimport { ViewRegistry } from '../view/ViewRegistry';\nimport { MeterSharedState } from './MeterSharedState';\nimport { MetricCollector, MetricCollectorHandle } from './MetricCollector';\nimport { toAggregation } from '../view/AggregationOption';\nimport { Aggregation } from '../view/Aggregation';\nimport { InstrumentType } from '../export/MetricData';\n\n/**\n * An internal record for shared meter provider states.\n */\nexport class MeterProviderSharedState {\n  viewRegistry = new ViewRegistry();\n\n  metricCollectors: MetricCollector[] = [];\n\n  meterSharedStates: Map<string, MeterSharedState> = new Map();\n\n  constructor(public resource: Resource) {}\n\n  getMeterSharedState(instrumentationScope: InstrumentationScope) {\n    const id = instrumentationScopeId(instrumentationScope);\n    let meterSharedState = this.meterSharedStates.get(id);\n    if (meterSharedState == null) {\n      meterSharedState = new MeterSharedState(this, instrumentationScope);\n      this.meterSharedStates.set(id, meterSharedState);\n    }\n    return meterSharedState;\n  }\n\n  selectAggregations(instrumentType: InstrumentType) {\n    const result: [MetricCollectorHandle, Aggregation][] = [];\n    for (const collector of this.metricCollectors) {\n      result.push([\n        collector,\n        toAggregation(collector.selectAggregation(instrumentType)),\n      ]);\n    }\n    return result;\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAkBA,SAASA,sBAAsB,QAAQ,UAAU;AACjD,SAASC,YAAY,QAAQ,sBAAsB;AACnD,SAASC,gBAAgB,QAAQ,oBAAoB;AAErD,SAASC,aAAa,QAAQ,2BAA2B;AAIzD;;;AAGA,OAAM,MAAOC,wBAAwB;EAOhBC,QAAA;EANnBC,YAAY,GAAG,IAAIL,YAAY,EAAE;EAEjCM,gBAAgB,GAAsB,EAAE;EAExCC,iBAAiB,GAAkC,IAAIC,GAAG,EAAE;EAE5DC,YAAmBL,QAAkB;IAAlB,KAAAA,QAAQ,GAARA,QAAQ;EAAa;EAExCM,mBAAmBA,CAACC,oBAA0C;IAC5D,MAAMC,EAAE,GAAGb,sBAAsB,CAACY,oBAAoB,CAAC;IACvD,IAAIE,gBAAgB,GAAG,IAAI,CAACN,iBAAiB,CAACO,GAAG,CAACF,EAAE,CAAC;IACrD,IAAIC,gBAAgB,IAAI,IAAI,EAAE;MAC5BA,gBAAgB,GAAG,IAAIZ,gBAAgB,CAAC,IAAI,EAAEU,oBAAoB,CAAC;MACnE,IAAI,CAACJ,iBAAiB,CAACQ,GAAG,CAACH,EAAE,EAAEC,gBAAgB,CAAC;;IAElD,OAAOA,gBAAgB;EACzB;EAEAG,kBAAkBA,CAACC,cAA8B;IAC/C,MAAMC,MAAM,GAA2C,EAAE;IACzD,KAAK,MAAMC,SAAS,IAAI,IAAI,CAACb,gBAAgB,EAAE;MAC7CY,MAAM,CAACE,IAAI,CAAC,CACVD,SAAS,EACTjB,aAAa,CAACiB,SAAS,CAACE,iBAAiB,CAACJ,cAAc,CAAC,CAAC,CAC3D,CAAC;;IAEJ,OAAOC,MAAM;EACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst MAX_ATTEMPTS = 5;\nconst INITIAL_BACKOFF = 1000;\nconst MAX_BACKOFF = 5000;\nconst BACKOFF_MULTIPLIER = 1.5;\nconst JITTER = 0.2;\n/**\n * Get a pseudo-random jitter that falls in the range of [-JITTER, +JITTER]\n */\nfunction getJitter() {\n  return Math.random() * (2 * JITTER) - JITTER;\n}\nclass RetryingTransport {\n  _transport;\n  constructor(_transport) {\n    this._transport = _transport;\n  }\n  retry(data, timeoutMillis, inMillis) {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        this._transport.send(data, timeoutMillis).then(resolve, reject);\n      }, inMillis);\n    });\n  }\n  async send(data, timeoutMillis) {\n    const deadline = Date.now() + timeoutMillis;\n    let result = await this._transport.send(data, timeoutMillis);\n    let attempts = MAX_ATTEMPTS;\n    let nextBackoff = INITIAL_BACKOFF;\n    while (result.status === 'retryable' && attempts > 0) {\n      attempts--;\n      // use maximum of computed backoff and 0 to avoid negative timeouts\n      const backoff = Math.max(Math.min(nextBackoff, MAX_BACKOFF) + getJitter(), 0);\n      nextBackoff = nextBackoff * BACKOFF_MULTIPLIER;\n      const retryInMillis = result.retryInMillis ?? backoff;\n      // return when expected retry time is after the export deadline.\n      const remainingTimeoutMillis = deadline - Date.now();\n      if (retryInMillis > remainingTimeoutMillis) {\n        return result;\n      }\n      result = await this.retry(data, remainingTimeoutMillis, retryInMillis);\n    }\n    return result;\n  }\n  shutdown() {\n    return this._transport.shutdown();\n  }\n}\n/**\n * Creates an Exporter Transport that retries on 'retryable' response.\n */\nexport function createRetryingTransport(options) {\n  return new RetryingTransport(options.transport);\n}","map":{"version":3,"names":["MAX_ATTEMPTS","INITIAL_BACKOFF","MAX_BACKOFF","BACKOFF_MULTIPLIER","JITTER","getJitter","Math","random","RetryingTransport","_transport","constructor","retry","data","timeoutMillis","inMillis","Promise","resolve","reject","setTimeout","send","then","deadline","Date","now","result","attempts","nextBackoff","status","backoff","max","min","retryInMillis","remainingTimeoutMillis","shutdown","createRetryingTransport","options","transport"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/otlp-exporter-base/src/retrying-transport.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IExporterTransport } from './exporter-transport';\nimport { ExportResponse } from './export-response';\n\nconst MAX_ATTEMPTS = 5;\nconst INITIAL_BACKOFF = 1000;\nconst MAX_BACKOFF = 5000;\nconst BACKOFF_MULTIPLIER = 1.5;\nconst JITTER = 0.2;\n\n/**\n * Get a pseudo-random jitter that falls in the range of [-JITTER, +JITTER]\n */\nfunction getJitter() {\n  return Math.random() * (2 * JITTER) - JITTER;\n}\n\nclass RetryingTransport implements IExporterTransport {\n  constructor(private _transport: IExporterTransport) {}\n\n  private retry(\n    data: Uint8Array,\n    timeoutMillis: number,\n    inMillis: number\n  ): Promise<ExportResponse> {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        this._transport.send(data, timeoutMillis).then(resolve, reject);\n      }, inMillis);\n    });\n  }\n\n  async send(data: Uint8Array, timeoutMillis: number): Promise<ExportResponse> {\n    const deadline = Date.now() + timeoutMillis;\n    let result = await this._transport.send(data, timeoutMillis);\n    let attempts = MAX_ATTEMPTS;\n    let nextBackoff = INITIAL_BACKOFF;\n\n    while (result.status === 'retryable' && attempts > 0) {\n      attempts--;\n\n      // use maximum of computed backoff and 0 to avoid negative timeouts\n      const backoff = Math.max(\n        Math.min(nextBackoff, MAX_BACKOFF) + getJitter(),\n        0\n      );\n      nextBackoff = nextBackoff * BACKOFF_MULTIPLIER;\n      const retryInMillis = result.retryInMillis ?? backoff;\n\n      // return when expected retry time is after the export deadline.\n      const remainingTimeoutMillis = deadline - Date.now();\n      if (retryInMillis > remainingTimeoutMillis) {\n        return result;\n      }\n\n      result = await this.retry(data, remainingTimeoutMillis, retryInMillis);\n    }\n\n    return result;\n  }\n\n  shutdown() {\n    return this._transport.shutdown();\n  }\n}\n\n/**\n * Creates an Exporter Transport that retries on 'retryable' response.\n */\nexport function createRetryingTransport(options: {\n  // Underlying transport to wrap.\n  transport: IExporterTransport;\n}): IExporterTransport {\n  return new RetryingTransport(options.transport);\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAmBA,MAAMA,YAAY,GAAG,CAAC;AACtB,MAAMC,eAAe,GAAG,IAAI;AAC5B,MAAMC,WAAW,GAAG,IAAI;AACxB,MAAMC,kBAAkB,GAAG,GAAG;AAC9B,MAAMC,MAAM,GAAG,GAAG;AAElB;;;AAGA,SAASC,SAASA,CAAA;EAChB,OAAOC,IAAI,CAACC,MAAM,EAAE,IAAI,CAAC,GAAGH,MAAM,CAAC,GAAGA,MAAM;AAC9C;AAEA,MAAMI,iBAAiB;EACDC,UAAA;EAApBC,YAAoBD,UAA8B;IAA9B,KAAAA,UAAU,GAAVA,UAAU;EAAuB;EAE7CE,KAAKA,CACXC,IAAgB,EAChBC,aAAqB,EACrBC,QAAgB;IAEhB,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAI;MACrCC,UAAU,CAAC,MAAK;QACd,IAAI,CAACT,UAAU,CAACU,IAAI,CAACP,IAAI,EAAEC,aAAa,CAAC,CAACO,IAAI,CAACJ,OAAO,EAAEC,MAAM,CAAC;MACjE,CAAC,EAAEH,QAAQ,CAAC;IACd,CAAC,CAAC;EACJ;EAEA,MAAMK,IAAIA,CAACP,IAAgB,EAAEC,aAAqB;IAChD,MAAMQ,QAAQ,GAAGC,IAAI,CAACC,GAAG,EAAE,GAAGV,aAAa;IAC3C,IAAIW,MAAM,GAAG,MAAM,IAAI,CAACf,UAAU,CAACU,IAAI,CAACP,IAAI,EAAEC,aAAa,CAAC;IAC5D,IAAIY,QAAQ,GAAGzB,YAAY;IAC3B,IAAI0B,WAAW,GAAGzB,eAAe;IAEjC,OAAOuB,MAAM,CAACG,MAAM,KAAK,WAAW,IAAIF,QAAQ,GAAG,CAAC,EAAE;MACpDA,QAAQ,EAAE;MAEV;MACA,MAAMG,OAAO,GAAGtB,IAAI,CAACuB,GAAG,CACtBvB,IAAI,CAACwB,GAAG,CAACJ,WAAW,EAAExB,WAAW,CAAC,GAAGG,SAAS,EAAE,EAChD,CAAC,CACF;MACDqB,WAAW,GAAGA,WAAW,GAAGvB,kBAAkB;MAC9C,MAAM4B,aAAa,GAAGP,MAAM,CAACO,aAAa,IAAIH,OAAO;MAErD;MACA,MAAMI,sBAAsB,GAAGX,QAAQ,GAAGC,IAAI,CAACC,GAAG,EAAE;MACpD,IAAIQ,aAAa,GAAGC,sBAAsB,EAAE;QAC1C,OAAOR,MAAM;;MAGfA,MAAM,GAAG,MAAM,IAAI,CAACb,KAAK,CAACC,IAAI,EAAEoB,sBAAsB,EAAED,aAAa,CAAC;;IAGxE,OAAOP,MAAM;EACf;EAEAS,QAAQA,CAAA;IACN,OAAO,IAAI,CAACxB,UAAU,CAACwB,QAAQ,EAAE;EACnC;;AAGF;;;AAGA,OAAM,SAAUC,uBAAuBA,CAACC,OAGvC;EACC,OAAO,IAAI3B,iBAAiB,CAAC2B,OAAO,CAACC,SAAS,CAAC;AACjD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
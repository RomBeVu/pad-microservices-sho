{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { TraceFlags } from '@opentelemetry/api';\nimport { internal, ExportResultCode, globalErrorHandler, BindOnceFuture } from '@opentelemetry/core';\n/**\n * An implementation of the {@link SpanProcessor} that converts the {@link Span}\n * to {@link ReadableSpan} and passes it to the configured exporter.\n *\n * Only spans that are sampled are converted.\n *\n * NOTE: This {@link SpanProcessor} exports every ended span individually instead of batching spans together, which causes significant performance overhead with most exporters. For production use, please consider using the {@link BatchSpanProcessor} instead.\n */\nexport class SimpleSpanProcessor {\n  _exporter;\n  _shutdownOnce;\n  _pendingExports;\n  constructor(_exporter) {\n    this._exporter = _exporter;\n    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n    this._pendingExports = new Set();\n  }\n  async forceFlush() {\n    await Promise.all(Array.from(this._pendingExports));\n    if (this._exporter.forceFlush) {\n      await this._exporter.forceFlush();\n    }\n  }\n  onStart(_span, _parentContext) {}\n  onEnd(span) {\n    if (this._shutdownOnce.isCalled) {\n      return;\n    }\n    if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {\n      return;\n    }\n    const pendingExport = this._doExport(span).catch(err => globalErrorHandler(err));\n    // Enqueue this export to the pending list so it can be flushed by the user.\n    this._pendingExports.add(pendingExport);\n    pendingExport.finally(() => this._pendingExports.delete(pendingExport));\n  }\n  async _doExport(span) {\n    if (span.resource.asyncAttributesPending) {\n      // Ensure resource is fully resolved before exporting.\n      await span.resource.waitForAsyncAttributes?.();\n    }\n    const result = await internal._export(this._exporter, [span]);\n    if (result.code !== ExportResultCode.SUCCESS) {\n      throw result.error ?? new Error(`SimpleSpanProcessor: span export failed (status ${result})`);\n    }\n  }\n  shutdown() {\n    return this._shutdownOnce.call();\n  }\n  _shutdown() {\n    return this._exporter.shutdown();\n  }\n}","map":{"version":3,"names":["TraceFlags","internal","ExportResultCode","globalErrorHandler","BindOnceFuture","SimpleSpanProcessor","_exporter","_shutdownOnce","_pendingExports","constructor","_shutdown","Set","forceFlush","Promise","all","Array","from","onStart","_span","_parentContext","onEnd","span","isCalled","spanContext","traceFlags","SAMPLED","pendingExport","_doExport","catch","err","add","finally","delete","resource","asyncAttributesPending","waitForAsyncAttributes","result","_export","code","SUCCESS","error","Error","shutdown","call"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/sdk-trace-base/src/export/SimpleSpanProcessor.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context, TraceFlags } from '@opentelemetry/api';\nimport {\n  internal,\n  ExportResultCode,\n  globalErrorHandler,\n  BindOnceFuture,\n} from '@opentelemetry/core';\nimport { Span } from '../Span';\nimport { SpanProcessor } from '../SpanProcessor';\nimport { ReadableSpan } from './ReadableSpan';\nimport { SpanExporter } from './SpanExporter';\n\n/**\n * An implementation of the {@link SpanProcessor} that converts the {@link Span}\n * to {@link ReadableSpan} and passes it to the configured exporter.\n *\n * Only spans that are sampled are converted.\n *\n * NOTE: This {@link SpanProcessor} exports every ended span individually instead of batching spans together, which causes significant performance overhead with most exporters. For production use, please consider using the {@link BatchSpanProcessor} instead.\n */\nexport class SimpleSpanProcessor implements SpanProcessor {\n  private _shutdownOnce: BindOnceFuture<void>;\n  private _pendingExports: Set<Promise<void>>;\n\n  constructor(private readonly _exporter: SpanExporter) {\n    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n    this._pendingExports = new Set<Promise<void>>();\n  }\n\n  async forceFlush(): Promise<void> {\n    await Promise.all(Array.from(this._pendingExports));\n    if (this._exporter.forceFlush) {\n      await this._exporter.forceFlush();\n    }\n  }\n\n  onStart(_span: Span, _parentContext: Context): void {}\n\n  onEnd(span: ReadableSpan): void {\n    if (this._shutdownOnce.isCalled) {\n      return;\n    }\n\n    if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {\n      return;\n    }\n\n    const pendingExport = this._doExport(span).catch(err =>\n      globalErrorHandler(err)\n    );\n    // Enqueue this export to the pending list so it can be flushed by the user.\n    this._pendingExports.add(pendingExport);\n    pendingExport.finally(() => this._pendingExports.delete(pendingExport));\n  }\n\n  private async _doExport(span: ReadableSpan): Promise<void> {\n    if (span.resource.asyncAttributesPending) {\n      // Ensure resource is fully resolved before exporting.\n      await span.resource.waitForAsyncAttributes?.();\n    }\n\n    const result = await internal._export(this._exporter, [span]);\n    if (result.code !== ExportResultCode.SUCCESS) {\n      throw (\n        result.error ??\n        new Error(`SimpleSpanProcessor: span export failed (status ${result})`)\n      );\n    }\n  }\n\n  shutdown(): Promise<void> {\n    return this._shutdownOnce.call();\n  }\n\n  private _shutdown(): Promise<void> {\n    return this._exporter.shutdown();\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAgBA,SAAkBA,UAAU,QAAQ,oBAAoB;AACxD,SACEC,QAAQ,EACRC,gBAAgB,EAChBC,kBAAkB,EAClBC,cAAc,QACT,qBAAqB;AAM5B;;;;;;;;AAQA,OAAM,MAAOC,mBAAmB;EAIDC,SAAA;EAHrBC,aAAa;EACbC,eAAe;EAEvBC,YAA6BH,SAAuB;IAAvB,KAAAA,SAAS,GAATA,SAAS;IACpC,IAAI,CAACC,aAAa,GAAG,IAAIH,cAAc,CAAC,IAAI,CAACM,SAAS,EAAE,IAAI,CAAC;IAC7D,IAAI,CAACF,eAAe,GAAG,IAAIG,GAAG,EAAiB;EACjD;EAEA,MAAMC,UAAUA,CAAA;IACd,MAAMC,OAAO,CAACC,GAAG,CAACC,KAAK,CAACC,IAAI,CAAC,IAAI,CAACR,eAAe,CAAC,CAAC;IACnD,IAAI,IAAI,CAACF,SAAS,CAACM,UAAU,EAAE;MAC7B,MAAM,IAAI,CAACN,SAAS,CAACM,UAAU,EAAE;;EAErC;EAEAK,OAAOA,CAACC,KAAW,EAAEC,cAAuB,GAAS;EAErDC,KAAKA,CAACC,IAAkB;IACtB,IAAI,IAAI,CAACd,aAAa,CAACe,QAAQ,EAAE;MAC/B;;IAGF,IAAI,CAACD,IAAI,CAACE,WAAW,EAAE,CAACC,UAAU,GAAGxB,UAAU,CAACyB,OAAO,MAAM,CAAC,EAAE;MAC9D;;IAGF,MAAMC,aAAa,GAAG,IAAI,CAACC,SAAS,CAACN,IAAI,CAAC,CAACO,KAAK,CAACC,GAAG,IAClD1B,kBAAkB,CAAC0B,GAAG,CAAC,CACxB;IACD;IACA,IAAI,CAACrB,eAAe,CAACsB,GAAG,CAACJ,aAAa,CAAC;IACvCA,aAAa,CAACK,OAAO,CAAC,MAAM,IAAI,CAACvB,eAAe,CAACwB,MAAM,CAACN,aAAa,CAAC,CAAC;EACzE;EAEQ,MAAMC,SAASA,CAACN,IAAkB;IACxC,IAAIA,IAAI,CAACY,QAAQ,CAACC,sBAAsB,EAAE;MACxC;MACA,MAAMb,IAAI,CAACY,QAAQ,CAACE,sBAAsB,GAAE,CAAE;;IAGhD,MAAMC,MAAM,GAAG,MAAMnC,QAAQ,CAACoC,OAAO,CAAC,IAAI,CAAC/B,SAAS,EAAE,CAACe,IAAI,CAAC,CAAC;IAC7D,IAAIe,MAAM,CAACE,IAAI,KAAKpC,gBAAgB,CAACqC,OAAO,EAAE;MAC5C,MACEH,MAAM,CAACI,KAAK,IACZ,IAAIC,KAAK,CAAC,mDAAmDL,MAAM,GAAG,CAAC;;EAG7E;EAEAM,QAAQA,CAAA;IACN,OAAO,IAAI,CAACnC,aAAa,CAACoC,IAAI,EAAE;EAClC;EAEQjC,SAASA,CAAA;IACf,OAAO,IAAI,CAACJ,SAAS,CAACoC,QAAQ,EAAE;EAClC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { baggageEntryMetadataFromString } from '@opentelemetry/api';\nimport { BAGGAGE_ITEMS_SEPARATOR, BAGGAGE_PROPERTIES_SEPARATOR, BAGGAGE_KEY_PAIR_SEPARATOR, BAGGAGE_MAX_TOTAL_LENGTH } from './constants';\nexport function serializeKeyPairs(keyPairs) {\n  return keyPairs.reduce((hValue, current) => {\n    const value = `${hValue}${hValue !== '' ? BAGGAGE_ITEMS_SEPARATOR : ''}${current}`;\n    return value.length > BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;\n  }, '');\n}\nexport function getKeyPairs(baggage) {\n  return baggage.getAllEntries().map(([key, value]) => {\n    let entry = `${encodeURIComponent(key)}=${encodeURIComponent(value.value)}`;\n    // include opaque metadata if provided\n    // NOTE: we intentionally don't URI-encode the metadata - that responsibility falls on the metadata implementation\n    if (value.metadata !== undefined) {\n      entry += BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();\n    }\n    return entry;\n  });\n}\nexport function parsePairKeyValue(entry) {\n  const valueProps = entry.split(BAGGAGE_PROPERTIES_SEPARATOR);\n  if (valueProps.length <= 0) return;\n  const keyPairPart = valueProps.shift();\n  if (!keyPairPart) return;\n  const separatorIndex = keyPairPart.indexOf(BAGGAGE_KEY_PAIR_SEPARATOR);\n  if (separatorIndex <= 0) return;\n  const key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());\n  const value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());\n  let metadata;\n  if (valueProps.length > 0) {\n    metadata = baggageEntryMetadataFromString(valueProps.join(BAGGAGE_PROPERTIES_SEPARATOR));\n  }\n  return {\n    key,\n    value,\n    metadata\n  };\n}\n/**\n * Parse a string serialized in the baggage HTTP Format (without metadata):\n * https://github.com/w3c/baggage/blob/master/baggage/HTTP_HEADER_FORMAT.md\n */\nexport function parseKeyPairsIntoRecord(value) {\n  const result = {};\n  if (typeof value === 'string' && value.length > 0) {\n    value.split(BAGGAGE_ITEMS_SEPARATOR).forEach(entry => {\n      const keyPair = parsePairKeyValue(entry);\n      if (keyPair !== undefined && keyPair.value.length > 0) {\n        result[keyPair.key] = keyPair.value;\n      }\n    });\n  }\n  return result;\n}","map":{"version":3,"names":["baggageEntryMetadataFromString","BAGGAGE_ITEMS_SEPARATOR","BAGGAGE_PROPERTIES_SEPARATOR","BAGGAGE_KEY_PAIR_SEPARATOR","BAGGAGE_MAX_TOTAL_LENGTH","serializeKeyPairs","keyPairs","reduce","hValue","current","value","length","getKeyPairs","baggage","getAllEntries","map","key","entry","encodeURIComponent","metadata","undefined","toString","parsePairKeyValue","valueProps","split","keyPairPart","shift","separatorIndex","indexOf","decodeURIComponent","substring","trim","join","parseKeyPairsIntoRecord","result","forEach","keyPair"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/core/src/baggage/utils.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {\n  Baggage,\n  BaggageEntryMetadata,\n  baggageEntryMetadataFromString,\n} from '@opentelemetry/api';\nimport {\n  BAGGAGE_ITEMS_SEPARATOR,\n  BAGGAGE_PROPERTIES_SEPARATOR,\n  BAGGAGE_KEY_PAIR_SEPARATOR,\n  BAGGAGE_MAX_TOTAL_LENGTH,\n} from './constants';\n\ntype ParsedBaggageKeyValue = {\n  key: string;\n  value: string;\n  metadata: BaggageEntryMetadata | undefined;\n};\n\nexport function serializeKeyPairs(keyPairs: string[]): string {\n  return keyPairs.reduce((hValue: string, current: string) => {\n    const value = `${hValue}${\n      hValue !== '' ? BAGGAGE_ITEMS_SEPARATOR : ''\n    }${current}`;\n    return value.length > BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;\n  }, '');\n}\n\nexport function getKeyPairs(baggage: Baggage): string[] {\n  return baggage.getAllEntries().map(([key, value]) => {\n    let entry = `${encodeURIComponent(key)}=${encodeURIComponent(value.value)}`;\n\n    // include opaque metadata if provided\n    // NOTE: we intentionally don't URI-encode the metadata - that responsibility falls on the metadata implementation\n    if (value.metadata !== undefined) {\n      entry += BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();\n    }\n\n    return entry;\n  });\n}\n\nexport function parsePairKeyValue(\n  entry: string\n): ParsedBaggageKeyValue | undefined {\n  const valueProps = entry.split(BAGGAGE_PROPERTIES_SEPARATOR);\n  if (valueProps.length <= 0) return;\n  const keyPairPart = valueProps.shift();\n  if (!keyPairPart) return;\n  const separatorIndex = keyPairPart.indexOf(BAGGAGE_KEY_PAIR_SEPARATOR);\n  if (separatorIndex <= 0) return;\n  const key = decodeURIComponent(\n    keyPairPart.substring(0, separatorIndex).trim()\n  );\n  const value = decodeURIComponent(\n    keyPairPart.substring(separatorIndex + 1).trim()\n  );\n  let metadata;\n  if (valueProps.length > 0) {\n    metadata = baggageEntryMetadataFromString(\n      valueProps.join(BAGGAGE_PROPERTIES_SEPARATOR)\n    );\n  }\n  return { key, value, metadata };\n}\n\n/**\n * Parse a string serialized in the baggage HTTP Format (without metadata):\n * https://github.com/w3c/baggage/blob/master/baggage/HTTP_HEADER_FORMAT.md\n */\nexport function parseKeyPairsIntoRecord(\n  value?: string\n): Record<string, string> {\n  const result: Record<string, string> = {};\n\n  if (typeof value === 'string' && value.length > 0) {\n    value.split(BAGGAGE_ITEMS_SEPARATOR).forEach(entry => {\n      const keyPair = parsePairKeyValue(entry);\n\n      if (keyPair !== undefined && keyPair.value.length > 0) {\n        result[keyPair.key] = keyPair.value;\n      }\n    });\n  }\n\n  return result;\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAeA,SAGEA,8BAA8B,QACzB,oBAAoB;AAC3B,SACEC,uBAAuB,EACvBC,4BAA4B,EAC5BC,0BAA0B,EAC1BC,wBAAwB,QACnB,aAAa;AAQpB,OAAM,SAAUC,iBAAiBA,CAACC,QAAkB;EAClD,OAAOA,QAAQ,CAACC,MAAM,CAAC,CAACC,MAAc,EAAEC,OAAe,KAAI;IACzD,MAAMC,KAAK,GAAG,GAAGF,MAAM,GACrBA,MAAM,KAAK,EAAE,GAAGP,uBAAuB,GAAG,EAC5C,GAAGQ,OAAO,EAAE;IACZ,OAAOC,KAAK,CAACC,MAAM,GAAGP,wBAAwB,GAAGI,MAAM,GAAGE,KAAK;EACjE,CAAC,EAAE,EAAE,CAAC;AACR;AAEA,OAAM,SAAUE,WAAWA,CAACC,OAAgB;EAC1C,OAAOA,OAAO,CAACC,aAAa,EAAE,CAACC,GAAG,CAAC,CAAC,CAACC,GAAG,EAAEN,KAAK,CAAC,KAAI;IAClD,IAAIO,KAAK,GAAG,GAAGC,kBAAkB,CAACF,GAAG,CAAC,IAAIE,kBAAkB,CAACR,KAAK,CAACA,KAAK,CAAC,EAAE;IAE3E;IACA;IACA,IAAIA,KAAK,CAACS,QAAQ,KAAKC,SAAS,EAAE;MAChCH,KAAK,IAAIf,4BAA4B,GAAGQ,KAAK,CAACS,QAAQ,CAACE,QAAQ,EAAE;;IAGnE,OAAOJ,KAAK;EACd,CAAC,CAAC;AACJ;AAEA,OAAM,SAAUK,iBAAiBA,CAC/BL,KAAa;EAEb,MAAMM,UAAU,GAAGN,KAAK,CAACO,KAAK,CAACtB,4BAA4B,CAAC;EAC5D,IAAIqB,UAAU,CAACZ,MAAM,IAAI,CAAC,EAAE;EAC5B,MAAMc,WAAW,GAAGF,UAAU,CAACG,KAAK,EAAE;EACtC,IAAI,CAACD,WAAW,EAAE;EAClB,MAAME,cAAc,GAAGF,WAAW,CAACG,OAAO,CAACzB,0BAA0B,CAAC;EACtE,IAAIwB,cAAc,IAAI,CAAC,EAAE;EACzB,MAAMX,GAAG,GAAGa,kBAAkB,CAC5BJ,WAAW,CAACK,SAAS,CAAC,CAAC,EAAEH,cAAc,CAAC,CAACI,IAAI,EAAE,CAChD;EACD,MAAMrB,KAAK,GAAGmB,kBAAkB,CAC9BJ,WAAW,CAACK,SAAS,CAACH,cAAc,GAAG,CAAC,CAAC,CAACI,IAAI,EAAE,CACjD;EACD,IAAIZ,QAAQ;EACZ,IAAII,UAAU,CAACZ,MAAM,GAAG,CAAC,EAAE;IACzBQ,QAAQ,GAAGnB,8BAA8B,CACvCuB,UAAU,CAACS,IAAI,CAAC9B,4BAA4B,CAAC,CAC9C;;EAEH,OAAO;IAAEc,GAAG;IAAEN,KAAK;IAAES;EAAQ,CAAE;AACjC;AAEA;;;;AAIA,OAAM,SAAUc,uBAAuBA,CACrCvB,KAAc;EAEd,MAAMwB,MAAM,GAA2B,EAAE;EAEzC,IAAI,OAAOxB,KAAK,KAAK,QAAQ,IAAIA,KAAK,CAACC,MAAM,GAAG,CAAC,EAAE;IACjDD,KAAK,CAACc,KAAK,CAACvB,uBAAuB,CAAC,CAACkC,OAAO,CAAClB,KAAK,IAAG;MACnD,MAAMmB,OAAO,GAAGd,iBAAiB,CAACL,KAAK,CAAC;MAExC,IAAImB,OAAO,KAAKhB,SAAS,IAAIgB,OAAO,CAAC1B,KAAK,CAACC,MAAM,GAAG,CAAC,EAAE;QACrDuB,MAAM,CAACE,OAAO,CAACpB,GAAG,CAAC,GAAGoB,OAAO,CAAC1B,KAAK;;IAEvC,CAAC,CAAC;;EAGJ,OAAOwB,MAAM;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { diag } from '@opentelemetry/api';\nimport { isExportRetryable, parseRetryAfterToMills } from '../is-export-retryable';\nclass XhrTransport {\n  _parameters;\n  constructor(_parameters) {\n    this._parameters = _parameters;\n  }\n  send(data, timeoutMillis) {\n    return new Promise(resolve => {\n      const xhr = new XMLHttpRequest();\n      xhr.timeout = timeoutMillis;\n      xhr.open('POST', this._parameters.url);\n      const headers = this._parameters.headers();\n      Object.entries(headers).forEach(([k, v]) => {\n        xhr.setRequestHeader(k, v);\n      });\n      xhr.ontimeout = _ => {\n        resolve({\n          status: 'failure',\n          error: new Error('XHR request timed out')\n        });\n      };\n      xhr.onreadystatechange = () => {\n        if (xhr.status >= 200 && xhr.status <= 299) {\n          diag.debug('XHR success');\n          resolve({\n            status: 'success'\n          });\n        } else if (xhr.status && isExportRetryable(xhr.status)) {\n          resolve({\n            status: 'retryable',\n            retryInMillis: parseRetryAfterToMills(xhr.getResponseHeader('Retry-After'))\n          });\n        } else if (xhr.status !== 0) {\n          resolve({\n            status: 'failure',\n            error: new Error('XHR request failed with non-retryable status')\n          });\n        }\n      };\n      xhr.onabort = () => {\n        resolve({\n          status: 'failure',\n          error: new Error('XHR request aborted')\n        });\n      };\n      xhr.onerror = () => {\n        resolve({\n          status: 'failure',\n          error: new Error('XHR request errored')\n        });\n      };\n      xhr.send(data);\n    });\n  }\n  shutdown() {\n    // Intentionally left empty, nothing to do.\n  }\n}\n/**\n * Creates an exporter transport that uses XHR to send the data\n * @param parameters applied to each request made by transport\n */\nexport function createXhrTransport(parameters) {\n  return new XhrTransport(parameters);\n}","map":{"version":3,"names":["diag","isExportRetryable","parseRetryAfterToMills","XhrTransport","_parameters","constructor","send","data","timeoutMillis","Promise","resolve","xhr","XMLHttpRequest","timeout","open","url","headers","Object","entries","forEach","k","v","setRequestHeader","ontimeout","_","status","error","Error","onreadystatechange","debug","retryInMillis","getResponseHeader","onabort","onerror","shutdown","createXhrTransport","parameters"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/otlp-exporter-base/src/transport/xhr-transport.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IExporterTransport } from '../exporter-transport';\nimport { ExportResponse } from '../export-response';\nimport { diag } from '@opentelemetry/api';\nimport {\n  isExportRetryable,\n  parseRetryAfterToMills,\n} from '../is-export-retryable';\n\nexport interface XhrRequestParameters {\n  url: string;\n  headers: () => Record<string, string>;\n}\n\nclass XhrTransport implements IExporterTransport {\n  constructor(private _parameters: XhrRequestParameters) {}\n\n  send(data: Uint8Array, timeoutMillis: number): Promise<ExportResponse> {\n    return new Promise<ExportResponse>(resolve => {\n      const xhr = new XMLHttpRequest();\n      xhr.timeout = timeoutMillis;\n      xhr.open('POST', this._parameters.url);\n      const headers = this._parameters.headers();\n      Object.entries(headers).forEach(([k, v]) => {\n        xhr.setRequestHeader(k, v);\n      });\n\n      xhr.ontimeout = _ => {\n        resolve({\n          status: 'failure',\n          error: new Error('XHR request timed out'),\n        });\n      };\n\n      xhr.onreadystatechange = () => {\n        if (xhr.status >= 200 && xhr.status <= 299) {\n          diag.debug('XHR success');\n          resolve({\n            status: 'success',\n          });\n        } else if (xhr.status && isExportRetryable(xhr.status)) {\n          resolve({\n            status: 'retryable',\n            retryInMillis: parseRetryAfterToMills(\n              xhr.getResponseHeader('Retry-After')\n            ),\n          });\n        } else if (xhr.status !== 0) {\n          resolve({\n            status: 'failure',\n            error: new Error('XHR request failed with non-retryable status'),\n          });\n        }\n      };\n\n      xhr.onabort = () => {\n        resolve({\n          status: 'failure',\n          error: new Error('XHR request aborted'),\n        });\n      };\n      xhr.onerror = () => {\n        resolve({\n          status: 'failure',\n          error: new Error('XHR request errored'),\n        });\n      };\n\n      xhr.send(data);\n    });\n  }\n\n  shutdown() {\n    // Intentionally left empty, nothing to do.\n  }\n}\n\n/**\n * Creates an exporter transport that uses XHR to send the data\n * @param parameters applied to each request made by transport\n */\nexport function createXhrTransport(\n  parameters: XhrRequestParameters\n): IExporterTransport {\n  return new XhrTransport(parameters);\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAkBA,SAASA,IAAI,QAAQ,oBAAoB;AACzC,SACEC,iBAAiB,EACjBC,sBAAsB,QACjB,wBAAwB;AAO/B,MAAMC,YAAY;EACIC,WAAA;EAApBC,YAAoBD,WAAiC;IAAjC,KAAAA,WAAW,GAAXA,WAAW;EAAyB;EAExDE,IAAIA,CAACC,IAAgB,EAAEC,aAAqB;IAC1C,OAAO,IAAIC,OAAO,CAAiBC,OAAO,IAAG;MAC3C,MAAMC,GAAG,GAAG,IAAIC,cAAc,EAAE;MAChCD,GAAG,CAACE,OAAO,GAAGL,aAAa;MAC3BG,GAAG,CAACG,IAAI,CAAC,MAAM,EAAE,IAAI,CAACV,WAAW,CAACW,GAAG,CAAC;MACtC,MAAMC,OAAO,GAAG,IAAI,CAACZ,WAAW,CAACY,OAAO,EAAE;MAC1CC,MAAM,CAACC,OAAO,CAACF,OAAO,CAAC,CAACG,OAAO,CAAC,CAAC,CAACC,CAAC,EAAEC,CAAC,CAAC,KAAI;QACzCV,GAAG,CAACW,gBAAgB,CAACF,CAAC,EAAEC,CAAC,CAAC;MAC5B,CAAC,CAAC;MAEFV,GAAG,CAACY,SAAS,GAAGC,CAAC,IAAG;QAClBd,OAAO,CAAC;UACNe,MAAM,EAAE,SAAS;UACjBC,KAAK,EAAE,IAAIC,KAAK,CAAC,uBAAuB;SACzC,CAAC;MACJ,CAAC;MAEDhB,GAAG,CAACiB,kBAAkB,GAAG,MAAK;QAC5B,IAAIjB,GAAG,CAACc,MAAM,IAAI,GAAG,IAAId,GAAG,CAACc,MAAM,IAAI,GAAG,EAAE;UAC1CzB,IAAI,CAAC6B,KAAK,CAAC,aAAa,CAAC;UACzBnB,OAAO,CAAC;YACNe,MAAM,EAAE;WACT,CAAC;SACH,MAAM,IAAId,GAAG,CAACc,MAAM,IAAIxB,iBAAiB,CAACU,GAAG,CAACc,MAAM,CAAC,EAAE;UACtDf,OAAO,CAAC;YACNe,MAAM,EAAE,WAAW;YACnBK,aAAa,EAAE5B,sBAAsB,CACnCS,GAAG,CAACoB,iBAAiB,CAAC,aAAa,CAAC;WAEvC,CAAC;SACH,MAAM,IAAIpB,GAAG,CAACc,MAAM,KAAK,CAAC,EAAE;UAC3Bf,OAAO,CAAC;YACNe,MAAM,EAAE,SAAS;YACjBC,KAAK,EAAE,IAAIC,KAAK,CAAC,8CAA8C;WAChE,CAAC;;MAEN,CAAC;MAEDhB,GAAG,CAACqB,OAAO,GAAG,MAAK;QACjBtB,OAAO,CAAC;UACNe,MAAM,EAAE,SAAS;UACjBC,KAAK,EAAE,IAAIC,KAAK,CAAC,qBAAqB;SACvC,CAAC;MACJ,CAAC;MACDhB,GAAG,CAACsB,OAAO,GAAG,MAAK;QACjBvB,OAAO,CAAC;UACNe,MAAM,EAAE,SAAS;UACjBC,KAAK,EAAE,IAAIC,KAAK,CAAC,qBAAqB;SACvC,CAAC;MACJ,CAAC;MAEDhB,GAAG,CAACL,IAAI,CAACC,IAAI,CAAC;IAChB,CAAC,CAAC;EACJ;EAEA2B,QAAQA,CAAA;IACN;EAAA;;AAIJ;;;;AAIA,OAAM,SAAUC,kBAAkBA,CAChCC,UAAgC;EAEhC,OAAO,IAAIjC,YAAY,CAACiC,UAAU,CAAC;AACrC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
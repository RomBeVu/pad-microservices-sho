{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { hrTimeToNanoseconds } from '@opentelemetry/core';\nimport { hexToBinary } from './hex-to-binary';\nexport function hrTimeToNanos(hrTime) {\n  const NANOSECONDS = BigInt(1000000000);\n  return BigInt(hrTime[0]) * NANOSECONDS + BigInt(hrTime[1]);\n}\nexport function toLongBits(value) {\n  const low = Number(BigInt.asUintN(32, value));\n  const high = Number(BigInt.asUintN(32, value >> BigInt(32)));\n  return {\n    low,\n    high\n  };\n}\nexport function encodeAsLongBits(hrTime) {\n  const nanos = hrTimeToNanos(hrTime);\n  return toLongBits(nanos);\n}\nexport function encodeAsString(hrTime) {\n  const nanos = hrTimeToNanos(hrTime);\n  return nanos.toString();\n}\nconst encodeTimestamp = typeof BigInt !== 'undefined' ? encodeAsString : hrTimeToNanoseconds;\nfunction identity(value) {\n  return value;\n}\nfunction optionalHexToBinary(str) {\n  if (str === undefined) return undefined;\n  return hexToBinary(str);\n}\nconst DEFAULT_ENCODER = {\n  encodeHrTime: encodeAsLongBits,\n  encodeSpanContext: hexToBinary,\n  encodeOptionalSpanContext: optionalHexToBinary\n};\nexport function getOtlpEncoder(options) {\n  if (options === undefined) {\n    return DEFAULT_ENCODER;\n  }\n  const useLongBits = options.useLongBits ?? true;\n  const useHex = options.useHex ?? false;\n  return {\n    encodeHrTime: useLongBits ? encodeAsLongBits : encodeTimestamp,\n    encodeSpanContext: useHex ? identity : hexToBinary,\n    encodeOptionalSpanContext: useHex ? identity : optionalHexToBinary\n  };\n}","map":{"version":3,"names":["hrTimeToNanoseconds","hexToBinary","hrTimeToNanos","hrTime","NANOSECONDS","BigInt","toLongBits","value","low","Number","asUintN","high","encodeAsLongBits","nanos","encodeAsString","toString","encodeTimestamp","identity","optionalHexToBinary","str","undefined","DEFAULT_ENCODER","encodeHrTime","encodeSpanContext","encodeOptionalSpanContext","getOtlpEncoder","options","useLongBits","useHex"],"sources":["/home/senthilkumar/project/shopping-cart/frontend/node_modules/@opentelemetry/otlp-transformer/src/common/utils.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { OtlpEncodingOptions, Fixed64, LongBits } from './internal-types';\nimport { HrTime } from '@opentelemetry/api';\nimport { hrTimeToNanoseconds } from '@opentelemetry/core';\nimport { hexToBinary } from './hex-to-binary';\n\nexport function hrTimeToNanos(hrTime: HrTime): bigint {\n  const NANOSECONDS = BigInt(1_000_000_000);\n  return BigInt(hrTime[0]) * NANOSECONDS + BigInt(hrTime[1]);\n}\n\nexport function toLongBits(value: bigint): LongBits {\n  const low = Number(BigInt.asUintN(32, value));\n  const high = Number(BigInt.asUintN(32, value >> BigInt(32)));\n  return { low, high };\n}\n\nexport function encodeAsLongBits(hrTime: HrTime): LongBits {\n  const nanos = hrTimeToNanos(hrTime);\n  return toLongBits(nanos);\n}\n\nexport function encodeAsString(hrTime: HrTime): string {\n  const nanos = hrTimeToNanos(hrTime);\n  return nanos.toString();\n}\n\nconst encodeTimestamp =\n  typeof BigInt !== 'undefined' ? encodeAsString : hrTimeToNanoseconds;\n\nexport type HrTimeEncodeFunction = (hrTime: HrTime) => Fixed64;\nexport type SpanContextEncodeFunction = (\n  spanContext: string\n) => string | Uint8Array;\nexport type OptionalSpanContextEncodeFunction = (\n  spanContext: string | undefined\n) => string | Uint8Array | undefined;\n\nexport interface Encoder {\n  encodeHrTime: HrTimeEncodeFunction;\n  encodeSpanContext: SpanContextEncodeFunction;\n  encodeOptionalSpanContext: OptionalSpanContextEncodeFunction;\n}\n\nfunction identity<T>(value: T): T {\n  return value;\n}\n\nfunction optionalHexToBinary(str: string | undefined): Uint8Array | undefined {\n  if (str === undefined) return undefined;\n  return hexToBinary(str);\n}\n\nconst DEFAULT_ENCODER: Encoder = {\n  encodeHrTime: encodeAsLongBits,\n  encodeSpanContext: hexToBinary,\n  encodeOptionalSpanContext: optionalHexToBinary,\n};\n\nexport function getOtlpEncoder(options?: OtlpEncodingOptions): Encoder {\n  if (options === undefined) {\n    return DEFAULT_ENCODER;\n  }\n\n  const useLongBits = options.useLongBits ?? true;\n  const useHex = options.useHex ?? false;\n  return {\n    encodeHrTime: useLongBits ? encodeAsLongBits : encodeTimestamp,\n    encodeSpanContext: useHex ? identity : hexToBinary,\n    encodeOptionalSpanContext: useHex ? identity : optionalHexToBinary,\n  };\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAkBA,SAASA,mBAAmB,QAAQ,qBAAqB;AACzD,SAASC,WAAW,QAAQ,iBAAiB;AAE7C,OAAM,SAAUC,aAAaA,CAACC,MAAc;EAC1C,MAAMC,WAAW,GAAGC,MAAM,CAAC,UAAa,CAAC;EACzC,OAAOA,MAAM,CAACF,MAAM,CAAC,CAAC,CAAC,CAAC,GAAGC,WAAW,GAAGC,MAAM,CAACF,MAAM,CAAC,CAAC,CAAC,CAAC;AAC5D;AAEA,OAAM,SAAUG,UAAUA,CAACC,KAAa;EACtC,MAAMC,GAAG,GAAGC,MAAM,CAACJ,MAAM,CAACK,OAAO,CAAC,EAAE,EAAEH,KAAK,CAAC,CAAC;EAC7C,MAAMI,IAAI,GAAGF,MAAM,CAACJ,MAAM,CAACK,OAAO,CAAC,EAAE,EAAEH,KAAK,IAAIF,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC;EAC5D,OAAO;IAAEG,GAAG;IAAEG;EAAI,CAAE;AACtB;AAEA,OAAM,SAAUC,gBAAgBA,CAACT,MAAc;EAC7C,MAAMU,KAAK,GAAGX,aAAa,CAACC,MAAM,CAAC;EACnC,OAAOG,UAAU,CAACO,KAAK,CAAC;AAC1B;AAEA,OAAM,SAAUC,cAAcA,CAACX,MAAc;EAC3C,MAAMU,KAAK,GAAGX,aAAa,CAACC,MAAM,CAAC;EACnC,OAAOU,KAAK,CAACE,QAAQ,EAAE;AACzB;AAEA,MAAMC,eAAe,GACnB,OAAOX,MAAM,KAAK,WAAW,GAAGS,cAAc,GAAGd,mBAAmB;AAgBtE,SAASiB,QAAQA,CAAIV,KAAQ;EAC3B,OAAOA,KAAK;AACd;AAEA,SAASW,mBAAmBA,CAACC,GAAuB;EAClD,IAAIA,GAAG,KAAKC,SAAS,EAAE,OAAOA,SAAS;EACvC,OAAOnB,WAAW,CAACkB,GAAG,CAAC;AACzB;AAEA,MAAME,eAAe,GAAY;EAC/BC,YAAY,EAAEV,gBAAgB;EAC9BW,iBAAiB,EAAEtB,WAAW;EAC9BuB,yBAAyB,EAAEN;CAC5B;AAED,OAAM,SAAUO,cAAcA,CAACC,OAA6B;EAC1D,IAAIA,OAAO,KAAKN,SAAS,EAAE;IACzB,OAAOC,eAAe;;EAGxB,MAAMM,WAAW,GAAGD,OAAO,CAACC,WAAW,IAAI,IAAI;EAC/C,MAAMC,MAAM,GAAGF,OAAO,CAACE,MAAM,IAAI,KAAK;EACtC,OAAO;IACLN,YAAY,EAAEK,WAAW,GAAGf,gBAAgB,GAAGI,eAAe;IAC9DO,iBAAiB,EAAEK,MAAM,GAAGX,QAAQ,GAAGhB,WAAW;IAClDuB,yBAAyB,EAAEI,MAAM,GAAGX,QAAQ,GAAGC;GAChD;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}